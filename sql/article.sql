/*
 Navicat Premium Data Transfer

 Source Server         : aliyun
 Source Server Type    : MySQL
 Source Server Version : 50560
 Source Host           : 39.108.166.59:3306
 Source Schema         : tuclown

 Target Server Type    : MySQL
 Target Server Version : 50560
 File Encoding         : 65001

 Date: 10/04/2019 19:20:59
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `body` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `image` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `created_time` datetime NOT NULL,
  `modified_time` datetime NOT NULL,
  `status` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `abstract` varchar(54) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `views` int(10) UNSIGNED NOT NULL,
  `likes` int(10) UNSIGNED NOT NULL,
  `topped` tinyint(1) NOT NULL,
  `author` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `category_id` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_category_id_99127861_fk_category_id`(`category_id`) USING BTREE,
  CONSTRAINT `article_category_id_99127861_fk_category_id` FOREIGN KEY (`category_id`) REFERENCES `category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 145 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, 'django -- 文件上传至七牛云', '---\r\n\r\n![][1]\r\n\r\n<p><center>青梅枯萎，竹马老去，从此我爱上的人都像你</center></p>\r\n\r\n\r\n\r\n------\r\n### 说明\r\n因为考虑到本地存储的不方便性，于是在上网找到了相关的插件 django-qiniu-storage\r\n\r\n> 官网：[http://django-qiniu-storage.readthedocs.io/zh_CN/latest/][2]\r\n\r\n----------\r\n### 各项配置\r\n0. 安装\r\n```\r\npip install django-qiniu-storage\r\n```\r\n\r\n安装的时候出现了超时连接的问题，于是就使用了国内镜像安装\r\n```\r\npip  install --index https://pypi.mirrors.ustc.edu.cn/simple/ django-qiniu-storage \r\n```\r\n\r\n有意思的是，这个插件竟然不用放到 settting.py 中的 INSTALLED_APPS \r\n\r\n1. 登录或者注册七牛云获取以下数据,具体地操作可以自行百度\r\n```\r\nQINIU_ACCESS_KEY = \'**\'    # AK\r\nQINIU_SECRET_KEY = \'**\'    # SK\r\nQINIU_BUCKET_NAME = \'django\'   # 存储空间名字\r\nQINIU_BUCKET_DOMAIN = \'p9w6udf2c.bkt.clouddn.com\' # 外链的前缀\r\n```\r\n\r\n2. 配置 `settings.py`\r\n```\r\nQINIU_ACCESS_KEY = \'**\'\r\nQINIU_SECRET_KEY = \'**\'\r\nQINIU_BUCKET_NAME = \'django\'\r\nQINIU_BUCKET_DOMAIN = \'p9w6udf2c.bkt.clouddn.com\'\r\nQINIU_SECURE_URL = False   # 使用http\r\n\r\n# http://csn.pinsily.site/10-18818.jpg\r\n\r\nPREFIX_URL = \'http://\'\r\n\r\nMEDIA_URL = PREFIX_URL + QINIU_BUCKET_DOMAIN + \'/media/\'\r\n#MEDIA_ROOT = os.path.join(BASE_DIR, \'media\')\r\nMEDIA_ROOT = \'media/\'\r\n\r\nDEFAULT_FILE_STORAGE = \'qiniustorage.backends.QiniuMediaStorage\'\r\n```\r\n\r\n这里需要注意的是 `MEDIA_ROOT` 的值不要还是按照原来本地文件上传时的配置，`MEDIA_ROOT = os.path.join(BASE_DIR, \'media\')`，这样会失败的\r\n\r\n参考：`https://www.jianshu.com/p/6b543668462b`\r\n\r\n\r\n3. 配置 `models`\r\n```python\r\nclass Article(models.Model):\r\n    #image = models.FileField() # 这里什么参数都不用\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/PJ.jpg\r\n  [2]: http://django-qiniu-storage.readthedocs.io/zh_CN/latest/', '1.jpg', '2018-06-08 15:09:00', '2019-04-10 09:52:32', 'p', '因为考虑到本地存储的不方便性，于是在上网找到了相关的插件 django-qiniu-storage', 274, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (2, 'django -- 文件上传至本地', '---\r\n\r\n![][1]\r\n\r\n<p><center>他的路在西风的袍袖中,在夕阳的咽喉里</center></p>\r\n\r\n\r\n----------\r\n### 说明\r\n之前看官网一直搞不明白，现在重新折腾了一下，并实现了效果\r\n\r\n------\r\n### 各项配置\r\n1. 配置 MEDIA 路径\r\n\r\n``` python\r\n# setting.py\r\n\r\nMEDIA_ROOT = os.path.join(BASE_DIR, \'media\')\r\nMEDIA_URL = \'/media/\'\r\n```\r\n\r\n```python\r\n# 根目录 urls.py\r\n\r\nfrom django.conf import settings\r\nfrom django.conf.urls.static import static\r\n\r\nif settings.DEBUG:\r\n    urlpatterns += static(settings.MEDIA_URL,\r\n                          document_root=settings.MEDIA_ROOT)\r\n\r\n```\r\n\r\n需要在项目根目录下创建一个 `media` 文件夹，Django 社区是默认这样的，也可以根据自己的需要有所更改\r\n\r\n\r\n2. 配置 models\r\n```python\r\nclass Article(models.Model):\r\n    #image = models.FileField(upload_to=\'blog/uploads/\')\r\n```\r\n\r\n`uploads_to` 的参数指的是上传的文件将存储在 `MEDIA_ROOT\\blog\\uploads` 文件夹中\r\n\r\n3. 迁移进数据库中\r\n```shell\r\n$ python manage.py makemigrations\r\n$ python manage.py migrate\r\n```\r\n\r\n4. 模板中使用\r\n```\r\n{{ article.image.url }}\r\n```\r\n\r\narticle 是一个文章对象，需要注意的是需要使用到 `url`，如果直接使用 `article.image`是访问不到的\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/BklynBrdge.jpg', '10-2758.jpg', '2018-06-08 15:12:00', '2019-03-30 08:26:37', 'p', '之前看官网一直搞不明白，现在重新折腾了一下，并实现了效果', 123, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (3, 'django -- 模板中获得结果集的长度', '---\r\n\r\n![][1]\r\n\r\n<p><center>如果，我多一张船票，你会不会跟我一起走？ ——花样年华</center></p>\r\n\r\n\r\n----------\r\n### 参考\r\n> [https://stackoverflow.com/questions/6495563/what-is-the-django-template-tag-to-get-the-number-of-items-returned-in-a-result?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa][2]\r\n\r\n----------\r\n### 方法\r\n可以直接使用模板中的过滤器 length：\r\n\r\n``` python\r\n{{ articles|length }}\r\n```\r\n\r\n\r\n------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/SpringtimeinGiverny.jpg\r\n  [2]: https://stackoverflow.com/questions/6495563/what-is-the-django-template-tag-to-get-the-number-of-items-returned-in-a-result?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa', '10-13703.jpg', '2018-06-08 15:13:00', '2019-04-05 14:06:03', 'p', '如果，我多一张船票，你会不会跟我一起走？', 109, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (4, 'django -- xadmin 自定义右侧菜单栏', '---\r\n\r\n![][1]\r\n\r\n<p><center>时间的沙漏沉淀着无法逃离的过往,记忆的双手总是拾起那些明媚的忧伤</center></p>\r\n\r\n------\r\n### 说明\r\nxadmin 默认的菜单栏包含了 Reversion，权限管理等选项，但是一般是用不上的，于是想着办法将其去掉，可以被逼着去翻了源码才搞定了\r\n\r\n----------\r\n### 修改\r\n[源码解析地址][2]\r\n\r\n主要用到的是视图类 `CommAdminView` 中 `get_site_menu()` 和 `get_nav_menu()` 方法，前一个是自定义增加菜单栏的，后一个是将增加的菜单栏合并到原来的菜单栏中并返回新的菜单栏集合，思路就是将返回的新集合只包含新增的菜单栏\r\n\r\n```python\r\n# adminx.py\r\nclass GlobalSetting(object):\r\n    site_title = \"Pinsily.blog\"\r\n    site_footer = \'pinsily blog\'\r\n    # menu_style = \'accordion\'\r\n\r\n    # 自定义新增菜单栏\r\n    def get_site_menu(self):\r\n        return (\r\n            {\'title\': \'Blog\', \'perm\': self.get_model_perm(Article, \'change\'), \'menus\': (\r\n                {\'title\': \'Article\', \'url\': self.get_model_url(\r\n                    Article, \'changelist\')},\r\n                {\'title\': \'Category\', \'url\': self.get_model_url(\r\n                    Category, \'changelist\')},\r\n                {\'title\': \'BlogComment\', \'url\': self.get_model_url(\r\n                    BlogComment, \'changelist\')},\r\n                {\'title\': \'Tag\', \'url\': self.get_model_url(Tag, \'changelist\')},\r\n                {\'title\': \'OneModel\', \'url\': self.get_model_url(\r\n                    OneModel, \'changelist\')},\r\n            )},\r\n        )\r\n\r\n    def get_nav_menu(self):\r\n        # 直接返回新增的菜单栏，源码中还有很大一部分的合并功能\r\n        site_menu = list(self.get_site_menu() or [])\r\n        return site_menu\r\n\r\n\r\nxadmin.site.register(xadmin.views.CommAdminView, GlobalSetting)\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/SatelliteGlades.jpg\r\n  [2]: http://xadmin.readthedocs.io/en/docs-chinese/_modules/xadmin/views/base.html', '10-17351.jpg', '2018-06-08 15:14:00', '2019-04-09 11:04:56', 'p', 'xadmin 默认的菜单栏包含了 Reversion，权限管理等选项，但是一般是用不上的，于是想着办法将其去', 660, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (5, 'django -- ajax 403 错误', '---\r\n![][1]\r\n<p><center>早知如此绊人心，何如当初莫相识。 ——秋风词</center></p>\r\n\r\n------\r\n### 说明\r\n在使用 ajax 实现文章点赞功能的时候，请求出现了 403 的错误\r\n```shell\r\nPOST http://localhost:8000/likes/1 403 (FORBIDDEN)\r\n```\r\n\r\n\r\n----------\r\n### 解决\r\n在官网上已经有了相应的解决方法和实例，出现这个问题的主要原因是没有添加 csrf 认证,解决的基本原理就是在post数据里面添加csrf信息\r\n> AJAX  \r\n> While the above method can be used for AJAX POST requests, it has some inconveniences: you have to remember to pass the CSRF token in as POST data with every POST request. For this reason, there is an alternative method: on each XMLHttpRequest, set a custom X-CSRFToken header to the value of the CSRF token. This is often easier, because many JavaScript frameworks provide hooks that allow headers to be set on every request.  \r\n> As a first step, you must get the CSRF token itself. The recommended source for the token is the > csrftoken cookie, which will be set if you’ve enabled CSRF protection for your views as outlined above. \r\n\r\n将下面的代码添加到同一个 ajax js 文件中或代码片段中即可解决问题\r\n```javascript\r\nfunction getCookie(name) {  \r\n    var cookieValue = null;  \r\n    if (document.cookie && document.cookie != \'\') {  \r\n        var cookies = document.cookie.split(\';\');  \r\n        for (var i = 0; i < cookies.length; i++) {  \r\n            var cookie = jQuery.trim(cookies[i]);  \r\n            // Does this cookie string begin with the name we want?  \r\n            if (cookie.substring(0, name.length + 1) == (name + \'=\')) {  \r\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));  \r\n                break;  \r\n            }  \r\n        }  \r\n    }  \r\n    return cookieValue;  \r\n}  \r\n  \r\nfunction csrfSafeMethod(method) {  \r\n    // these HTTP methods do not require CSRF protection  \r\n    return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));  \r\n}  \r\n$.ajaxSetup({  \r\n    beforeSend: function(xhr, settings) {  \r\n    var csrftoken = getCookie(\'csrftoken\');       \r\n    if (!csrfSafeMethod(settings.type) && !this.crossDomain) {  \r\n            xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);  \r\n        }  \r\n    }  \r\n});  \r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/MozambiqueSandbar.jpg', '10-18818.jpg', '2018-06-08 15:15:00', '2019-04-01 09:32:32', 'p', '在使用 ajax 实现文章点赞功能的时候，请求出现了 403 的错误', 143, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (6, 'django -- 自定义数据库表名', '---\r\n\r\n![][1]\r\n\r\n<p><center>雨，何时停？ ——秋之回忆</center></p>\r\n\r\n------\r\n### 说明\r\n\r\ndjango 自动生成的表名是 app 名和 model 名的组合，如果想改变的话，自定义 db_table 属性就行了\r\n\r\n```python\r\nfrom django.db import models\r\n\r\n\r\nclass UserModel(models.Model):\r\n    username = models.CharField(max_length=100, default=\"\", verbose_name=u\"用户名\")\r\n    password = models.CharField(max_length=100, default=\"\", verbose_name=u\"密码\")\r\n    \r\n    class Meta:\r\n        db_table = \"userprofile\"\r\n\r\n```\r\n\r\n----------\r\n\r\n[1]: http://cdn.pinsily.site/ResplendentQuetzal.jpg', '10-23733_6rrnMPO.jpg', '2018-06-08 15:16:00', '2019-04-03 12:02:39', 'p', 'django 自动生成的表名是 app 名和 model 名的组合，如果想改变的话，自定义 db_table', 135, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (7, 'django -- Abstract User Error', '---\r\n\r\n![][1]\r\n\r\n<p><center>回头皆幻景，对面知是谁。 ——牡丹亭</center></p>\r\n\r\n------\r\n### 问题\r\n在使用 AbstractUser 扩展用户的时候，数据库迁移时出现了一下错误\r\n```\r\nReverse accessor for \'User.groups\' clashes with reverse accessor for \'UserModel.groups\'.\r\nHINT: Add or change a related_name argument to the definition for \'User.groups\' or \'UserModel.groups\'.\r\n```\r\n\r\n\r\n----------\r\n### 解决\r\n在 settings.py 中增加相关变量，让 django 知道那个是用户管理 model\r\n```\r\nAUTH_USER_MODEL = \'user_admin.UserModel\'\r\n```\r\n\r\n`user_admin` 为 app 名字， `UserModel` 为所用用户 model\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-85058.jpg', '10-26520.jpg', '2018-06-08 15:17:00', '2019-04-07 19:30:44', 'p', '在使用 AbstractUser 扩展用户的时候，数据库迁移时出现了一下错误', 396, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (8, 'django -- 获得当前时间', '---\r\n\r\n![][1]\r\n\r\n<p><center>一朝春尽红颜老，花落人亡两不知。 ——红楼梦</center></p>\r\n\r\n------\r\n### 前言\r\n> 之前使用 django 的时候，都是原始的方法获得时间，发现 django 以自带有获得时间的包了\r\n\r\n----------\r\n### 使用\r\n- settings.py\r\n```python\r\nTIME_ZONE = \'Asia/Shanghai\'\r\n```\r\n\r\n- 其他文件\r\n```python\r\nfrom django.utils import timezone\r\n\r\ncreate_time = timezone.localtime(timezone.now())\r\n# datetime.datetime(2018, 3, 17, 19, 34, 53, 993815, tzinfo=<DstTzInfo \'Asia/Shanghai\' CST+8:00:00 STD>)\r\n\r\n# 可以获得相应的年月日\r\nyear = create_time.year\r\nday = create_time.day\r\n\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-85431.jpg', '10-48541_IGlTFEl.jpg', '2018-06-08 15:18:00', '2019-04-06 20:51:11', 'p', '之前使用 django 的时候，都是原始的方法获得时间，发现 django 以自带有获得时间的包了', 143, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (9, 'django  -- static 静态文件', '----------\r\n\r\n![][1]\r\n\r\n<center><p>我们确实有如是的优点，但也要隐藏几分，这个叫做涵养</p></center>\r\n\r\n\r\n----------\r\n### 简单说明\r\n关于静态文件的保存使用，应该保存下来的目录习惯，构建项目时将文件放到 app 中，css 文件目录为 `appname/static/appname/style.css`，图片等目录为 `apname/static/appname/image/1.jpg`，之所以加多一层 `appname` 目录，是因为防止多个 app 中存在相同名称的文件，导致出错\r\n\r\n当项目部署时，将所有文件搜集到项目根目录下的 `static/` 中\r\n\r\n---------\r\n### app 下配置\r\n1. 确保 app 在  INSTALLED_APPS 中\r\n2. `settings.py`\r\n```python\r\nSTATIC_URL = \'/static/\'\r\n```\r\n3. 在 app 下新建 static 文件夹并新建相应文件\r\n4. 引用`/static/appname/style.css`\r\n```\r\n{% load static %}\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"{% static \"appname/style.css\" %}\">\r\n```\r\n\r\n\r\n\r\n----------\r\n### 根目录下\r\n1. `settings.py`\r\n```\r\nimport os \r\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\r\n\r\nSTATICFILES_DIRS = [\r\n    os.path.join(BASE_DIR, \"static\")\r\n]\r\n```\r\n\r\n2. 在根目录下新建 static 文件夹并新建文件\r\n3. 引用 `/static/css/style.css`\r\n```\r\n{% load static %}\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"{% static \"css/style.css\" %}\">\r\n```\r\n\r\n\r\n----------\r\n### 优先级设置\r\n```python\r\nSTATICFILES_FINDERS = (\r\n    \"django.contrib.staticfiles.finders.FileSystemFinder\",\r\n    \"django.contrib.staticfiles.finders.AppDirectoriesFinder\"\r\n)\r\n```\r\n\r\n\r\n----------\r\n### 部署使用\r\n1. 设置 `static_root`\r\n```python\r\nSTATIC_ROOT = os.path.join(BASE_DIR, \'collected_static\')\r\n```\r\n\r\n2. 收集静态文件\r\n```\r\npython manage.py collectstatic\r\n```\r\n3. nginx 部署\r\n```\r\nlocation /static {\r\n    alias /path/to/project/collected_static;\r\n}\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%A7%86%E8%A7%89%20-%201.jpg', '10-55009.jpg', '2018-06-08 15:19:00', '2019-04-01 06:13:09', 'p', '我们确实有如是的优点，但也要隐藏几分，这个叫做涵养', 132, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (10, 'django -- templates', '----------\r\n![][1]\r\n\r\n<center><p>所谓现实，“发生”的并非实体，而是现象</p></center>\r\n\r\n---------\r\n### 配置信息\r\n```python\r\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\r\n```\r\n\r\n```python\r\nTEMPLATES = [\r\n    {\r\n        \'BACKEND\': \'django.template.backends.django.DjangoTemplates\',\r\n        \'DIRS\': [os.path.join(BASE_DIR, \'templates\')],\r\n        \'APP_DIRS\': True,\r\n        \'OPTIONS\': {\r\n            \'context_processors\': [\r\n                \'django.template.context_processors.debug\',\r\n                \'django.template.context_processors.request\',\r\n                \'django.contrib.auth.context_processors.auth\',\r\n                \'django.contrib.messages.context_processors.messages\',\r\n            ],\r\n        },\r\n    },\r\n]\r\n```\r\n\r\n#### 简单说明\r\n1. APP_DIRS : 是否使用 APP 下的 templates 目录，貌似是优先\r\n2. DIRS : templates 目录的路径集合，django 会按照排列顺序进行查找\r\n3. BACKEND : 后端类接口，保持默认即可,虽然其中还是挺多学问的\r\n\r\n----------\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%AE%BE%E8%AE%A1%20-%207.jpg', '10-85431.jpg', '2018-06-08 15:20:00', '2019-04-03 13:47:28', 'p', '所谓现实，“发生”的并非实体，而是现象', 151, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (11, 'django -- js 交互', '----------\r\n\r\n![][1]\r\n\r\n<center><p>她走了，一位风一般的佳人</p></center>\r\n\r\n---------\r\n### 前言\r\ndjango 与 js 的交互主要有两种:\r\n- js 不需要处理\r\n- js 需要处理\r\n\r\n----------\r\n### js 不需要处理\r\n直接使用 django 模板传递\r\n\r\n\r\n----------\r\n### js 需要处理\r\n直接传递使用的话会报错\r\n```\r\nUncaught SyntaxError: Unexpected token ILLEGAL\r\n```\r\n\r\n#### 解决方法\r\n- 视图函数中的字典或列表要用 json.dumps() 处理\r\n- 在模板上要加 safe 过滤器\r\n\r\nviews.py\r\n```\r\n# -*- coding: utf-8 -*-\r\n \r\nfrom __future__ import unicode_literals\r\n \r\nimport json\r\nfrom django.shortcuts import render\r\n \r\ndef home(request):\r\n    List = [\'one\', \'two\']\r\n    return render(request, \'home.html\', {\r\n            \'List\': json.dumps(List)\r\n        })\r\n```\r\n\r\nhome.html(部分)\r\n```\r\n<script type=\"text/javascript\">\r\n    var List = {{ List|safe }};\r\n</script>\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E5%8A%A8%E6%BC%AB%20-%208.jpg', '10-85760.jpg', '2018-06-08 15:21:00', '2019-04-05 16:46:06', 'p', 'django 与 js 的交互主要有两种', 198, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (12, 'docker 笔记(0) -- 概述', '--------\r\n![][1]\r\n\r\n<center>摆脱了奴役和罪恶的束缚，摆脱了庸俗和野蛮，生命就显得有生气了。</center>\r\n\r\n----------\r\n### Docker 是什么\r\n百度百科\r\n> Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。\r\n\r\n\r\n就自己所了解的一些，docker 相当于是简化版的虚拟机，但是又跟虚拟机有着不同，在使用时，docker 又相当于一个程序在运作了，不用像虚拟机那样配置各种内存、空间等等，所以说，docker 既有虚拟机的独立性，又没有虚拟机的繁杂\r\n\r\n\r\n一个完整的 docker 包含以下部分：\r\n1. dockerClient 客户端\r\n2. Docker Daemon 守护进程\r\n3. Docker Image 镜像\r\n4. DockerContainer 容器\r\n\r\n上面的前两项自不必说，客户端和进程对程序来说再正常不过，那么镜像和容器呢\r\n\r\n容器是 docker 进行独立的一个箱子，也就是上面所说的沙盒模型，在这个容器当中，我们可以放入相应的镜像，以获得不同的操作系统进行试验\r\n\r\n要有镜像，就要有获取的途径，docker 自身有一个远程镜像仓库 Docker Hub，里面存放在已经打包好的各种镜像，方便性来讲算是超然的了\r\n\r\n\r\n开始的界面\r\n\r\n![][2]\r\n\r\n可以找到许多相关的镜像\r\n\r\n![][3]\r\n\r\n当我们构建容器执行镜像文件时，如果 docker 发现本地没有此镜像文件的话，就自动在这里下载了\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/1508573197221.jpg \r\n  [2]: http://cdn.pinsily.site/1508573197736.jpg\r\n  [3]: http://cdn.pinsily.site/1508573197741.jpg', 'DandelionXray.jpg', '2017-10-21 12:11:00', '2019-04-03 19:48:38', 'p', 'Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中', 136, 0, 0, 'pinsily', 2);
INSERT INTO `article` VALUES (13, 'docker 笔记(1) -- 安装', '---\r\n\r\n![][1]\r\n<center>一段关系无解，不是任何人的错，那么我们就把悲伤藏在心底。微笑着，说再见。</center>\r\n\r\n----------\r\n\r\n###  参考\r\n[菜鸟教程 -- docker][2]\r\n\r\n[2]: http://www.runoob.com/docker/docker-tutorial.html\r\n\r\n----------\r\n\r\n\r\n### 前提条件\r\n>docker 要求 Ubuntu 系统的内核版本高于 3.10\r\n\r\n```shell\r\nroot@pinsily:~# uname -r\r\n4.4.0-79-generic\r\n```\r\n\r\n----------\r\n\r\n### 使用脚本安装 Docker\r\n#### 1. 获取最新版本的 Docker 安装包\r\n\r\n```shell\r\nroot@pinsily:~# wget -qO- https://get.docker.com/ | sh\r\n```\r\n\r\n开始下载脚本并且安装 Docker 及依赖包\r\n```shell\r\n\r\n# Executing docker install script, commit: 490beaa\r\n+ sh -c apt-get update -qq >/dev/null\r\n+ sh -c apt-get install -y -qq apt-transport-https ca-certificates curl software-properties-common >/dev/null\r\n+ sh -c curl -fsSL \"https://download.docker.com/linux/ubuntu/gpg\" | apt-key add -qq - >/dev/null\r\n+ sh -c echo \"deb [arch=amd64] https://download.docker.com/linux/ubuntu trusty edge\" > /etc/apt/sources.list.d/docker.list\r\n+ [ ubuntu = debian ]\r\n+ sh -c apt-get update -qq >/dev/null\r\n+ sh -c apt-get install -y -qq docker-ce >/dev/null\r\n+ sh -c docker version\r\nClient:\r\n Version:      17.10.0-ce\r\n API version:  1.33\r\n Go version:   go1.8.3\r\n Git commit:   f4ffd25\r\n Built:        Tue Oct 17 19:04:40 2017\r\n OS/Arch:      linux/amd64\r\n\r\nServer:\r\n Version:      17.10.0-ce\r\n API version:  1.33 (minimum version 1.12)\r\n Go version:   go1.8.3\r\n Git commit:   f4ffd25\r\n Built:        Tue Oct 17 19:03:20 2017\r\n OS/Arch:      linux/amd64\r\n Experimental: false\r\n\r\n\r\n```\r\n\r\n后面还有一段提示\r\n```shell\r\nIf you would like to use Docker as a non-root user, you should now consider\r\nadding your user to the \"docker\" group with something like:\r\n\r\n  sudo usermod -aG docker your-user\r\n\r\nRemember that you will have to log out and back in for this to take effect!\r\n\r\n```\r\n\r\n如果是非 root 用户的话，就需要留意这条信息，在启动 docker 时需要先执行命令，`your-user`是当前用户名 \r\n```shell\r\nsudo usermod -aG docker your-user\r\n```\r\n\r\n#### 2. 启动docker 后台服务\r\n```\r\nroot@pinsily:~# service docker start\r\n```\r\n\r\n#### 3. 测试运行\r\n```shell\r\nroot@pinsily:~# docker run hello-world\r\n```\r\n\r\n因为本地没有这个 hello-world 的镜像，所以它会自动从远程库 Docker Hub  中下载\r\n```\r\nUnable to find image \'hello-world:latest\' locally\r\nlatest: Pulling from library/hello-world\r\n5b0f327be733: Pull complete\r\nDigest: sha256:07d5f7800dfe37b8c2196c7b1c524c33808ce2e0f74e7aa00e603295ca9a0972\r\nStatus: Downloaded newer image for hello-world:latest\r\n```\r\n\r\n下面是测试的结果\r\n```shell\r\nHello from Docker!\r\nThis message shows that your installation appears to be working correctly.\r\n\r\nTo generate this message, Docker took the following steps:\r\n 1. The Docker client contacted the Docker daemon.\r\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\r\n 3. The Docker daemon created a new container from that image which runs the\r\n    executable that produces the output you are currently reading.\r\n 4. The Docker daemon streamed that output to the Docker client, which sent it\r\n    to your terminal.\r\n\r\nTo try something more ambitious, you can run an Ubuntu container with:\r\n $ docker run -it ubuntu bash\r\n\r\nShare images, automate workflows, and more with a free Docker ID:\r\n https://cloud.docker.com/\r\n\r\nFor more examples and ideas, visit:\r\n https://docs.docker.com/engine/userguide/\r\n\r\n```\r\n\r\n\r\n----------\r\n\r\ndocker 的安装还是挺容易的，做一下简单的记录就行\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/1508572492023.jpg', 'MooseLakeGrass.jpg', '2017-10-22 01:42:00', '2019-04-03 16:29:03', 'p', '一段关系无解，不是任何人的错，那么我们就把悲伤藏在心底。微笑着，说再见。', 157, 0, 0, 'pinsily', 2);
INSERT INTO `article` VALUES (14, 'docker 笔记(2) -- 镜像', '----------\r\n![][1]\r\n<center>无论如何，飞蛾扑火都是一种高贵的姿态。</center>\r\n\r\n----------\r\n###  参考\r\n[菜鸟教程 -- docker][2]\r\n\r\n\r\n----------\r\n\r\n\r\n### 额\r\n\r\n当使用的镜像文件本地不存在时，则从远程镜像库中下载，默认是 docker Hub，也可以找到其他的镜像库使用\r\n\r\n----\r\n### 列出所有的本地镜像\r\n```shell\r\nroot@pinsily:~# docker images\r\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\r\nhello-world         latest              05a3bd381fc2        5 weeks ago         1.84kB\r\n```\r\n\r\n表头名分别表示 镜像源、标签、ID、生成时间以及大小，其中我们经常以 REPOSITORY:TAG 来表示镜像，比如 Ubuntu:14.04,如果使用的时候不加标签的话，默认下载最新版本的，也即 latest 标签\r\n\r\n\r\n----------\r\n\r\n\r\n### 预先下载镜像\r\n可以不在使用的时候就把镜像下载好\r\n```\r\nroot@pinsily:~# docker pull ubuntu:14.04\r\n\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n### 搜索远程镜像库\r\n```shell\r\nroot@pinsily:~# docker search ubuntu\r\n\r\nNAME                                            DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\r\nubuntu                                          Ubuntu is a Debian-based Linux operating s...   6699                [OK]\r\nubuntu-upstart                                  Upstart is an event-based replacement for ...   80                  [OK]\r\nubuntu-debootstrap                              debootstrap --variant=minbase --components...   31                  [OK]\r\nsaltstack/ubuntu-14.04-minimal                                                                  7                                       [OK]\r\nbrook/ubuntu-14.04.3-baidupcs                   https://github.com/GangZhuo/BaiduPCS 此项目功能...   6                                       [OK]\r\nsaltstack/ubuntu-14.04                                                                          5                                       [OK]\r\ntmartinx/ubuntu-14.04-server-cloudimg           Ubuntu 14.04 LTS (Trusty Tahr)  Cloud image     2\r\nfernandoacorreia/ubuntu-14.04-oracle-java-1.7   Docker image with Ubuntu 14.04 and Oracle ...   1                                       [OK]\r\nmist/ubuntu-14.04                               Ubuntu 14.04 image with openssh server and...   1\r\nsimphonyproject/ubuntu-14.04-remote             LEGACY. Ubuntu 14.04 with Remote Access Su...   1                                       [OK]\r\n```\r\n\r\n|     |     |\r\n| --- | --- |\r\n|   NAME  |   镜像仓库源的名称  |\r\n|   DESCRIPTION  |   镜像的描述  |\r\n|OFFICIAL|是否docker官方发布|\r\n\r\n\r\n----------\r\n\r\n### 运行镜像\r\n```\r\nroot@pinsily:~# docker run hello-world\r\n```\r\n\r\n\r\n----------\r\n### 更新镜像\r\n可以将我们修改后的镜像以副本形式上传\r\n更新之前，需要创建一个容器来进行交互，关于容器的记录一起放到下一节讲\r\n```\r\nroot@pinsily:~# docker run -t -i ubuntu:14.04 /bin/bash\r\nroot@f34700df208e:/#\r\n```\r\n创建了一个交互式进程，进入了容器当中（@后面的表示容器 ID），在其中进行软件库更新\r\n```\r\nroot@f34700df208e:/# apt-get update\r\n```\r\n\r\n使用 `exit` 命令退出容器，记下容器 ID\r\n\r\n提交副本\r\n\r\n```\r\nroot@pinsily:~# docker commit -m=\"updated\" -a=\"pinsily\" f34700df208e pinsily/ubuntu:14.04_v2\r\nsha256:be2e8bc7629efb487cacaf541fddd8dccaec29be05739fa33743cfb3385f3551\r\n```\r\n\r\n|     |     |\r\n| --- | --- |\r\n|  -m |   提交的描述信息  |\r\n| -a |   镜像作者  |\r\n|f34700df208e |   容器ID |\r\n|   pinsily/ubuntu:14.04_v2  |  目标镜像名   |\r\n\r\n可以查看到我们新提交的镜像，可以以此来创建容器使用\r\n\r\n![][3]\r\n\r\n\r\n----------\r\n\r\n### 添加镜像标签\r\n对上面更新的镜像添加一个 hello 标签\r\n```\r\nroot@pinsily:~# docker tag be2e8bc7629e pinsily/ubuntu:hello\r\n```\r\n![][4]\r\n\r\n\r\n----------\r\n\r\n\r\n\r\n \r\n\r\n\r\n  [1]: http://cdn.pinsily.site/268198-106.jpg\r\n  [2]: http://www.runoob.com/docker/docker-tutorial.html\r\n  [3]: http://cdn.pinsily.site/1508577954564.jpg\r\n  [4]: http://cdn.pinsily.site/1508578299875.jpg', 'ClaretCup.jpg', '2017-10-23 01:44:00', '2019-04-09 09:43:07', 'p', '当使用的镜像文件本地不存在时，则从远程镜像库中下载', 138, 0, 0, 'pinsily', 2);
INSERT INTO `article` VALUES (15, 'docker 笔记(3) -- 容器', '----------\r\n\r\n![][1]\r\n<center>面壁者，我是你的破壁人</center>\r\n\r\n----------\r\n###  参考\r\n[菜鸟教程 -- docker][2]\r\n\r\n----------\r\n\r\n### 额\r\n容器可以看成是虚拟机软件，是用来运行镜像的\r\n\r\n\r\n----------\r\n\r\n### Docker 客户端\r\ndocker 客户端既是在 bash 下使用 docker 相关的命令，比如之前所记录的 `docker images` 等命令，直接键入 docker 能够看到所有命令，可以通过命令 `docker command --help` 更深入的了解\r\n\r\n![][3]\r\n\r\n![][4]\r\n\r\n\r\n----------\r\n\r\n### 查看正在运行的容器\r\n```\r\nroot@pinsily:~# docker ps\r\n```\r\n\r\n\r\n----------\r\n### 查看网络端口\r\n容器和主机之间会有一个端口映射实现网络连接\r\n```\r\nroot@pinsily:~# docker port ID\r\n```\r\n也可以使用 `docker ps`得到端口映射\r\n\r\n\r\n----------\r\n\r\n### 创建容器\r\n#### 直接镜像的程序\r\n```\r\nroot@pinsily:~# docker run ubuntu:14.04 /bin/echo \"Hello world\"\r\nHello world\r\n```\r\n\r\n#### 交互式容器\r\n`-i`表示可以进行交互，`-t`表示建立虚拟终端，可以并在一起使用`-it`,使用 `exit` 退出\r\n```\r\nroot@pinsily:~# docker run  -i -t ubuntu:14.04 /bin/bash\r\nroot@6c15420e7512:/#\r\n```\r\n\r\n#### 使用后台模式\r\n使用 `-d`实现，打印出容器 ID（前12位可以直接使用），但是容器一直在后台运行着，可以使用`docker ps`确认\r\n```\r\nroot@pinsily:~# docker run -d ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\r\nb8d8bbb1d21af5d7d184ead1cefd618ca867847deb1c2f6470006cf3ec9c7535\r\n```\r\n\r\n使用 `docker logs name/id` 查看上面的运行结果\r\n\r\n![][5]\r\n\r\n#### 终止容器\r\n使用 `docker stop name/id` \r\n```\r\nroot@pinsily:~# docker stop b8d8bbb1d21a\r\nb8d8bbb1d21a\r\n\r\n```\r\n\r\n----------\r\n\r\n### 总结\r\n容器的基本使用就记录这些常用的了，留当一个学习的记录，之后如果有具体应用的话在再接再厉，可能会用到 python，Nginx 这些网络和编程软件安装的可能\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/1508641911197.jpg\r\n  [2]: http://www.runoob.com/docker/docker-tutorial.html\r\n  [3]: http://cdn.pinsily.site/1508641911578.jpg\r\n  [4]: http://cdn.pinsily.site/1508641911578.jpg\r\n  [5]: http://cdn.pinsily.site/1508641242350.jpg', 'MooseLakeGrass_NsliWkX.jpg', '2017-10-24 01:48:00', '2019-03-29 14:16:39', 'p', '容器可以看成是虚拟机软件，是用来运行镜像的', 126, 0, 0, 'pinsily', 2);
INSERT INTO `article` VALUES (16, 'linux -- 日志重定向到文本', '---\r\n\r\n![][1]\r\n\r\n<p><center>对于你，我又何止一句喜欢～ ——竹马钢琴师</center></p>\r\n\r\n------\r\n### 说明\r\n在使用Hadoop的使用，输出的日志太多，于是想将其重定向到日志文件中，但是因为忽略了一个细节问题，一直还是在shell中输出日志，找了许久才找到了解决的方法\r\n\r\n----------\r\n### 解决\r\n\r\n``` shell\r\nhadoop jar *.jar $mrClass > mr.log 2>&1\r\n```\r\n\r\n这里的 `2>&1` 很关键，没有的话就无法在mr.log中看到hadoop jar执行过程的内容输出了\r\n\r\n1代表标准输出,2代表标准错误\r\n\r\n那么命令后面跟 2>&1意思就是把命令执行的标准错误和标准输出都重定向到mr.log里面去.\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/SatelliteGlades.jpg', 'happychildday.jpg', '2017-05-30 09:53:00', '2019-03-29 15:10:20', 'p', '忽略了一个细节问题', 116, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (17, 'linux -- tar.bz2 文件解压', '---\r\n\r\n![][1]\r\n\r\n<p><center>苦难算什么，我本来，就喜欢走上阿修罗之路。 ——海贼王</center></p>\r\n\r\n------\r\n### 解压命令\r\n\r\n假设文件名为 test.tar.bz2\r\n\r\n```bash\r\n$ bzip2 -d test.tar.bz2\r\n$ tar -xvf test.tar\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-23733.jpg', 'Mariachis.jpg', '2018-03-29 19:56:00', '2019-04-06 16:15:27', 'p', '常见的解压缩命令', 119, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (19, 'linux -- 后台管理程序 supervisor', '----------\r\n![][1]\r\n\r\n<center><p>记忆就像是握在手中的水，不管你握紧还是摊开都会慢慢的消失</p></center>\r\n\r\n---------\r\n### 前言\r\n搭建 ss 的时候发现把 putty 关闭之后就关掉了进程，发现是没有在后台运行，就找了相关的进程管理，发现 supervisor 还不错，就使用了\r\n\r\n查了挺多资料，整合成一份可以使用的\r\n\r\nsupervisor 是用 Python 开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台 daemon，并监控进程状态，异常退出时能自动重启\r\n\r\n\r\n----------\r\n### 安装\r\n```\r\n$ apt-get install supervisor\r\n```\r\nsupervisor 安装完成后会生成三个执行程序：`supervisortd`、`supervisorctl`、`echo_supervisord_conf`，分别是 supervisor 的守护进程服务（用于接收进程管理命令）、客户端（用于和守护进程通信，发送管理进程的指令）、生成初始配置文件程序\r\n\r\n----------\r\n### 生成初始配置文件\r\n初始的配置文件可能是已经有的，不需要再创建\r\n```\r\n$ mkdir /etc/supervisor\r\n$ echo_supervisord_conf > /etc/supervisor/supervisord.conf\r\n```\r\n\r\n\r\n----------\r\n### 添加进程管理\r\n这里以 ss 为例\r\n```\r\n$ vim /etc/supervisor/supervisord.conf\r\n```\r\n\r\n```\r\n[program:shadowsocks]\r\ncommand=/etc/init.d/shadowsocks restart\r\nautostart=true\r\nautorestart=true\r\nuser=root\r\nlog_stderr=true\r\nlogfile=/var/log/shadowsocks.log\r\n```\r\n\r\n\r\n----------\r\n### 启动\r\n```\r\nsupervisord -c /etc/supervisor/supervisord.conf\r\n```\r\n\r\n\r\n----------\r\n### 管理\r\n```\r\nsupervisorctl stop shadowsocks\r\nsupervisorctl start shadowsocks\r\nsupervisorctl restart shadowsocks\r\n```\r\n\r\n\r\n----------\r\n### 错误解决\r\n```\r\n$ sudo unlink /tmp/supervisor.sock\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%A7%86%E8%A7%89%20-%2016.jpg', 'Kiasma.jpg', '2018-01-31 05:04:00', '2019-03-29 11:20:44', 'p', '搭建 ss 的时候发现把 putty 关闭之后就关掉了进程，发现是没有在后台运行，就找了相关的进程管理', 143, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (20, 'linux -- 常用命令含义', '----------\r\n\r\n![][1]\r\n\r\n<center><p>在那过去未来，时光两端，青史之外，记忆之前，我可曾，见过你</p></center>\r\n\r\n---------\r\n### 前言\r\n主要记录日常会使用到的命令，偏门的遇上再添加\r\n\r\n----------\r\n### 命令\r\n\r\n| 命令    |  原文   |\r\n| --- | --- |\r\n|   ls  | list    |\r\n|   cd   | change directory    |\r\n|   su  | switch user    |\r\n|   pwd  |  print work directory   |\r\n|   ps  |  process status   |\r\n|   df  |  disk free   |\r\n|   rmdir  |  remove directory   |\r\n|   rm  |  remove   |\r\n|   cat  | concatenate    |\r\n|   ln -s  |  link -soft   |\r\n|   mkdir  | make directory    |\r\n|   man  |  manual   |\r\n|   pwd | print working directory    |\r\n|   mv  |  move   |\r\n|   cp  |  copy   |\r\n|   chown  | change owner    |\r\n|   chmod  | change mode    |\r\n|   bin  | binaries    |\r\n|   etc  | etcetera    |\r\n|   lib  |  library   |\r\n|   proc  | processes    |\r\n|   sbin  | superuser binaries    |\r\n|   tmp  |  temporary   |\r\n|   usr  |  unix shared resources   |\r\n|   var  | variable    |\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/343210-106.jpg', 'DUAN.jpg', '2018-01-20 10:05:00', '2019-04-08 16:05:25', 'p', '主要记录日常会使用到的命令，偏门的遇上再添加', 116, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (21, 'linux -- 环境变量 path', '----------\r\n\r\n![][1]\r\n\r\n<center><p>A structure this pretty just had to exist</p></center>\r\n\r\n----------\r\n### 环境变量的查看\r\n\r\n```\r\nroot@pinsily:~# echo $PATH\r\n```\r\n\r\n```\r\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\r\n```\r\n\r\n更详细的信息\r\n```\r\nroot@pinsily:~# export\r\n```\r\n\r\n\r\n----------\r\n### 环境变量的添加\r\n#### 临时添加\r\n```Shell\r\nroot@pinsily:~# PATH=\"$PATH\":/NEW_PATH\r\n```\r\n关闭终端后会失效\r\n\r\n#### 永久添加\r\n- 对所有用户生效\r\n```\r\nroot@pinsily:~# sudo vim /etc/profile\r\n```\r\n在末尾添加上以下语句\r\n```\r\nexport PATH=\"/NEW_PATH:$PATH\"\r\n```\r\n执行立即生效语句\r\n```\r\npinsily@zhu:~$ source /etc/profile\r\n```\r\n- 对当前用户生效\r\n```\r\nroot@pinsily:~# vim ~/.bashrc\r\n```\r\n\r\n```\r\nexport PATH=\"/NEW_PATH:$PATH\"\r\n```\r\n\r\n\r\n```\r\n# 生效\r\nsource ~/.bashrc\r\n```\r\n\r\n----------\r\n#### **环境变量的删除**\r\n使用 命令 `unset PATH` 清空 PATH 变量\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/343096-106.jpg', 'MaryLouWilliams.jpg', '2018-01-20 10:06:00', '2019-04-06 15:27:21', 'p', '记录关于环境变量的修改', 120, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (22, 'linux -- swap file “*.swp”already exists！', '---------\r\n\r\n\r\n![][1]\r\n\r\n<center><p>慕言，思慕的慕，无言以对的言，我的名字</p></center>\r\n\r\n----------\r\n### 问题\r\n在使用 vim 的时候，出现了以下问题\r\n\r\n![][2]\r\n\r\n\r\n使用vim编辑文件实际是先 copy 一份临时文件并映射到内存给你编辑， 编辑的是临时文件， 当执行：w 后才保存临时文件到原文件，执行：q 后才删除临时文件。\r\n\r\n每次启动检索是否有临时文件， 有则询问如何处理，就会出现如上情景\r\n\r\n----------\r\n### 解决\r\n在文件目录下使用 `ls -a` 会看到交换文件，将它删除即可\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341191-106.jpg\r\n  [2]: http://cdn.pinsily.site/1512980175813.jpg', 'ClaretCup_dN5fppk.jpg', '2017-12-11 10:08:00', '2019-04-07 23:25:37', 'p', '使用vim编辑文件实际是先 copy 一份临时文件并映射到内存给你编辑， 编辑的是临时文件', 109, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (23, 'linux -- ls 命令', '----------\r\n\r\n![][1]\r\n\r\n<center><p>从此故乡只有冬夏，再无春秋</p></center>\r\n\r\n---------\r\n### emmmm\r\n> ls 是 list 的缩写，在 linux 中用于列出文件和目录,在这里只是记录常用的\r\n\r\n----------\r\n### 用法\r\n- 直接使用\r\n> 列出目录下的所有文件或文件夹\r\n```\r\nroot@pinsily:~# ls\r\npinsily_1  pinsily_2  pinsily_3  test.html\r\n```\r\n\r\n- 获得详细信息\r\n> 使用参数 `-l`\r\n```shell\r\nroot@pinsily:~# ls -l\r\ntotal 16\r\ndrwxr-xr-x 2 root root 4096 Dec 15 15:55 pinsily_1\r\ndrwxr-xr-x 2 root root 4096 Dec 15 15:55 pinsily_2\r\ndrwxrwxrwx 2 root root 4096 Dec 15 15:55 pinsily_3\r\n-rw-r--r-- 1 root root   14 Dec 11 16:12 test.html\r\n```\r\n\r\n|   列数  |   解释  |\r\n| --- | --- |\r\n|   1  |  第一个字母：`d`表示目录，`-`表示文件，`l`表示链接    |\r\n|   1   |   第2-10个字母：三位一组，分别表示文件所有者、所有组、其他用户的权限  |\r\n|   2  |   数字表示有多少个链接指向这个文件  |\r\n|   3  |    文件的所有者 |\r\n|   4  |   文件的所有组  |\r\n|  5   |  文件大小，字节数   |\r\n|   6  |    文件最后的修改时间 |\r\n|   7  |  文件名或者目录名   |\r\n\r\n- 人性化展示信息\r\n> 使用参数`-h`，比如可以把上面的字节数改为我们熟悉的单位\r\n```\r\nroot@pinsily:~# ls -lh\r\ntotal 16K\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 15:55 pinsily_1\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 15:55 pinsily_2\r\ndrwxrwxrwx 2 root root 4.0K Dec 15 15:55 pinsily_3\r\n-rw-r--r-- 1 root root   14 Dec 11 16:12 test.html\r\n```\r\n\r\n- 隐藏文件\r\n> 在 linux 中，以`.`开头的文件都是隐藏文件，可以使用参数`-a`打印\r\n```\r\nroot@pinsily:~# ls -al\r\ntotal 60\r\ndrwx------  8 root root 4096 Dec 15 16:08 .\r\ndrwxr-xr-x 23 root root 4096 Dec  7 11:12 ..\r\n-rw-------  1 root root 1157 Dec 11 16:43 .bash_history\r\n-rw-r--r--  1 root root 3106 Feb 20  2014 .bashrc\r\ndrwx------  3 root root 4096 Aug 24 20:53 .cache\r\n-rw-------  1 root root    0 Dec  7 11:32 .mysql_history\r\n-rw-r--r--  1 root root    0 Dec 15 16:08 .pinsily\r\ndrwxr-xr-x  2 root root 4096 Dec 15 15:55 pinsily_1\r\ndrwxr-xr-x  2 root root 4096 Dec 15 15:55 pinsily_2\r\ndrwxrwxrwx  2 root root 4096 Dec 15 15:55 pinsily_3\r\ndrwxr-xr-x  2 root root 4096 Aug 24 20:53 .pip\r\n-rw-r--r--  1 root root  140 Feb 20  2014 .profile\r\n-rw-r--r--  1 root root   64 Aug 24 20:53 .pydistutils.cfg\r\ndrwx------  2 root root 4096 Dec  7 10:59 .ssh\r\n-rw-r--r--  1 root root   14 Dec 11 16:12 test.html\r\n-rw-------  1 root root 4215 Dec 11 16:43 .viminfo\r\n```\r\n\r\n- 按文件大小排序\r\n> 使用参数`-S`,按文件大小从大到小排序\r\n```\r\nroot@pinsily:~# ls -lhS\r\ntotal 64K\r\n-rw-r--r-- 1 root root  51K Dec 15 16:18 test.html\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 16:17 pinsily_1\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 15:55 pinsily_2\r\ndrwxrwxrwx 2 root root 4.0K Dec 15 15:55 pinsily_3\r\n\r\n```\r\n\r\n- 输出反转\r\n> 使用参数 `-r`,比如可以将排序从小到大输出\r\n```\r\nroot@pinsily:~# ls -lhSr\r\ntotal 64K\r\ndrwxrwxrwx 2 root root 4.0K Dec 15 15:55 pinsily_3\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 15:55 pinsily_2\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 16:17 pinsily_1\r\n-rw-r--r-- 1 root root  51K Dec 15 16:18 test.html\r\n```\r\n\r\n- 只列出目录条目\r\n> 使用参数 `-d`,不过后面得加上参考(通配符)，这个可以自己定\r\n```\r\nroot@pinsily:~# ls -d */\r\npinsily_1/  pinsily_2/  pinsily_3/\r\n```\r\n-- ls 版本\r\n> 使用参数 `--version`\r\n```\r\nroot@pinsily:~# ls --version\r\nls (GNU coreutils) 8.21\r\nCopyright (C) 2013 Free Software Foundation, Inc.\r\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\r\nThis is free software: you are free to change and redistribute it.\r\nThere is NO WARRANTY, to the extent permitted by law.\r\n\r\nWritten by Richard M. Stallman and David MacKenzie.\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/248913-106.jpg', 'MooseLakeGrass_YDGOj6B.jpg', '2017-12-15 10:11:00', '2019-04-05 16:50:33', 'p', 'ls 是 list 的缩写，在 linux 中用于列出文件和目录,在这里只是记录常用的', 103, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (24, 'linux -- 修改主机名', '----------\r\n\r\n![][1]\r\n\r\n<center><p>你永远是我唯爱旅行中名为秘密的起点站</p></center>\r\n\r\n----------\r\n### 序\r\n每次新装的 linux 系统，计算机名都很长，网上找了修改的方法\r\n\r\n![][2]\r\n\r\n----------\r\n### 方法\r\n\r\n\r\n1. 修改 hostname 文件\r\n```\r\nvim /etc/hostname\r\n```\r\n将内容删掉改成自己的计算机名\r\n\r\n2. 修改 hosts 文件\r\n\r\n```\r\nvim /etc/hosts\r\n```\r\n在 localhost 下添加一行数据，本地ip+用户名\r\n```\r\n127.0.0.1       localhost\r\n127.0.0.1       pinsily\r\n```\r\n\r\n修改好后重启系统即可，还没有找到不重启就生效文件的方法，暂时就这样先了\r\n\r\n![][3]\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341373-106.jpg\r\n  [2]: http://cdn.pinsily.site/1512615869316.jpg\r\n  [3]: http://cdn.pinsily.site/1512616512864.jpg', '10-87376.jpg', '2017-12-07 10:14:00', '2019-03-29 17:52:54', 'p', '每次新装的 linux 系统，计算机名都很长，网上找了修改的方法', 112, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (25, 'nginx -- 403 forbidden 权限问题', '----------\r\n\r\n![][1]\r\n\r\n<center><p>奚者为奴，怜我奚儿，囚于闺阁囹圄，终不得见世间川峦，人生百态</p></center>\r\n\r\n---------\r\n### 前言\r\n> 403 Forbidden 不仅仅只是权限问题导致的，还有其他问题，这里仅仅解决权限问题\r\n\r\n----------\r\n### 用户问题\r\n可以直接修改所属用户为 `root`，nginx 默认是 `www-data` 用户，如果需要保险的话，可以新建 `www-data` 用户，然后将文件所属用户改为这个即可，这里直接使用 `root` 用户\r\n```\r\nvim /etc/nginx/nginx.conf\r\n```\r\n```\r\n# 在文件最顶端修改\r\nuser root\r\n```\r\n\r\n\r\n----------\r\n### 文件访问权限\r\n也可以直接将目录的权限通过 `chmod +755 dirname` 修改成可访问的\r\n\r\n但是必须注意的是，文件目录不可以放在父目录为 `/root/` 的目录下，不然修改了是无效的\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E5%8A%A8%E6%BC%AB%20-%203.jpg', 'NamibFace.jpg', '2018-02-18 10:15:00', '2019-04-03 21:32:00', 'p', '403 Forbidden 不仅仅只是权限问题导致的，还有其他问题，这里仅仅解决权限问题', 124, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (26, 'nginx - nginx:[error] open() \"/run/nginx.pid\" failed', '----------\r\n![][1]\r\n\r\n<center>是我能够对你做的最自私的事</center>\r\n\r\n----------\r\n### 问题\r\n在重启 Nginx 之后重新加载配置文件 `nginx -s reload`,报了下面的错误\r\n```\r\nroot@pinsily:~# nginx -s reload\r\nnginx: [error] open() \"/run/nginx.pid\" failed (2: No such file or directory)\r\n```\r\n\r\n----------\r\n### 解决\r\n使用 Nginx `-c` 的参数指定 nginx.conf 文件的位置\r\n```\r\nroot@pinsily:~# nginx -c /etc/nginx/nginx.conf\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/102493-106.jpg', 'LongtailedWidowbird.jpg', '2017-11-13 10:16:00', '2019-03-31 16:14:02', 'p', '在重启 Nginx 之后重新加载配置文件 `nginx -s reload`,报了下面的错误', 152, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (27, '小知识 -- 彼得潘症候群', '----------\r\n![][1]\r\n\r\n<center><p>如果你以为那么简单就可以把我甩掉，就大错特错了</p></center>\r\n\r\n----------\r\n> 维基百科：[彼得潘症候群][2]\r\n\r\n\r\n彼得潘症候群（Peter Pan syndrome）是个流行的心理学名词，用来叙述一个在社会未成熟的成人。这个词汇通常用于一般人，但也用于一些心理学的专业人士在普及心理学上的描述。这个词汇是来自丹·凯利（Dan Kiley）于1983年出版的书《彼得潘症候群：不曾长大的男人》（The Peter Pan Syndrome: Men Who Have Never Grown Up）。丹·凯利也写了一本伙伴书《温蒂穷境》（The Wendy Dilemma），于1984年出版。精神疾病诊断与统计手册并没有列入“彼得潘症候群”这个疾病，而美国心理学会（American Psychiatric Association）并没有承认这是一种心理疾病。应要归类可分入依赖性人格疾患。深受此症困扰的人多半会有逃避大多数形式上的责任，从事一些不成熟的举动，且仍会眷恋其青少年时期的时光，会设法不断留住青春。\r\n\r\n该症候群虽非精神医学正式的诊断，却普遍存在于因家庭、婚姻、社交问题寻求咨商辅导的个案中，患者也往往不自觉。近来，更有学者以新的英文单字“Kidult”，即kid（小孩）与adult（成人）的合体，称呼这些具儿童心态的成年人。\r\n\r\n专家指出，当事者常见的特征约略如下：\r\n\r\n\r\n1. 不负责任：表现任性、散漫，过于自我中心，出了差错老爱怪罪别人。\r\n\r\n\r\n2. 缺乏自信：恐惧失败，不敢勇于任事，面对挑战会找借口逃避。\r\n\r\n\r\n3. 依赖心强：害怕孤单、寂寞，希望随时有人可以帮忙，满足任何需求。\r\n\r\n\r\n4. 难于坚持：挫折忍受度低，行事稍有不顺或遭批评便易情绪化或放弃。\r\n\r\n\r\n5. 关系障碍：与异性交往到需给予承诺时，便会临阵脱逃，故不时更换伴侣，且对象越来越年轻，藉以缓解被要求结婚组织家庭的压力。\r\n\r\n6. 其他：穿着打扮如青少年，与本身年纪有所出入；好奇心强，爱尝试新奇事物，喜欢热闹气氛等。\r\n\r\n患有该症候群者，或许习惯随心所欲，在职场或人际互动上易受挫，总觉得遭到团体排斥，凡事格格不入，故换工作如家常便饭。即使成家立业，事不关己的特质也常让配偶负担沉重，仿佛在照顾另一个孩子般，造成彼此关系恶化\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341134-105.jpg\r\n  [2]: https://zh.wikipedia.org/wiki/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%97%87%E5%80%99%E7%BE%A4', 'HollowRock.jpg', '2018-06-20 10:18:00', '2019-03-28 05:56:14', 'p', '彼得潘症候群（Peter Pan syndrome）是个流行的心理学名词，用来叙述一个在社会未成熟的成人。', 175, 0, 0, 'pinsily', 4);
INSERT INTO `article` VALUES (28, 'css -- 颜色代码对照表', '----------\r\n\r\n![][1]\r\n\r\n\r\n<center><p>世间事，除了生死，哪一件事不是闲事</p></center>\r\n\r\n----------\r\n### 对照表\r\n<table border=\"0\">\r\n<tbody>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffffff\">FFFFFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#dddddd\">#DDDDDD</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#aaaaaa\">#AAAAAA</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#888888\">#888888</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#666666\">#666666</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#444444\">#444444</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#000000\">#000000</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffb7dd\">#FFB7DD</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff88c2\">#FF88C2</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff44aa\">#FF44AA&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff0088\">#FF0088&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#c10066\">#C10066&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#a20055\">#A20055&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#8c0044\">#8C0044&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffcccc\">#FFCCCC</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff8888\">#FF8888</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff3333\">#FF3333&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff0000\">#FF0000&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#cc0000\">#CC0000&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#aa0000\">#AA0000&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#880000\">#880000&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffc8b4\">#FFC8B4</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffa488\">#FFA488</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff7744\">#FF7744&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff5511\">#FF5511&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#e63f00\">#E63F00&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#c63300\">#C63300&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#a42d00\">#A42D00&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffddaa\">#FFDDAA</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffbb66\">#FFBB66</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffaa33\">#FFAA33</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff8800\">#FF8800&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ee7700\">#EE7700&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#cc6600\">#CC6600&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#bb5500\">#BB5500&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffee99\">#FFEE99</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffdd55\">#FFDD55</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffcc22\">#FFCC22</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffbb00\">#FFBB00&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ddaa00\">#DDAA00&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#aa7700\">#AA7700&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#886600\">#886600&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffffbb\">#FFFFBB</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffff77\">#FFFF77</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffff33\">#FFFF33</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffff00\">#FFFF00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#eeee00\">#EEEE00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#bbbb00\">#BBBB00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#888800\">#888800</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#eeffbb\">#EEFFBB</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ddff77\">#DDFF77</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ccff33\">#CCFF33</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#bbff00\">#BBFF00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#99dd00\">#99DD00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#88aa00\">#88AA00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#668800\">#668800</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ccff99\">#CCFF99</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#bbff66\">#BBFF66</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#99ff33\">#99FF33</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#77ff00\">#77FF00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#66dd00\">#66DD00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#55aa00\">#55AA00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#227700\">#227700</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#99ff99\">#99FF99</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#66ff66\">#66FF66</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#33ff33\">#33FF33</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00ff00\">#00FF00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00dd00\">#00DD00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00aa00\">#00AA00</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#008800\">#008800</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#bbffee\">#BBFFEE</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#77ffcc\">#77FFCC</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#33ffaa\">#33FFAA</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00ff99\">#00FF99</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00dd77\">#00DD77</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00aa55\">#00AA55</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#008844\">#008844</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#aaffee\">#AAFFEE</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#77ffee\">#77FFEE</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#33ffdd\">#33FFDD</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00ffcc\">#00FFCC</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00ddaa\">#00DDAA</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00aa88\">#00AA88</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#008866\">#008866</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#99ffff\">#99FFFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#66ffff\">#66FFFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#33ffff\">#33FFFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00ffff\">#00FFFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00dddd\">#00DDDD</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00aaaa\">#00AAAA</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#008888\">#008888</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#cceeff\">#CCEEFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#77ddff\">#77DDFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#33ccff\">#33CCFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#00bbff\">#00BBFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#009fcc\">#009FCC</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#0088a8\">#0088A8</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#007799\">#007799</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ccddff\">#CCDDFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#99bbff\">#99BBFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#5599ff\">#5599FF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#0066ff\">#0066FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#0044bb\">#0044BB&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#003c9d\">#003C9D&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#003377\">#003377&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ccccff\">#CCCCFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#9999ff\">#9999FF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#5555ff\">#5555FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#0000ff\">#0000FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#0000cc\">#0000CC&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#0000aa\">#0000AA&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#000088\">#000088&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ccbbff\">#CCBBFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#9f88ff\">#9F88FF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#7744ff\">#7744FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#5500ff\">#5500FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#4400cc\">#4400CC&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#2200aa\">#2200AA&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#220088\">#220088&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#d1bbff\">#D1BBFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#b088ff\">#B088FF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#9955ff\">#9955FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#7700ff\">#7700FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#5500dd\">#5500DD&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#4400b3\">#4400B3&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#3a0088\">#3A0088&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#e8ccff\">#E8CCFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#d28eff\">#D28EFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#b94fff\">#B94FFF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#9900ff\">#9900FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#7700bb\">#7700BB&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#66009d\">#66009D&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#550088\">#550088&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#f0bbff\">#F0BBFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#e377ff\">#E38EFF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#d93eff\">#E93EFF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#cc00ff\">#CC00FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#a500cc\">#A500CC&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#7a0099\">#7A0099&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#660077\">#660077&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ffb3ff\">#FFB3FF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff77ff\">#FF77FF</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff3eff\">#FF3EFF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#ff00ff\">#FF0&nbsp;0FF&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#cc00cc\">#CC00CC&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#990099\">#990099&nbsp;</td>\r\n<td height=\"30\" width=\"95\" bgcolor=\"#770077\">#770077&nbsp;</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341396-106.jpg', 'HenningsvaerFootball.jpg', '2017-12-10 10:22:00', '2019-04-09 00:37:35', 'p', '世间事，除了生死，哪一件事不是闲事', 245, 0, 0, 'pinsily', 5);
INSERT INTO `article` VALUES (29, 'css -- Button 鼠标箭头变手势', '---\r\n\r\n![][1]\r\n\r\n<p><center>镜中的雪越发耀眼，活像燃烧的火焰。 ——雪国</center></p>\r\n\r\n------\r\n### 说明\r\n按钮默认是鼠标悬停的时候还是箭头，对交互不明显\r\n\r\n\r\n----------\r\n### 修改\r\n在button 样式中添加\r\n```css\r\nbutton {\r\n    /* ... */\r\n    cursor:pointer; \r\n    /* ... */\r\n}\r\n```\r\n\r\n--------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/HollowRock.jpg', 'TinyLadybird.jpg', '2018-05-18 10:24:00', '2019-03-30 00:44:42', 'p', '按钮默认是鼠标悬停的时候还是箭头，对交互不明显', 158, 0, 0, 'pinsily', 5);
INSERT INTO `article` VALUES (30, 'css -- img 等比例自动缩放', '---\r\n\r\n![][1]\r\n\r\n<p><center>人生如逆旅，我亦是行人。 ——临江仙</center></p>\r\n\r\n------\r\n### 说明\r\n使得 img 随着父元素的大小自动等比例缩放\r\n\r\n\r\n----------\r\n### 修改\r\n```css\r\nimg{  \r\n    /* ... */\r\n    width: auto;  \r\n    height: auto;  \r\n    max-width: 100%;  \r\n    max-height: 100%;   \r\n    /* ... */\r\n}  \r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/GreatGhost.jpg', 'PKUCHINA.jpg', '2018-05-18 10:25:00', '2019-03-29 15:10:22', 'p', '使得 img 随着父元素的大小自动等比例缩放', 115, 0, 0, 'pinsily', 5);
INSERT INTO `article` VALUES (31, 'python -- 去掉字符串的空白字符', '---\r\n![][1]\r\n\r\n<p><center>且行善举，莫问前途。 ——浮生物语3</center></p>\r\n\r\n\r\n----------\r\n### 参考\r\n> [https://blog.csdn.net/drbing/article/details/50891172][2]\r\n\r\n------\r\n### 方法\r\n1. 使用 string 自带方法\r\n\r\n``` python\r\nstr = \" pinsily is someome \"\r\n\r\n# 去掉两边的空白 \"pinsily is someome\"\r\nprint(str.strip()) \r\n\r\n# 去掉左边的空白 \"pinsily is someome \"\r\nprint(str.lstrip())  \r\n\r\n# 去掉右边的空白 \" pinsily is someome\"\r\nprint(str.rstrip())     \r\n```\r\n\r\n\r\n2. 使用 re 表达式\r\n\r\n``` python\r\nstr = \" pinsily is someome \"\r\n\r\nimport re\r\n\r\n# 去掉字符串中的所有空格, 返回新字符串\r\nre.sub(\'\\s\', \'\', str)\r\n```\r\n\r\nre.sub() 方法也可以用在删除其他字符上，比如：\r\n\r\n``` python\r\n删除所有空白字符及单双引号\r\nre.sub([\'\\\"\',\'\\\'\',\'\\s\'],\'\',str)  \r\n```\r\n\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-18818.jpg\r\n  [2]: https://blog.csdn.net/drbing/article/details/50891172', 'ConcreteDinosaurs.jpg', '2018-07-04 14:50:00', '2019-03-31 12:18:39', 'p', '且行善举，莫问前途。 ——浮生物语3', 148, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (32, 'python -- 判断 list 是否为父子集关系', '---\r\n\r\n![][1]\r\n\r\n<p><center>心有所愿，便是值得。 ——花火</center></p>\r\n\r\n------\r\n### 说明\r\n list1 和 list2 两个 list ，想要得到list1是不是包含 list2 （是不是其子集 )\r\n\r\n\r\n----------\r\n### 判断\r\n\r\n``` python\r\na = [1,2]  \r\nb = [1,2,3]  \r\nc = [0, 1]  \r\n  \r\nset(b) > set(a)  \r\nset(b) > set(c)   \r\n\r\n# True  \r\n# False  \r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/TopDam.jpg', 'SallyRideEarthKAM.jpg', '2018-07-03 14:42:00', '2019-04-03 18:07:51', 'p', 'list1 和 list2 两个 list ，想要得到list1是不是包含 list2 （是不是其子集 )', 118, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (33, 'python -- 均匀分割字符串', '---\r\n\r\n![][1]\r\n\r\n<p><center>明天的事，交给明天的我</center></p>\r\n\r\n------\r\n### 参考\r\n> [https://segmentfault.com/q/1010000002615925][2]\r\n\r\n\r\n----------\r\n### 说明\r\n遇到了需要使用 k-shingle 算法，想到了直接使用 Python 的字符串分割，比如字符串\"absdgjael\",转换成 2-kingle 为 {\"ab\", \"sd\", \"gj\", \"ae\", \"l\"},不满整得直接单独放置\r\n\r\n\r\n----------\r\n### 实现\r\n```python\r\ns = \'absdgjael\'\r\n    n = 2\r\n    print([s[i:i+n] for i in xrange(0, len(s), n)])\r\n    #[\"ab\", \"sd\", \"gj\", \"ae\", \"l\"]\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/Grainrain.jpg\r\n  [2]: https://segmentfault.com/q/1010000002615925', '10-55009_Z4mWkqm.jpg', '2018-07-02 14:43:00', '2019-04-01 06:09:42', 'p', '遇到了需要使用 k-shingle 算法，想到了直接使用 Python 的字符串分割，比如字符串\"absdg', 144, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (34, 'python -- 调用 shell 命令', '---\r\n\r\n![][1]\r\n\r\n<p><center>一个人想像自己不懂得的事很容易浪漫 ——沉默的大多数</center></p>\r\n\r\n------\r\n### 前言\r\n有时候写 python 脚本的时候，直接使用 shell 命令的话会事半功倍，不需要自己再另外写函数来实现\r\n\r\n参考：[https://www.jianshu.com/p/5d999a668e79][2]\r\n\r\n----------\r\n### os 模块\r\n#### system 方法\r\n> system方法会创建子进程运行外部程序，方法除了返回外部程序的运行结果，还有结束的状态码 1 或 0\r\n\r\n```shell\r\n>>> import os\r\n>>> os.system(\"echo 8\")\r\n8\r\n0\r\n```\r\n\r\n### popen 方法\r\n> popen方不仅仅返回结果，还返回一个类文件对象，通过调用该对象的read()或readlines()方法可以读取输出内容\r\n\r\n```\r\n>>> import os\r\n>>> output = os.popen(\"dir\").read()\r\n>>> output\r\n.....\r\n>>>\r\n>>> outputs = os.popen(\"dir\").readlines()\r\n>>> for line in outputs:\r\n...     print(line)\r\n```\r\n----------\r\n### commands 模块\r\n#### getoutput 方法\r\n> 这种方法同popend的区别在于popen返回的是一个类文件对象，而本方法将外部程序的输出结果当作字符串返回\r\n```python\r\n# 返回(status, output)\r\ncommands.getstatusoutput(command)      \r\n# 只返回输出结果\r\ncommands.getoutput(command)                  \r\n# 调用了getoutput，不建议使用此方法\r\ncommands.getstatus(file)\r\n```\r\n\r\n\r\n----------\r\n### subprocess 模块\r\n> subprocess 允许你去创建一个新的进程让其执行另外的程序，并与它进行通信，获取标准的输入、标准输出、标准错误以及返回码等\r\n```shell\r\n>>> import subprocess\r\n>>> subprocess.call(\"dir\", shell=True)\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/ResplendentQuetzal.jpg\r\n  [2]: https://www.jianshu.com/p/5d999a668e79', 'EtaAquarids.jpg', '2018-07-01 14:45:00', '2019-03-27 18:32:43', 'p', '有时候写 python 脚本的时候，直接使用 shell 命令的话会事半功倍，不需要自己再另外写函数来实现', 104, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (35, 'python -- 新建文件夹', '---\r\n\r\n![][1]\r\n\r\n<p><center>曾经我眼前不见一物，如今视野中万物多彩</center></p>\r\n\r\n------\r\n### 说明\r\nPython 新建文件夹主要在 os 模块中完成\r\n\r\n----------\r\n### 相关方法\r\n- os.path.exists(path) -- 判断一个目录是否存在\r\n- os.makedirs(path) -- 多层创建目录\r\n- os.mkdir(path) -- 创建目录\r\n\r\n`makedirs(path)` 方法如果父目录不存在的条件下会先创建父目录，而 `mkdir` 没有这个功能\r\n\r\n另外，关于 window 的路径记录，由于 window 的路径是由反斜杠分割的，使用的时候需要另外增加转义字符\r\n\r\n----------\r\n### 使用\r\n```python\r\n\r\npath = \"D:\\\\Wallpaper\\\\\"\r\n\r\nif not os.path.exists(path):\r\n    os.mkdir(path)\r\n\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/ElephantSibs.jpg', 'WhalePod.jpg', '2018-06-30 14:46:00', '2019-04-06 15:27:19', 'p', 'Python 新建文件夹主要在 os 模块中完成', 150, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (36, 'python -- 文档字符串', '---\r\n\r\n![][1]\r\n\r\n<p><center>改变的东西，一定有其意义</center></p>\r\n\r\n-------\r\n### 文档字符串定义\r\n> 在函数体的第一行，我们可以使用一对三个单引号（\'\'\'）或者一对三个双引号（\"\"\"）来定义文档字符串，文档字符串通常第一行以大写字母开头，以句号（.）结束，第二行是空行，第三行开始是详细描述\r\n\r\n> 文档字符串的作用在于能够很直观地表示出函数或者类的作用，而不用通过源代码来获知，节省使用者的精力时间\r\n\r\n\r\n----------\r\n### 与注释的区别\r\n> 虽然文档字符串使用的也是注释符，但是不同的是，注释在解释器中会直接被忽视掉，但是文档字符串可以被调用使用\r\n\r\n-------\r\n### 实例\r\n```python\r\n>>> def maxnum(x,y):\r\n...     \"\"\" get the max number between x and y.\r\n...\r\n...     x and y much be integer.\"\"\"\r\n...\r\n...     if x>y:\r\n...         return x\r\n...     else:\r\n...         return y\r\n...\r\n```\r\n\r\n#### 使用\r\n```\r\n>>> help(maxnum)\r\nHelp on function maxnum in module __main__:\r\n\r\nmaxnum(x, y)\r\n    get the max number between x and y.\r\n\r\n    x and y much be integer.\r\n\r\n>>> maxnum.__doc__\r\n\' get the max number between x and y.\\n\\n\\tx and y much be integer.\'\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-84895.jpg', 'AuroraPhotographer.jpg', '2018-03-12 14:49:00', '2019-04-01 07:00:32', 'p', '在函数体的第一行，我们可以使用一对三个单引号（\'\'\'）或者一对三个双引号（\"\"\"）来定义文档字符串', 156, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (37, 'python -- pycharm 新建文件自动填充信息', '---\r\n\r\n![][1]\r\n\r\n<p><center>别忘了，你从本质上是个喜欢笑的人</center></p>\r\n\r\n-------\r\n### 前言\r\n在 py 文件中填上必要的文件信息是非常必要的，能够直观地得到相关信息\r\n\r\n\r\n----------\r\n### 设置\r\n打开 settings --> Editor --> Color Scheme --> File and Code Templates\r\n\r\n在右边找到 python script 选项，编辑框里输入相关信息\r\n```python\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\n-------------------------------------------------\r\n   Filename：      ${NAME}\r\n   Author :        ${USER}\r\n   date：          ${DATE} ${TIME}\r\n   Description :\r\n-------------------------------------------------\r\n\"\"\"\r\n\r\nif __name__ == \'__main__\':\r\n    pass\r\n```\r\n\r\n其他相关变量模板：\r\n```\r\n${PROJECT_NAME} - 当前Project名称;\r\n\r\n ${NAME} - 在创建文件的对话框中指定的文件名;\r\n\r\n ${USER} - 当前用户名;\r\n\r\n ${DATE} - 当前系统日期;\r\n\r\n ${TIME} - 当前系统时间;\r\n\r\n ${YEAR} - 年;\r\n\r\n ${MONTH} - 月;\r\n\r\n ${DAY} - 日;\r\n\r\n ${HOUR} - 小时;\r\n\r\n ${MINUTE} - 分钟；\r\n\r\n ${PRODUCT_NAME} - 创建文件的IDE名称;\r\n\r\n ${MONTH_NAME_SHORT} - 英文月份缩写, 如: Jan, Feb, etc;\r\n\r\n ${MONTH_NAME_FULL} - 英文月份全称, 如: January, February, etc；\r\n\r\n```\r\n\r\n-------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E5%B0%8F%E4%B9%A6%E5%8C%A0/10-84820.jpg', 'BklynBrdge_Q6BlxaQ.jpg', '2018-03-10 14:50:00', '2019-04-09 07:53:45', 'p', '在 py 文件中填上必要的文件信息是非常必要的，能够直观地得到相关信息', 960, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (38, 'mysql -- 备份和还原', '---\r\n\r\n![][1]\r\n\r\n<p><center>最好的感觉，是有人懂你的欲言又止</center></p>\r\n\r\n\r\n----------\r\n### 说明\r\n数据库的备份和还原是经常需要用到的，其实是遇到大祸之后才学会的\r\n\r\n------\r\n### 备份\r\n1. 备份整个数据库\r\n```\r\nmysqldump -uusername -ppassword databasename > backupfile.sql\r\n```\r\n\r\n\r\n2. 备份某些表\r\n```\r\nmysqldump -uusername -ppassword databasename table1 table2 > backupfile.sql\r\n```\r\n\r\n----------\r\n### 还原\r\n```\r\nmysql -uusername -ppassword databasename < backupfile.sql\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/WhalePod.jpg', 'TreeHugger.jpg', '2018-07-07 03:14:00', '2019-04-04 02:39:57', 'p', '数据库的备份和还原是经常需要用到的，其实是遇到大祸之后才学会的', 138, 0, 0, 'pinsily', 7);
INSERT INTO `article` VALUES (39, 'virtualbox -- 解决ubuntu卡顿问题', '---\r\n\r\n![][1]\r\n\r\n<p><center>我发过誓，再也不装作没察觉，再也不逃避</center></p>\r\n\r\n\r\n------\r\n### 说明\r\n因为需要用到桌面版的 ubuntu，所以就使用 virtualbox 安装了 ubuntu 镜像，发现有些设置没有设置好出现了卡顿的现象\r\n\r\n----------\r\n### 加大分配的内存\r\n\r\n直接一冲动直接分了电脑的一半内存，这个还是得看情况\r\n\r\n![][2]\r\n\r\n\r\n  \r\n\r\n\r\n----------\r\n### 开启CPU的硬件虚拟化功能\r\n这个是网上看到的，不过我自己的是一安装就有了\r\n\r\n说是可以通过 bios 进行设置，这个因为没有亲身试过，就略过呗\r\n\r\n\r\n----------\r\n### 开启3D加速，分配足够显存\r\n这个跟内存差不多，都需要根据自己电脑性能来分配\r\n\r\n![][3]\r\n\r\n\r\n----------\r\n### 安装VirtualBox增强功能\r\n这个看资料说增强功能是virtualbox的一个强势所在，实现了鼠标可以自由切换虚拟机和主机以及公用文件夹之类的，挺厉害的，也解决了不少以前自己放弃虚拟机的理由和问题\r\n\r\n启动虚拟机。单击虚拟机菜单中的“设备”>“安装增强功能”，也可以按快捷键Host+D。Host键就是虚拟机窗口右下方显示的键，默认为Right Ctrl，即右边的Ctrl键。然后系统会加载增强功能所在的虚拟光盘。点击运行，按提示完成安装，重启虚拟机\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/HONKONG.jpg\r\n  [2]: http://cdn.pinsily.site/1530795300194.jpg\r\n  [3]: http://cdn.pinsily.site/1530795525839.jpg', 'bangkok.jpg', '2018-07-07 06:36:00', '2019-04-09 07:46:08', 'p', '因为需要用到桌面版的 ubuntu，所以就使用 virtualbox 安装了 ubuntu 镜像，发现有些设', 200, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (40, 'virtualbox -- 共享文件夹', '---\r\n\r\n![][1]\r\n\r\n<p><center>要么忙着生存要么赶着去死，人总要做点什么</center></p>\r\n\r\n------\r\n### 说明\r\n没有共享文件夹的虚拟机真的会绝望的\r\n\r\n----------\r\n### 安装增加功能\r\n1. 启动 Ubuntu 虚拟机\r\n2. 在 virtualbox 菜单中找到\"设备(D)\" -> \"安装增强功能(I)...\"，之后可能需要重启系统\r\n\r\n![][2]\r\n\r\n上述操作相当于在系统中挂载了一张光盘，会默认保存到 /media/ 文件夹中\r\n\r\n**2018.07.19** 改：一般情况下，上诉操作后已经安装好增强功能，可以执行后续的操作，如果失败的话再执行下面语句安装\r\n```\r\n$ cd /media/pinsily/VBoxGuestAdditions-5.2.8    # pinsily 为用户名\r\n$ sudo ./VboxLinuxAdditions.run\r\n```\r\n\r\n注: 资料显示，不同的版本会有不同的安装方法\r\n\r\n----------\r\n### 共享文件夹\r\n1. 在 virtualbox 菜单找到 设备 --> 共享文件夹\r\n2. 指定主机上的共享路径及命名\r\n\r\n![][3]\r\n\r\n注: 命名可随意但是不能和共享文件名重名\r\n\r\n3. 实现挂载共享\r\n```\r\n$ sudo mount -t vboxsf zhu /mnt/shared\r\n```\r\n\r\nzhu 为上一步的命名，/mnt/shared 为虚拟机上的共享目录\r\n\r\n以上就可以实现主机和虚拟机上的文件夹共享了，另外，网上找的资料在自己的虚拟机上都不能实现自动挂载还报错，所以还是每次开机需要的时候自己手动挂载了\r\n\r\n4. 卸载命令\r\n```\r\n$ sudo umount -f /mnt/shared\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/NamibFace.jpg\r\n  [2]: http://cdn.pinsily.site/1530798609570.jpg\r\n  [3]: http://cdn.pinsily.site/1530799158844.jpg', 'girl-boy.jpg', '2018-07-07 06:37:00', '2019-04-07 10:38:15', 'p', '没有共享文件夹的虚拟机真的会绝望的', 182, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (41, 'hadoop -- Unable to load native-hadoop library for your platform” warning', '---\r\n\r\n![][1]\r\n\r\n<p><center>绚烂如繁樱，瞬息绽放后凋落</center></p>\r\n\r\n\r\n------\r\n### 说明\r\n在执行 hadoop 中时候，日志中总是出现下面的 warning，虽没什么影响，但是看得不顺眼\r\n\r\n```\r\nUnable to load native-hadoop library for your platform\r\n```\r\n\r\n----------\r\n### 解决\r\n```\r\n$ $ vim /opt/hadoop/etc/hadoop/hadoop-env.sh\r\n\r\n# 加入以下环境变量\r\nexport HADOOP_OPTS=\"$HADOOP_OPTS -Djava.library.path=/usr/local/hadoop/lib/native\"\r\n\r\nexport HADOOP_COMMON_LIB_NATIVE_DIR=\"/usr/local/hadoop/lib/native/\"\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/happychildday.jpg', 'blizzard.jpg', '2018-07-07 06:38:00', '2019-03-31 22:18:39', 'p', '在执行 hadoop 中时候，日志中总是出现下面的 warning，虽没什么影响，但是看得不顺眼', 194, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (42, 'android -- SDK 国内镜像', '---\r\n\r\n![][1]\r\n\r\n<p><center>不管是怎样的回忆，都是我们活过的人生</center></p>\r\n\r\n\r\n----------\r\n### 说明\r\n通过 google 国外镜像下载 sdk 安装库，速度还是太慢了\r\n\r\n------\r\n### 解决\r\n1. 启动Android SDK  Manager\r\n\r\n2. 点击“Tools”>“Options...”\r\n\r\n3. settings窗体中“HTTP Proxy Server”输入mirrors.neusoft.edu.cn HTTP  Proxy Port输入80，勾选Other中“Force https..”开头选项\r\n\r\n4. 点击“Close”按钮\r\n\r\n5. 点击“packages”>“Reload”，选择要下载的SDK版本进行下载即可\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/HenningsvaerFootball.jpg', 'girl-rock.jpg', '2017-12-07 06:39:00', '2019-04-09 16:55:32', 'p', '通过 google 国外镜像下载 sdk 安装库，速度还是太慢了', 114, 0, 0, 'pinsily', 8);
INSERT INTO `article` VALUES (43, 'shell -- 比较两个文件是否相同', '---\r\n\r\n![][1]\r\n\r\n<p><center>只要有你，我便无所不能 -- 进击的巨人</center></p>\r\n\r\n\r\n\r\n------\r\n### 说明\r\n在写代码进行迭代的时候，想通过 shell 判断当前后输出的文件相同时则停止，就网上找了个脚本进行了修改\r\n\r\n脚本来源：[https://blog.csdn.net/u010783148/article/details/73691154][2]\r\n\r\n\r\n----------\r\n### 脚本\r\n```\r\n#!/bin/bash\r\n\r\n# ScriptName: file_diff.sh\r\n\r\necho \"usage: -$0 file1 file2\"\r\n\r\nfile1=$1\r\n\r\nfile2=$2\r\n\r\nif [ -f $file1 ] && [ -f $file2 ]\r\n\r\nthen\r\n\r\n    diff $file1 $file2 > /dev/null\r\n\r\n    if [ $? != 0 ]\r\n\r\n    then\r\n\r\n        echo \"Different!\"\r\n\r\n    else\r\n\r\n        echo \"Same!\"\r\n\r\n    fi\r\n\r\nelse\r\n\r\n    echo \"$file1 or $file2 does not exist, please check filename.\"\r\n\r\nfi\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/DandelionXray.jpg\r\n  [2]: https://blog.csdn.net/u010783148/article/details/73691154', 'HenningsvaerFootball_mgpO4zP.jpg', '2018-05-15 06:40:00', '2019-04-05 17:38:32', 'p', '在写代码进行迭代的时候，想通过 shell 判断当前后输出的文件相同时则停止，就网上找了个脚本进行了修改', 140, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (44, 'js -- jquery实现回到顶部', '---\r\n\r\n![][1]\r\n\r\n<p><center>失去故土的花朵，回不去，却也离不开</center></p>\r\n\r\n<div style=\"width:50%;margin:0 auto;\">\r\n\r\n   <img src=\"\" />\r\n\r\n</div>\r\n\r\n------\r\n### 说明\r\n继续完善着博客，开始接触 js 的功能，也得慢慢熟悉起这块\r\n\r\n----------\r\n### html\r\n```\r\n<button class=\"back-top btn\">\r\n    Top\r\n</button>\r\n```\r\n\r\n----------\r\n### css\r\n```css\r\n.back-top {\r\n\r\n    position: fixed;  /*应用到全景*/ \r\n    bottom: 0;      /*距离右边和底部为0*/\r\n    right: 0;\r\n    margin: 50px;\r\n    padding: 5px 25px;\r\n    border: 1px solid #bcbcbc;\r\n    \r\n}\r\n\r\n/*bootstrap 4 中的 button 基础样式*/\r\n.btn {\r\n    display: inline-block;\r\n    font-weight: 400;\r\n    text-align: center;\r\n    white-space: nowrap;\r\n    vertical-align: middle;\r\n    -webkit-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n    user-select: none;\r\n    border: 1px solid transparent;\r\n    padding: .375rem .75rem;\r\n    font-size: 1rem;\r\n    line-height: 1.5;\r\n    border-radius: .25rem;\r\n    transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;\r\n}\r\n```\r\n\r\n----------\r\n### js\r\n```js\r\n;$( function() {\r\n\r\n    \'use strict\';   // 严格模式\r\n\r\n    // 找到 btn\r\n    var backButton = $(\'.back-top\');\r\n\r\n    // 点击按钮时返回顶部\r\n    backButton.on(\'click\', function(){\r\n\r\n        $(\'html,body\').animate({scrollTop: 0}, 800);\r\n\r\n    });\r\n\r\n    // 当页面在顶部时隐藏按钮，反之显现\r\n    $(window).on(\'scroll\', function(){\r\n        if($(window).scrollTop() > $(window).height()){\r\n            backButton.fadeIn();\r\n        }else {\r\n            backButton.fadeOut();\r\n        }\r\n    });\r\n\r\n\r\n    // 刚刷新时触发滚动事件\r\n    // 防止刚开始出现按钮\r\n    $(window).trigger(\'scroll\');\r\n\r\n\r\n})\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/DUAN.jpg', 'cvety.jpg', '2018-07-07 06:42:00', '2019-04-06 09:55:53', 'p', '继续完善着博客，开始接触 js 的功能，也得慢慢熟悉起这块', 142, 0, 0, 'pinsily', 9);
INSERT INTO `article` VALUES (45, 'bootstrap 4 -- 导航', '---\r\n\r\n![][1]\r\n\r\n<p><center>故乡的云。上古的玉。随手的诗。十九岁的你</center></p>\r\n\r\n------\r\n### 实现效果\r\n\r\n![][2]\r\n\r\n1. 可以居中显示\r\n2. 小屏幕时可以收缩成按钮菜单\r\n3. 导航 不等于 导航栏？\r\n\r\n----------\r\n### html\r\n```html\r\n<div class=\"all-container\">\r\n        <!-- header -->\r\n\r\n        <header>\r\n\r\n        <div class=\"container-fluid\">\r\n          <div class=\"header-title\">\r\n            <h1 class=\"text-center\">TuClown</h1>\r\n            <p class=\"text-center\">~听说，小丑给了你一朵郁金香~</p>\r\n          </div>\r\n\r\n\r\n\r\n          <nav class=\"navbar navbar-expand-md navbar-light justify-content-center cl-effect-12\">\r\n           \r\n            <button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#collapsingNavbar2\" >\r\n                <span class=\"navbar-toggler-icon\" style=\"color: black;\"></span>\r\n            </button>\r\n            <div class=\"navbar-collapse collapse justify-content-between align-items-center w-100\" id=\"collapsingNavbar2\">\r\n                <ul class=\"navbar-nav mx-auto text-center\">\r\n                    <li class=\"nav-item\">\r\n                      <a class=\"nav-link\" href=\"#\">Home</a>\r\n                    </li>\r\n                    <li class=\"nav-item\">\r\n                      <a class=\"nav-link\" href=\"#\">Archive</a>\r\n                    </li>\r\n                    <li class=\"nav-item\">\r\n                      <a class=\"nav-link\" href=\"#\">Category</a>\r\n                    </li>\r\n                    \r\n                    <li class=\"nav-item\">\r\n                      <a class=\"nav-link\" href=\"#\">Nav</a>\r\n                    </li>\r\n                    <li class=\"nav-item\">\r\n                      <a class=\"nav-link\" href=\"#\">Admin</a>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </nav>\r\n        </div>\r\n    </header> \r\n```\r\n\r\n\r\n----------\r\n### css\r\n```css\r\n.all-container {\r\n    max-width: 1000px;\r\n    margin: 0 auto;\r\n\r\n    color:black;\r\n    font-size: 14px;\r\n}\r\n\r\nheader {\r\n    padding: 0 0 0 0;\r\n    margin: 0 auto;\r\n}\r\n\r\n\r\n.main-navigation {\r\n    text-align: center;\r\n    margin-bottom: 35px;\r\n}\r\n\r\nheader h1 {\r\n    font-size: 50px;\r\n    padding-top: 20px;\r\n    font-weight: 0;\r\n    font-family: \'Pacifico\', cursive;\r\n}\r\n\r\nheader p {\r\n    font-size: 10px;\r\n    color: black;\r\n    margin-bottom: 0;\r\n    padding-bottom:10px;\r\n\r\n}\r\n\r\nheader .header-img {\r\n    text-align: center;\r\n}\r\n\r\nheader .header-img img {\r\n    width: 100%;\r\n    height: 500px;\r\n}\r\n\r\n.container-fluid {\r\n    padding:0;\r\n}\r\n\r\nheader li {\r\n    /*padding: 5px 10px;*/\r\n    width: 100px;\r\n    text-align: center;\r\n}\r\n\r\nheader .navbar {\r\n    padding: 0;\r\n    margin: 30px 0;\r\n}\r\n\r\nul {\r\n    color: black;\r\n    padding: 0;\r\n}\r\n\r\n\r\nheader nav {\r\n    margin:30px 0;\r\n}\r\n\r\nhr {\r\n    margin: 20px 0 60px 0;\r\n}\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-13703.jpg\r\n  [2]: http://cdn.pinsily.site/1530928549067.jpg', 'league.jpg', '2018-07-07 06:44:00', '2019-04-05 16:06:36', 'p', '1. 可以居中显示 2. 小屏幕时可以收缩成按钮菜单', 130, 0, 0, 'pinsily', 10);
INSERT INTO `article` VALUES (46, 'django -- 博客评论功能', '---\r\n\r\n![][1]\r\n\r\n<p><center>用我一生，换你十年天真无邪 -- 盗墓笔记</center></p>\r\n\r\n\r\n----------\r\n### 环境\r\n1. bootstrap 4\r\n2. django 2.0\r\n3. python 3.6\r\n\r\n------\r\n### 实现效果\r\n#### 评论框\r\n采用 bootstrap 模态框实现\r\n\r\n![][2]\r\n\r\n#### 评论列表\r\n除了首级评论，其他都缩进显示\r\n\r\n![][3]\r\n\r\n\r\n#### 效果展示\r\n> [blog.pinsily.site][4]\r\n\r\n----------\r\n### 初始化操作\r\n1. 新建app（实现功能化）\r\n```\r\n$ python manage.py startapp comment\r\n```\r\n\r\n2. 加入 settings.py 中\r\n\r\n----------\r\n### model 设计\r\n```python\r\nfrom django.db import models\r\nfrom django.conf import settings\r\n\r\nfrom django.contrib.contenttypes.fields import GenericForeignKey\r\nfrom django.contrib.contenttypes.models import ContentType\r\n\r\n\r\nclass Comment(models.Model):\r\n\r\n    # 使用 django 的 ContentType 与 GenericForeignKey 关联评论类型(article)和评论id\r\n    # ContentType： https://juejin.im/entry/581da04f128fe1005afdf618\r\n    content_type = models.ForeignKey(ContentType, on_delete=models.DO_NOTHING)\r\n    object_id = models.PositiveIntegerField()\r\n    content_object = GenericForeignKey(\'content_type\', \'object_id\')\r\n\r\n    # 评论内容\r\n    text = models.TextField()\r\n\r\n    user_name = models.CharField(\'评论者名字\', max_length=100)\r\n    user_email = models.EmailField(\r\n        max_length=50, blank=True, null=True, verbose_name=\'邮箱地址\', help_text=\'邮箱地址，用于发送回复\')\r\n\r\n    # 评论时间和修改时间自动添加\r\n    created_time = models.DateTimeField(\'评论发表时间\', auto_now_add=True)\r\n    modified_time = models.DateTimeField(\'修改时间\', auto_now=True)\r\n\r\n    # 根评论，每个回复都只有一个\r\n    # 根评论的根评论默认为空\r\n    root = models.ForeignKey(\"self\", related_name=\'root_comment\',\r\n                             null=True, on_delete=models.DO_NOTHING, verbose_name=u\"根回复\")\r\n    \r\n    # 父级评论，每个回复只有一个\r\n    # 根评论的父级评论默认为空\r\n    parent = models.ForeignKey(\'self\', related_name=\"parent_comment\",\r\n                               null=True, on_delete=models.DO_NOTHING, verbose_name=u\'父级评论\')\r\n\r\n    # 根评论没有回复谁，为空\r\n    reply_name = models.CharField(\r\n        max_length=100, null=True, blank=True, verbose_name=u\'回复谁\')\r\n\r\n    def __str__(self):\r\n        return self.text[:20]\r\n\r\n    class Meta:\r\n        db_table = \"comment\"\r\n        ordering = [\'created_time\']\r\n```\r\n\r\n1. 数据库迁移操作\r\n```\r\n$ python manage.py makemigrations\r\n$ python manage.py migrate\r\n```\r\n\r\n----------\r\n### view 视图函数\r\n```\r\nfrom django.shortcuts import render, redirect, reverse, get_object_or_404\r\nfrom django.contrib.contenttypes.models import ContentType\r\n\r\n# Create your views here.\r\n\r\nfrom .models import Comment\r\n\r\n\r\ndef comment(request):\r\n    if request.method == \"POST\":\r\n        nick = request.POST[\'nick\']\r\n        email = request.POST[\'email\']\r\n        text = request.POST[\'comment_body\']\r\n\r\n        # 参数都由隐藏的 input 提供\r\n        content_type = request.POST[\"content_type\"]\r\n        object_id = int(request.POST[\"object_id\"])\r\n        parent_id = int(request.POST[\'reply_comment_id\'])\r\n\r\n        # 新建评论\r\n        comment = Comment()\r\n\r\n        # 获取对应的文章\r\n        model_class = ContentType.objects.get(model=content_type).model_class()\r\n        model_obj = model_class.objects.get(pk=object_id)\r\n\r\n        # 关联评论和父级评论\r\n        parent = None\r\n        if parent_id:\r\n            parent = get_object_or_404(Comment, pk=parent_id)\r\n\r\n        # 判断是否是回复评论\r\n        if not parent is None:\r\n            comment.root = parent.root if not parent.root is None else parent\r\n            comment.parent = parent\r\n            comment.reply_name = parent.user_name\r\n        else:\r\n            comment.root = None\r\n            comment.parent = None\r\n\r\n        comment.user_name = nick\r\n        comment.user_email = email\r\n        comment.text = text\r\n        comment.content_object = model_obj\r\n\r\n        comment.save()\r\n\r\n        # 评论后回到原页面\r\n        referer = request.META.get(\r\n            \'HTTP_REFERER\', reverse(\"blog:index\"))\r\n        return redirect(referer)\r\n\r\n    referer = request.META.get(\r\n        \'HTTP_REFERER\', reverse(\"blog:index\"))\r\n    return redirect(referer)\r\n\r\n```\r\n\r\n----------\r\n### url\r\n1. 主 url\r\n```\r\nurlpatterns = [\r\n    # ....\r\n    path(\'comment/\', include(\'comment.urls\')),\r\n]\r\n```\r\n\r\n\r\n2. comment url\r\n```\r\nfrom django.urls import path, include, re_path\r\nfrom . import views\r\n\r\napp_name = \'comment\'\r\n\r\nurlpatterns = [\r\n    path(\'\', views.comment, name=\'user_comment\'),\r\n]\r\n```\r\n\r\n----------\r\n### 页面代码\r\n1. comment.html：通过 `{% include \"blog/comment.html\" %}` 引入到文章详情页\r\n```html\r\n{% load static %}\r\n<!-- modal begin -->\r\n<div class=\"modal fade\" id=\"commentModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\">\r\n  <div class=\"modal-dialog\" role=\"document\">\r\n    <div class=\"modal-content\">\r\n      <div class=\"modal-header\">\r\n        <h4 class=\"modal-title\" id=\"myModalLabel\">Comment</h4>\r\n\r\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\r\n      </div>\r\n      <div class=\"modal-body\">\r\n        <form class=\"form-horizontal\" role=\"form\" action=\"{% url \'comment:user_comment\'%}\" method=\"post\">\r\n          {% csrf_token %}\r\n            <div class=\"form-group\">\r\n                \r\n                <div class=\"col-sm-12\">\r\n                    <input type=\"text\" class=\"form-control\" name=\"nick\" id=\"nick\" placeholder=\"nick\">\r\n                </div>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <div class=\"col-sm-12\">\r\n                    <input type=\"email\" class=\"form-control\" name=\"email\" id=\"email\" placeholder=\"email\">\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"form-group\">\r\n                \r\n                <div class=\"col-sm-12\">\r\n                    <textarea type=\"text\" class=\"form-control\" name=\"comment_body\" id=\"conent\" placeholder=\"content\" rows=\"4\"></textarea>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"form-group\">\r\n                \r\n                <div class=\"col-sm-12\">\r\n                    <input type=\"hidden\" name=\"object_id\" value=\"{{ article.pk }}\">\r\n                    <input type=\"hidden\" name=\"content_type\" value=\"article\">\r\n                    <input type=\"hidden\" name=\"reply_comment_id\" id=\"reply_comment_id\" value=\"\">\r\n                </div>\r\n            </div>\r\n\r\n\r\n            <div class=\"form-group\">\r\n              <div class=\"col-sm-12\">\r\n              <button class=\"btn btn-primary btn-sm btn-block\" id=\"comment_btn\">Comment</button>\r\n              </div>\r\n            </div>\r\n        </form>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- modal end -->\r\n\r\n<!-- comment list begin -->\r\n<div class=\"col-12 comment-list\">\r\n\r\n  <p>评论列表&nbsp;&nbsp;\r\n\r\n    <a href=\"javascript:reply(0);\">\r\n      <button class=\"btn btn-danger btn-group-justified comment-btn\">我来说一句</button>\r\n    </a>\r\n    \r\n  </p>\r\n  <hr style=\"margin: 5px 0 10px 0;\">\r\n\r\n  <!-- Single Comment -->\r\n  <div class=\"media mb-4\">\r\n    <h6 class=\"mt-0\">\r\n      Comments( {{ comment_list | length }} )\r\n    </h6>\r\n  </div>\r\n  {% for comment in comment_list %}\r\n  <div class=\"media mb-4 comment-root\">\r\n    <img class=\"d-flex mr-3 rounded-circle\" src=\"{% static \'blog/imgs/1.jpg\' %}\" alt=\"\" width=\"25\" height=\"25\" style=\"border: 0.1px solid #afafaf;\">\r\n    <div class=\"media-body text-justify\" style=\"font-size: 14px;\">\r\n      <span>{{ comment.user_name }}</span>&nbsp;&nbsp;<span\"> {{ comment.created_time | date:\'Y-m-d h:i\' }} </span>&nbsp;&nbsp;<span>#</span>\r\n      <a href=\"javascript:reply({{comment.pk}});\">回复</a>\r\n        <p class=\"comment-text\">{{ comment.text  }}</p>\r\n\r\n      {% for reply in comment.root_comment.all %}\r\n\r\n        <span>\r\n          <img class=\"rounded-circle\" src=\"{% static \'blog/imgs/1.jpg\' %}\" alt=\"\" width=\"25\" height=\"25\" style=\"border: 0.1px solid #afafaf; margin: 2px; margin-right: 15px; \">\r\n          <span>{{ reply.user_name }}</span>&nbsp;&nbsp;\r\n          <span> {{ reply.created_time | date:\'Y-m-d h:i\' }} </span>&nbsp;&nbsp;\r\n          <span> 回复 </span>&nbsp;&nbsp;\r\n          <span> {{ reply.reply_name }}: </span>&nbsp;&nbsp;\r\n          <span> # </span>&nbsp;&nbsp;\r\n          <a href=\"javascript:reply({{reply.pk}});\">回复</a>\r\n        </span>\r\n          <p class=\"comment-reply-text\">{{ reply.text }}</p>\r\n\r\n      {% endfor %}\r\n\r\n    </div>\r\n  </div>\r\n  {% empty %}\r\n\r\n  <div class=\"media mb-4\">\r\n    <div class=\"media-body\">\r\n      <h6 class=\"mt-0\">暂时没有评论！</h6>\r\n    </div>\r\n  </div>\r\n  {% endfor %}\r\n\r\n</div>\r\n\r\n<!-- comment list end -->\r\n\r\n<script type=\"text/javascript\">\r\n  \r\n  function reply(reply_comment_id) {\r\n      $(\"#reply_comment_id\").val(reply_comment_id);\r\n      $(\'#commentModal\').modal({keyboard: false});\r\n  }\r\n\r\n</script>\r\n\r\n```\r\n\r\n----------\r\n### 部分 css\r\n```css\r\n/*---------------------------------------------------------*/\r\n/*comment*/\r\n.comment-list {\r\n    background-color: white;\r\n    border: solid #bcbcbc 1px;\r\n    border-top: solid 3px #1ba1e2;\r\n    border-radius: 15px;\r\n    margin: 50px 0 100px 0;\r\n    padding-top: 20px;\r\n}\r\n\r\n\r\n.comment-btn {\r\n    padding: 3px 3px 4px 3px; \r\n    font-size: 14px; \r\n    cursor:pointer;\r\n}\r\n\r\n.comment-root {\r\n    border: 0.1px solid #afafaf;\r\n    padding: 8px;\r\n    margin: 10px; \r\n}\r\n\r\n.comment-list span {\r\n    font-size: 14px;\r\n}\r\n\r\n.comment-reply-text {\r\n    font-size:14px; padding: 9px 0; margin:0; text-indent: 56px;\r\n}\r\n\r\n.comment-text {\r\n    font-size:14px; padding: 9px 0; margin:0;\r\n}\r\n\r\n/*---------------------------------------------------------*/\r\n/*----------------------*/\r\n/*Model*/\r\n\r\n.modal {\r\n    color: black;\r\n}\r\n\r\n.modal-body {\r\n    margin: 0 auto;\r\n    text-align: center;\r\n    width: 100%;\r\n}\r\n\r\n.modal-img {\r\n    width: 100%;\r\n    text-align: center;\r\n    background-color: #888888;\r\n}\r\n\r\n.modal-img img {\r\n    border: 1px #888888 solid;\r\n    width: 100%;\r\n    overflow: hidden;\r\n    \r\n    /*opacity: 0.5;*/\r\n}\r\n\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-18818.jpg\r\n  [2]: http://cdn.pinsily.site/1530929476230.jpg\r\n  [3]: http://cdn.pinsily.site/1530931580246.jpg\r\n  [4]: http://blog.pinsily.site', 'lotus.jpg', '2018-07-07 06:46:00', '2019-04-09 11:24:27', 'p', '用我一生，换你十年天真无邪 -- 盗墓笔记', 354, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (48, 'python -- 奇偶排序', '----------\r\n\r\n![][1]\r\n\r\n<center><p>好像突然有了软肋，又突然有了铠甲！</p></center>\r\n\r\n---------\r\n### 说明 -- wiki\r\n> 该算法中，通过比较数组中相邻的（奇-偶）位置数字对，如果该奇偶对是错误的顺序（第一个大于第二个），则交换。下一步重复该操作，但针对所有的（偶-奇）位置数字对。如此交替进行下去\r\n\r\n----------\r\n### 动图\r\n![][2]\r\n\r\n\r\n----------\r\n###代码实现\r\n```python\r\ndef odd_even(L):\r\n	print(L)\r\n	while True:\r\n		sorted = True\r\n		# 奇-偶\r\n		for i in range(0,len(L)-1,2):\r\n			if L[i]>L[i+1]:\r\n				L[i], L[i+1] = L[i+1], L[i]\r\n				sorted = False\r\n\r\n		print(L)\r\n\r\n		# 偶-奇\r\n		for i in range(1,len(L)-1,2):\r\n			if L[i]>L[i+1]:\r\n				L[i], L[i+1] = L[i+1], L[i]\r\n				sorted = False\r\n		print(L)\r\n		\r\n		if sorted:\r\n			break\r\n\r\n	return L\r\n\r\nif __name__ == \'__main__\':\r\n	L = [23,42,2,34,34,322,5,43,2,3,13,56,32]\r\n	L = odd_even(L)\r\n	print(L)\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%AE%BE%E8%AE%A1%20-%201.jpg\r\n  [2]: https://upload.wikimedia.org/wikipedia/commons/1/1b/Odd_even_sort_animation.gif', 'nastas-ya.jpg', '2018-02-02 14:30:00', '2019-04-06 15:27:29', 'p', '该算法中，通过比较数组中相邻的（奇-偶）位置数字对，如果该奇偶对是错误的顺序（第一个大于第二个），则交换', 120, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (49, 'python -- 鸡尾酒排序', '----------\r\n![][1]\r\n\r\n<center><p>我需要，最狂的风，和最静的海</p></center>\r\n\r\n---------\r\n### 说明 -- wiki\r\n> 鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序\r\n\r\n----------\r\n### 排序动图\r\n![][2]\r\n\r\n----------\r\n### 算法实现\r\n在冒泡算法的基础加上一层反向遍历\r\n```\r\ndef cocktail(L):\r\n	print(L)\r\n	for i in range(len(L)-1):\r\n		count = len(L)-1-i   \r\n		a = i \r\n		for j in range(len(L)-1-i):        \r\n			if L[j] > L[j+1]:            \r\n				L[j], L[j+1] = L[j+1], L[j]\r\n\r\n		while(count>a):\r\n			if L[count]<L[count-1]:\r\n				L[count],L[count-1] = L[count-1],L[count]\r\n			count -= 1\r\n		print(L)\r\n\r\n	return L\r\n\r\nif __name__ == \'__main__\':\r\n	L = [23,42,2,34,34,322,5,87,6,9,0,45,666,1]\r\n	L = cocktail(L)\r\n	print(L)\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%A7%86%E8%A7%89%20-%2024.jpg\r\n  [2]: https://upload.wikimedia.org/wikipedia/commons/e/ef/Sorting_shaker_sort_anim.gif', 'OakTreeMaize.jpg', '2018-02-01 14:32:00', '2019-04-05 14:13:57', 'p', '鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序', 116, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (50, 'python -- 冒泡排序', '----------\r\n![][1]\r\n\r\n<center><p>等待是这世界上最极致的煎熬</p></center>\r\n\r\n---------\r\n### 排序过程\r\n- 比较相邻的元素。如果第一个比第二个大，就交换他们两个\r\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的\r\n- 针对所有的元素重复以上的步骤，除了最后一个\r\n- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较\r\n\r\n#### 实例\r\n![][2]\r\n\r\n#### 动图\r\n![][3]\r\n\r\n可以看出，每次排序都是确定当前序列的最大值在最后\r\n\r\n----------\r\n### 算法实现\r\n```\r\ndef bubble(L):\r\n	print(L)\r\n	for i in range(len(L)-1):    \r\n	    for j in range(len(L)-1-i):        \r\n	        if L[j] > L[j+1]:            \r\n	            L[j], L[j+1] = L[j+1], L[j]\r\n	    print(L)\r\n\r\n	return L\r\n\r\nif __name__ == \'__main__\':\r\n	L = [23,42,2,34,34,322,5]\r\n	L = bubble(L)\r\n	print(L)\r\n\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%A7%86%E8%A7%89%20-%2024.jpg\r\n  [2]: http://cdn.pinsily.site/1517403734336.jpg\r\n  [3]: http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif', 'oblako-serdce.jpg', '2018-01-31 14:33:00', '2019-03-29 19:37:15', 'p', '等待是这世界上最极致的煎熬', 102, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (51, 'python -- 虚拟环境 virtualenv', '----------\r\n\r\n![][1]\r\n\r\n<center><p>过去是过去，你就是你</p></center>\r\n\r\n---------\r\n### 前言\r\n一激动把 django 升级了 2.0，结果以前的代码拼命报错，只能用这个虚拟环境了，满足基本使用即可\r\n\r\n\r\n----------\r\n### 使用\r\n1. 安装\r\n```\r\npip install virtualenv\r\n```\r\n\r\n2. 创建目录\r\n```\r\nmkdir project\r\ncd project\r\n```\r\n\r\n3. 新建虚拟环境\r\n```\r\n# 默认为无系统 python 包\r\nvirtualenv envdjango\r\n\r\n# 等价于\r\nvirtualenv --no-site-packages envdjango\r\n\r\n# 配备系统 python 包\r\nvirtualenv --system-site-packages envdjango\r\n\r\n# 指定已安装 python 版本\r\nvirtualenv -p /usr/bin/python2.7 envdjango\r\n```\r\n\r\n4. 运行\r\n```\r\n# window\r\nenvdjango\\Scripts\\activate\r\n\r\n# linux\r\nsource envdjango/bin/activate\r\n```\r\n\r\n5. 安装 python 包\r\n```\r\npip install django==1.11\r\n```\r\n\r\n6. 退出\r\n```\r\ndeactive\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%A7%86%E8%A7%89%20-%2011.jpg', 'OstrichDad_VtPymT5.jpg', '2018-01-21 01:34:00', '2019-04-08 15:14:48', 'p', '一激动把 django 升级了 2.0，结果以前的代码拼命报错，只能用这个虚拟环境了，满足基本使用即可', 238, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (52, 'python -- 同时遍历两个 list', '----------\r\n![][1]\r\n\r\n<center><p>很多人闯进你的生命里，只是为给你上一课，然后转身匆匆就走</p></center>\r\n\r\n---------\r\n### 使用\r\n当两个 list 有对应关系希望同时遍历时，可以使用 zip 函数打包\r\n\r\n一个不恰当的例子\r\n```\r\ntitles = [\'name\',\'gender\',\'age\']\r\nvalues = [\'pinsily\',\'female\',\'23\']\r\nfor title,value in zip(titles,values):\r\n    print(title+\" -- \"+value)\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%A7%86%E8%A7%89%20-%204.jpg', 'MeteorCrater.jpg', '2018-01-20 14:41:00', '2019-04-01 08:00:26', 'p', '当两个 list 有对应关系希望同时遍历时，可以使用 zip 函数打包', 116, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (53, 'numpy -- 基本操作', '----------\r\n\r\n![][1]\r\n\r\n<center><p>有一个捉迷藏社团，他们团长现在还没找到</p></center>\r\n\r\n---------\r\n\r\n### 参考翻译\r\n\r\n> [官网 Quickstart tutorial][2]\r\n\r\n\r\n----------\r\n### Array Creation\r\n> numpy 生成 Array 会返回一个 ndarray 对象\r\n\r\n```python\r\n>>> import numpy as np\r\n>>> a = np.array([[1,2,3],[4,5,6]])  # 直接生成\r\n>>> a\r\narray([[1, 2, 3],\r\n       [4, 5, 6]])\r\n	   \r\n>>> b = np.arange(1,10,2)  # 随机生成，1-10 步长为 2\r\n>>> b\r\narray([1, 3, 5, 7, 9])\r\n\r\n>>> c = np.arange(15)    # 默认 0-15 步长为 1\r\n>>> c\r\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\r\n\r\n\r\n>>> c = np.arange(15).reshape(3,5)  # 更改维度为 3*5\r\n>>> c\r\narray([[ 0,  1,  2,  3,  4],\r\n       [ 5,  6,  7,  8,  9],\r\n       [10, 11, 12, 13, 14]])\r\n	   \r\n	   \r\n>>> d = np.zeros((2,3))  # 生成元素全为 0 的 2*3 \r\n>>> d\r\narray([[ 0.,  0.,  0.],\r\n       [ 0.,  0.,  0.]])\r\n	   \r\n>>> e = np.ones((2,3,4)) # 生成元素全为 1 的三维矩阵\r\n>>> e\r\narray([[[ 1.,  1.,  1.,  1.],\r\n        [ 1.,  1.,  1.,  1.],\r\n        [ 1.,  1.,  1.,  1.]],\r\n\r\n       [[ 1.,  1.,  1.,  1.],\r\n        [ 1.,  1.,  1.,  1.],\r\n        [ 1.,  1.,  1.,  1.]]])\r\n		\r\n\r\n>>> f = np.linspace(1,10,3)  # 生成 1-10 含 3 个元素的等差数列\r\n>>> f\r\narray([  1. ,   5.5,  10. ])\r\n\r\n\r\n>>> g = np.logspace(1,10,3)  # 生成1-10 含 3 个元素的等比数列\r\n>>> g\r\narray([  1.00000000e+01,   3.16227766e+05,   1.00000000e+10])\r\n\r\n>>> s = \"hello\"         # 按照字符 ACSII 码生成矩阵\r\n>>> h = np.fromstring(s,dtype=np.int8)\r\n>>> h\r\narray([104, 101, 108, 108, 111], dtype=int8)\r\n\r\n# 自定义结构体矩阵\r\n>>> person = np.dtype({\'names\':[\'name\',\'age\'],\'formats\':[\'S32\',\'i\']})\r\n>>> person\r\ndtype([(\'name\', \'S32\'), (\'age\', \'<i4\')])\r\n>>> j = np.array([(\'zhang\',21)],dtype=person)\r\n>>> j\r\narray([(b\'zhang\', 21)],\r\n      dtype=[(\'name\', \'S32\'), (\'age\', \'<i4\')])\r\n```\r\n\r\n\r\n\r\n----------\r\n### ndarray 属性\r\n```\r\n>>> a = np.arange(15).reshape((3,5))\r\n>>> a\r\narray([[ 0,  1,  2,  3,  4],\r\n       [ 5,  6,  7,  8,  9],\r\n       [10, 11, 12, 13, 14]])\r\n>>> a.shape\r\n(3, 5)\r\n>>> a.ndim\r\n2\r\n>>> a.dtype\r\ndtype(\'int32\')\r\n>>> a.size\r\n15\r\n>>> type(a)\r\n<class \'numpy.ndarray\'>\r\n```\r\n\r\n\r\n----------\r\n### 基本运算\r\n记过运算之后，生成的结果会存放在一个新的 ndarray 对象中，原矩阵不会被改变，除非你重新对他赋值了\r\n```\r\n>>> a = np.array( [20,30,40,50] )\r\n>>> b = np.arange( 4 )\r\n>>> b\r\narray([0, 1, 2, 3])\r\n>>> c = a - b\r\n>>> c\r\narray([20, 29, 38, 47])\r\n>>> b**2\r\narray([0, 1, 4, 9], dtype=int32)\r\n>>> np.sin(a)\r\narray([ 0.91294525, -0.98803162,  0.74511316, -0.26237485])\r\n>>> a<35\r\narray([ True,  True, False, False], dtype=bool)\r\n```\r\n\r\n**注**：`a*b`表示的是矩阵对应元素的乘法，不是矩阵乘法，矩阵乘法使用  `dot` 来实现\r\n```\r\n>>> a = np.array([[1,1],[0,1]])\r\n>>> b = np.array([[2,0],[3,4]])\r\n>>> a * b\r\narray([[2, 0],\r\n       [0, 4]])\r\n	   \r\n>>> a.dot(b)\r\narray([[5, 4],\r\n       [3, 4]])\r\n	   \r\n>>> np.dot(a,b)\r\narray([[5, 4],\r\n       [3, 4]])\r\n```\r\n\r\n一些运算，比如`*=`，`+=`，会修改原来的矩阵而不是新增一个\r\n```\r\n>>> a\r\narray([[1, 1],\r\n       [0, 1]])\r\n	   \r\n>>> a *= 3\r\n\r\n>>> a\r\narray([[3, 3],\r\n       [0, 3]])\r\n```\r\n\r\n\r\n----------\r\n### Universal Functions\r\n基本方法如下所示，一般都可以见名知意\r\n```\r\nall, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, exp, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, sqrt, std, sum, trace, transpose, var, vdot, vectorize, where\r\n```\r\n\r\n\r\n----------\r\n### Shape Manipulation\r\n#### Changing the shape of an array\r\n下面的方法返回一个新的矩阵\r\n```\r\n>>> a = np.arange(15).reshape((3,5))\r\n>>> a\r\narray([[ 0,  1,  2,  3,  4],\r\n       [ 5,  6,  7,  8,  9],\r\n       [10, 11, 12, 13, 14]])\r\n\r\n>>> a.ravel()  # 将所有元素展成一维数组\r\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\r\n\r\n>>> a.T     # 反转\r\narray([[ 0,  5, 10],\r\n       [ 1,  6, 11],\r\n       [ 2,  7, 12],\r\n       [ 3,  8, 13],\r\n       [ 4,  9, 14]])\r\n	   \r\n>>> a.reshape(15,1)  # 重整\r\narray([[ 0],\r\n       [ 1],\r\n       [ 2],\r\n       [ 3],\r\n       [ 4],\r\n       [ 5],\r\n       [ 6],\r\n       [ 7],\r\n       [ 8],\r\n       [ 9],\r\n       [10],\r\n       [11],\r\n       [12],\r\n       [13],\r\n       [14]])\r\n	   \r\n>>> a   # 原矩阵不发生变化\r\narray([[ 0,  1,  2,  3,  4],\r\n       [ 5,  6,  7,  8,  9],\r\n       [10, 11, 12, 13, 14]])\r\n\r\n```\r\n\r\n#### 合并矩阵\r\n```python\r\nIn [2]: import numpy as np\r\n\r\nIn [3]: a = np.floor(10*np.random.random((2,2)))\r\n\r\nIn [4]: a\r\nOut[4]:\r\narray([[ 7.,  8.],\r\n       [ 7.,  5.]])\r\n\r\nIn [5]: b = np.floor(10*np.random.random((2,2)))\r\n\r\nIn [6]: b\r\nOut[6]:\r\narray([[ 5.,  0.],\r\n       [ 1.,  2.]])\r\n```\r\n\r\n**垂直合并**\r\n\r\n```\r\nIn [7]: np.vstack((a,b))   # 垂直合并\r\nOut[7]:\r\narray([[ 7.,  8.],\r\n       [ 7.,  5.],\r\n       [ 5.,  0.],\r\n       [ 1.,  2.]])\r\n```\r\n\r\n**水平合并**\r\n\r\n```\r\nIn [8]: np.hstack((a,b))\r\nOut[8]:\r\narray([[ 7.,  8.,  5.,  0.],\r\n       [ 7.,  5.,  1.,  2.]])\r\n```\r\n\r\n### 切分矩阵\r\n```\r\nIn [9]: a = np.floor(10*np.random.random((2,12)))\r\n\r\nIn [10]: a\r\nOut[10]:\r\narray([[ 8.,  2.,  2.,  5.,  4.,  4.,  8.,  0.,  1.,  6.,  4.,  2.],\r\n       [ 4.,  8.,  4.,  3.,  7.,  1.,  0.,  8.,  3.,  5.,  2.,  6.]])\r\n```\r\n\r\n**平均切割为 3 列**\r\n\r\n```\r\nIn [11]: np.hsplit(a,3)\r\nOut[11]:\r\n[array([[ 8.,  2.,  2.,  5.],\r\n        [ 4.,  8.,  4.,  3.]]), array([[ 4.,  4.,  8.,  0.],\r\n        [ 7.,  1.,  0.,  8.]]), array([[ 1.,  6.,  4.,  2.],\r\n        [ 3.,  5.,  2.,  6.]])]\r\n```\r\n\r\n**第 3、4 列为界限分开**\r\n\r\n```\r\nIn [12]: np.hsplit(a,(3,4))\r\nOut[12]:\r\n[array([[ 8.,  2.,  2.],[ 4.,  8.,  4.]]), \r\n  array([[ 5.],[ 3.]]), \r\n  array([[ 4.,  4.,  8.,  0.,  1.,  6.,  4.,  2.],\r\n        [ 7.,  1.,  0.,  8.,  3.,  5.,  2.,  6.]])]\r\n```\r\n\r\n----------\r\n### 总结\r\n上面所记录的差不多可以应付基本的使用了，简单查阅\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/343115-106.jpg\r\n  [2]: https://docs.scipy.org/doc/numpy-dev/user/quickstart.html', 'paporotnik.jpg', '2017-12-11 14:43:00', '2019-04-05 04:35:30', 'p', '有一个捉迷藏社团，他们团长现在还没找到', 102, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (55, 'css --  链接悬停动画效果(从左到右)', '----------\r\n\r\n![][1]\r\n\r\n<center><p>绿兮衣兮，绿衣黄里。心之忧矣，曷维其已</p></center>\r\n\r\n----------\r\n### 效果\r\n\r\n![][2]\r\n\r\n当鼠标悬停时，下划线从左往右延伸\r\n\r\n----------\r\n### css 样式\r\n\r\n```css\r\n/*链接效果*/\r\na {\r\n	color: #61BFC1;\r\n	margin: 0;\r\n	padding: 0;\r\n	font-size: 15px;\r\n	font-family: Times, TimesNR, \'New Century Schoolbook\', Georgia, \'New York\', serif;\r\n	text-decoration: none;\r\n	vertical-align: baseline;\r\n	position:relative;\r\n}\r\n\r\n\r\na:hover {\r\n	text-decoration: none;\r\n}\r\n\r\na::after{\r\n    content:\'\';\r\n    display:block;\r\n    /*开始时候下划线的宽度为0*/\r\n    width:0;\r\n    height:1px;\r\n    position:absolute;\r\n    left:0;\r\n    bottom:-1px;\r\n    background:#61BFC1;\r\n    /*这里我们设定所有改变都有动画效果，可以自己指定样式才有动画效果*/\r\n    transition:all 0.3s ease-in-out;\r\n}\r\n\r\na:hover::after{\r\n    width:100%;\r\n}\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/357249-106.jpg\r\n  [2]: http://cdn.pinsily.site/1511013110266.jpg', 'nastas-ya_vRzZVKo.jpg', '2017-11-16 03:59:00', '2019-04-03 15:37:43', 'p', '当鼠标悬停时，下划线从左往右延伸', 180, 0, 0, 'pinsily', 5);
INSERT INTO `article` VALUES (56, 'typecho -- title 小图标', '----------\r\n\r\n![][1]\r\n\r\n<center><p>你的时光是什么颜色</p></center>\r\n\r\n----------\r\n### 效果\r\n\r\n![][2]\r\n\r\n----------\r\n### 实现\r\n\r\n下载好需要的 ico 格式图标，可以在这里下载：[https://www.easyicon.net/][3]\r\n\r\n然后在 `<head></head>` 标签中加入下面语句\r\n```\r\n<link rel=\"shortcut icon\" href=\"<?php $this->options->themeUrl(\'images/title.ico\'); ?>\" type=\"image/x-icon\" />\r\n```\r\n只要修改 href 里面的图片地址就可以了\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/148081-106.jpg\r\n  [2]: http://cdn.pinsily.site/1511351455654.jpg\r\n  [3]: https://www.easyicon.net/', 'WhalePod_aFOFKZ1.jpg', '2017-11-15 04:13:00', '2019-04-03 23:58:46', 'p', '下载好需要的 ico 格式图标，可以在这里下载', 104, 0, 0, 'pinsily', 11);
INSERT INTO `article` VALUES (57, 'js -- 网站运行时间', '----------\r\n\r\n![][1]\r\n\r\n<center><p>你若与我化风，我便为你成龙</p></center>\r\n\r\n----------\r\n### 实现效果\r\n\r\n![][2]\r\n\r\n上面的是动态刷新的，下面的是静态的，需要手动刷新才会更新\r\n\r\n----------\r\n### 动态代码\r\n```html\r\n<script data-no-instant=\"\"> \r\n\r\n	function show_date_time() {\r\n		window.setTimeout(\"show_date_time()\",1e3);\r\n		var BirthDay=new Date(\"August 15,2017 18:19:35\"),\r\n		today=new Date,\r\n		timeold=today.getTime()-BirthDay.getTime(),\r\n		msPerDay=864e5,\r\n		e_daysold=timeold/msPerDay,\r\n		daysold=Math.floor(e_daysold),\r\n		e_hrsold=24*(e_daysold-daysold),\r\n		hrsold=Math.floor(e_hrsold),\r\n		e_minsold=60*(e_hrsold-hrsold),\r\n		minsold=Math.floor(60*(e_hrsold-hrsold)),\r\n		seconds=Math.floor(60*(e_minsold-minsold));\r\n		span_dt_dt.innerHTML=\"<font color=black>\"+daysold+\"</font> 天 <font color=black>\"+hrsold+\"</font> 时 <font color=black>\"+minsold+\"</font> 分 <font color=black>\"+seconds+\"</font> 秒\";} \r\n	show_date_time();\r\n\r\n</script>\r\n\r\n<p style=\"color: grey;\"><h6>本站已运行: <span id=\"span_dt_dt\"></span></h6></p>\r\n```\r\n\r\n\r\n\r\n----------\r\n### 静态代码\r\n```html\r\n<p style=\"color: grey;\"><h6>本站已运行:\r\n		<span>\r\n		    <script>\r\n			    BirthDay=new Date(\"August 15,2017 18:19:35\");\r\n			    today=new Date();\r\n			    timeold=(today.getTime()-BirthDay.getTime());\r\n			    sectimeold=timeold/1000;\r\n			    secondsold=Math.floor(sectimeold);\r\n			    msPerDay=24*60*60*1000;\r\n			    \r\n			    /*获取天数*/\r\n			    e_daysold=timeold/msPerDay;\r\n			    daysold=Math.floor(e_daysold);\r\n\r\n			    /*获取小时数*/\r\n			    e_hrsold=(daysold-e_daysold)*-24;\r\n				hrsold=Math.floor(e_hrsold);\r\n\r\n				/*获取分钟数*/\r\n				e_minsold=(hrsold-e_hrsold)*-60;\r\n				minsold=Math.floor((hrsold-e_hrsold)*-60);\r\n\r\n				/*获取秒数*/\r\n				seconds=Math.floor((minsold-e_minsold)*-60);\r\n\r\n			    document.write(\"<font color=black>\"+daysold+\"</font> 天 <font color=black>\"+hrsold+\"</font> 时 <font color=black>\"+minsold+\"</font> 分 <font color=black>\"+seconds+\"</font> 秒\");\r\n		    </script>\r\n		</span></h6> \r\n	</p>\r\n	\r\n	<p style=\"color:grey;\"><h6>@Copyright 2017 by pinsily,@Power by typecho</h6></p>\r\n	\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/112546-106.jpg\r\n  [2]: http://cdn.pinsily.site/1510991753070.jpg', 'WineDay.jpg', '2017-11-17 04:32:00', '2019-04-04 02:59:24', 'p', '你若与我化风，我便为你成龙', 156, 0, 0, 'pinsily', 9);
INSERT INTO `article` VALUES (58, 'css -- 旋转头像', '----------\r\n\r\n![][1]\r\n\r\n<center><p>越过人性的沼泽，谁可以不被弄脏</p></center>\r\n\r\n----------\r\n### 实现效果\r\n\r\n![][2]\r\n\r\n当鼠标悬停是图片顺时针旋转 360 度，离开时逆时针旋转回来\r\n\r\n----------\r\n### css 样式\r\n```css\r\n.headimage_ {  \r\n	width: 150px;  \r\n	height: 150px;  \r\n	margin: 0 auto;  \r\n	background: no-repeat url(\"../images/12.jpg\") left top;  \r\n	-webkit-background-size: 150px 150px;  \r\n	-moz-background-size: 150px 150px;  \r\n	background-size: 150px 150px;  \r\n	-webkit-border-radius: 110px;  \r\n	border-radius: 110px;  \r\n	-webkit-transition: -webkit-transform 1s ease-out;  \r\n	-moz-transition: -moz-transform 1s ease-out;  \r\n	-o-transition: -o-transform 1s ease-out;  \r\n	-ms-transition: -ms-transform 1s ease-out;\r\n	border:5px solid #96c2f1;  \r\n}  \r\n\r\n.headimage_:hover {  \r\n	-webkit-transform: rotateZ(360deg);  \r\n	-moz-transform: rotateZ(360deg);  \r\n	-o-transform: rotateZ(360deg);  \r\n	-ms-transform: rotateZ(360deg);  \r\n	transform: rotateZ(360deg);  \r\n}  \r\n```\r\n\r\n使用：\r\n```html\r\n<div class=\"headimage\">\r\n	<div class=\"headimage_\"></div>		\r\n</div>\r\n```\r\n\r\n[图片地址][3]\r\n\r\n![][4]\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/58640-106.jpg\r\n  [2]: http://cdn.pinsily.site/1510988511535.jpg\r\n  [3]: http://pinsily.site/usr/themes/Clown/images/12.jpg\r\n  [4]: http://pinsily.site/usr/themes/Clown/images/12.jpg', 'EtaAquarids_oHTnYrK.jpg', '2017-11-18 04:35:00', '2019-04-05 16:03:16', 'p', '越过人性的沼泽，谁可以不被弄脏', 124, 0, 0, 'pinsily', 5);
INSERT INTO `article` VALUES (59, '﻿typecho -- 分页', '--------\r\n\r\n![][1]\r\n\r\n<center><p>我想作诗，写雨，写夜的相思，写你，写不出</p></center>\r\n\r\n----------\r\n### 实现效果\r\n\r\n![][2]\r\n\r\n----------\r\n### 代码\r\n```\r\n<?php $this->pageNav(\'|<\', \'>|\',10,\'\',array(\'wrapTag\' => \'div\', \'wrapClass\' => \'page-nav\',\'itemTag\' =>\'li\',\'currentClass\' => \'current\',)); ?>\r\n```\r\n- `wrapTag` 外层包裹标签名，默认 `ol`，\r\n- `wrapClass` 外层包裹类名\r\n- `itemTag` 内层标签名， 默认 `li`，\r\n- `textTag` 直接输出文字的标签名，\r\n- `currentClass` 当前聚焦类名，\r\n- `prevClass` 上一页类名,默认为`prev`\r\n- `nextClass` 下一页类名,默认为`next`\r\n\r\n\r\n\r\n对应的 html 为：\r\n```\r\n<div class=\"page-nav\">\r\n\r\n<li class=\"prev\"><a href=\"http://pinsily.site/index.php/page/1/\">|&lt;</a></li>\r\n<li><a href=\"http://pinsily.site/index.php/page/1/\">1</a></li>\r\n<li class=\"current\"><a href=\"http://pinsily.site/index.php/page/2/\">2</a></li>\r\n<li><a href=\"http://pinsily.site/index.php/page/3/\">3</a></li><li><a href=\"http://pinsily.site/index.php/page/4/\">4</a></li>\r\n<li class=\"next\"><a href=\"http://pinsily.site/index.php/page/3/\">&gt;|</a></li>\r\n\r\n</div>\r\n```\r\n\r\n自己的 css 样式：\r\n```\r\n.page-nav {\r\n\r\n	list-style-type: none;\r\n    color: #aaa;\r\n    text-align: center;\r\n\r\n}\r\n\r\n.page-nav .current {\r\n    border-radius: 50%;\r\n    background: #96c2f1;\r\n    box-shadow: 1px 2px 3px #ddd;\r\n}\r\n\r\n.page-nav li {\r\n	border:1px solid #96c2f1;\r\n    display: inline-block;\r\n    float: none;\r\n    padding: 5px 10px 5px 10px;\r\n    margin:0 5px 10px 5px;\r\n    /*background-color: red;*/\r\n}\r\n```\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/105891-106.jpg\r\n  [2]: http://cdn.pinsily.site/1510981065256.jpg', 'OstrichDad_gNGjpPL.jpg', '2017-11-19 04:35:00', '2019-04-04 02:37:04', 'p', '我想作诗，写雨，写夜的相思，写你，写不出', 112, 0, 0, 'pinsily', 11);
INSERT INTO `article` VALUES (60, 'python 进阶(3) -- Counter 类', '----------\r\n\r\n![][1]\r\n\r\n<center><p>我明白你会来，所以我等</p></center>\r\n\r\n----------\r\n### 参考\r\n[官方文档][2]\r\n\r\n----------\r\n### class collections.Counter([iterable-or-mapping])\r\nCounter 集成于 dict 类，因此也可以使用字典的方法，此类返回一个以元素为 key 、元素个数为 value 的 Counter 对象集合\r\n```\r\n>>> from collections import Counter\r\n>>> s = \"hello pinsily\"\r\n>>> d = Counter(s)\r\n>>> d\r\nCounter({\'l\': 3, \'i\': 2, \'h\': 1, \'e\': 1, \'o\': 1, \' \': 1, \'p\': 1, \'n\': 1, \'s\': 1, \'y\': 1})\r\n```\r\n\r\n#### elements()\r\n返回一个迭代器\r\n```\r\n>>> d.elements()\r\n<itertools.chain object at 0x0000019AC812BBA8>\r\n\r\n# 可以进行打印和排序\r\n>>> for i in d.elements():\r\n...     	print(i)\r\n...\r\n\r\n\r\n```\r\n\r\n#### most_common(n)\r\n返回数量最多的前 n 个元素\r\n```\r\n>>> d.most_common(3)\r\n[(\'l\', 3), (\'i\', 2), (\'h\', 1)]\r\n```\r\n\r\n#### subtract([iterable-or-mapping])\r\n相当于减法，调用这个方法的 Counter 会被覆盖掉\r\n```\r\n>>> c = Counter(a=4, b=2, c=0, d=-2)\r\n>>> d = Counter(a=1, b=2, c=3, d=4)\r\n>>> c.subtract(d)\r\n>>> c\r\nCounter({\'a\': 3, \'b\': 0, \'c\': -3, \'d\': -6})\r\n>>> d\r\nCounter({\'d\': 4, \'c\': 3, \'b\': 2, \'a\': 1})\r\n```\r\n\r\n\r\n----------\r\n### 总结\r\n当需要对 list 中的大量数据进行计数时，可以直接使用 Counter ，而不用新建字典来计数\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/239869-0.jpg\r\n  [2]: https://docs.python.org/3/library/collections.html#collections.Counter', 'oblako-serdce_34vTYHV.jpg', '2017-11-01 04:36:00', '2019-04-09 12:53:48', 'p', '我明白你会来，所以我等', 118, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (61, 'python 进阶(2) -- string join', '----------\r\n\r\n![][1]\r\n\r\n<center><p>月似当时，人似当时否？</p></center>\r\n\r\n----------\r\n### 总\r\n在 python 中，一共有两个 join 方法，一个是 str.join(),另一个是 os.path.join() ，这里只了解前一种\r\n\r\n\r\n----------\r\n### str.join(iterable)\r\n> 官方文档\r\n> Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method.\r\n\r\n简单来讲，就是将可迭代对象中的元素以 str 为分隔符拼接返回，但是这些元素必须为 String 类型，不然会报错\r\n\r\n```\r\n# 报错\r\n>>> l = [1,2,3]\r\n>>> \" \".join(l)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: sequence item 0: expected str instance, int found\r\n\r\n# 对 list 拼接\r\n>>> l = [\"hello\",\"pinsily\"]\r\n>>> \" \".join(l)\r\n\'hello pinsily\'\r\n\r\n# 对 string 拼接\r\n>>> s = \"hello pinsily\"\r\n>>> \":\".join(s)\r\n\'h:e:l:l:o: :p:i:n:s:i:l:y\'\r\n\r\n# 对元组拼接\r\n>>> t = (\"hello\",\"pinsily\")\r\n>>> \" \".join(t)\r\n\'hello pinsily\'\r\n\r\n# 对字典拼接\r\n>>> d = {\"hello\":\"1\",\"pinsily\":\"2\",\"and\":\"3\",\"world\":\"4\"}\r\n>>> \" \".join(d)\r\n\'hello pinsily and world\'\r\n\r\n\r\n```\r\n\r\n**注**：当要使用大量的字符串拼接时，尽量避免 `+` 操作，这样会产生大量的临时变量，占据内存，可以先将其拼接到 list 中，然后使用 `join` 方法\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/80501-106.jpg', 'ClaretCup_YO6AOuS.jpg', '2017-10-30 04:39:00', '2019-04-08 16:57:57', 'p', '当要使用大量的字符串拼接时，尽量避免 `+` 操作，这样会产生大量的临时变量，占据内存', 116, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (62, 'python 进阶(0) -- __new__ 与 __init__', '----------\r\n![][1]\r\n\r\n<center><p>今宵明月，绝不西沉。只此美梦，不再苏醒</p></center>\r\n\r\n----------\r\n\r\n\r\n### `__new__`\r\n> 对象的创建，是一个静态方法，第一个参数是 cls\r\n\r\n当我们常见对象 `c = MyClass()` 的时候，`__new__` 方法会被默认调用创建一个 MyClass 新对象,因此，因为没有对象，所以第一个参数就不可能是 `self` 了\r\n\r\n关于 self 的理解：[http://pinsily.site/index.php/archives/272/](http://pinsily.site/index.php/archives/272/)\r\n\r\n```\r\nclass Bar(object):\r\n    pass\r\n\r\nclass Foo(object):\r\n    def __new__(cls,*args, **kwargs):\r\n	return Bar()\r\n\r\nprint(Foo())\r\n\r\n# Output:\r\n# <__main__.Bar object at 0*00000000006F5390>\r\n\r\n```\r\n\r\n可以看出，返回的是 Bar 的一个对象\r\n\r\n\r\n---\r\n### `__init__`\r\n> 对象的初始化，是一个实例方法，第一个参数是 `self`，也就是 `__new__` 方法创建的对象\r\n```\r\nclass Person(object):\r\n    def __init__(self, name, age):\r\n        self.name = name\r\n        self.age = age\r\npinsily = Person(\'pinsily\', 22)\r\n```\r\n\r\n\r\n---\r\n### 总结\r\n一个实例对象的生成，先经过 `__new__` 方法创建对象，然后将对象传递给 `__init__` 的 `self` 参数，实现初始化  \r\n\r\n---\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/46453-106.jpg', 'darling.jpg', '2017-10-24 04:40:00', '2019-03-24 00:48:02', 'p', '对象的创建，是一个静态方法，第一个参数是 cls', 96, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (63, 'python 进阶(1) -- self 简单理解', '----------\r\n![][1]\r\n\r\n<center><p>简单一句话，我们是伙伴</p></center>\r\n\r\n----------\r\n### 结论\r\n1. self 在定义时需要定义，但在调用时会自动传入\r\n2. self 的名字可以变更\r\n3. self 总是指调用时的类的实例\r\n\r\n下面就上面三点进行解释\r\n\r\n----------\r\n\r\n先看一个例子\r\n```\r\n>>> class Test(object):\r\n...     def testSelf(self):\r\n...         print(self)\r\n...\r\n>>> t = Test()\r\n>>> t.testSelf()\r\n<__main__.Test object at 0x00000182DEB82F98>\r\n```\r\n\r\n从例子可以看出，self 实际上是类的对象\r\n\r\n在 python 机制中，当我们执行 t.testSelf() 时，实际上执行的是 Test.testSelf(t)， 其会把生成的对象 t 传递给 self，所以实际打印出来的就是 t 了，因此，self 代表的是`类的实例`\r\n\r\n所以说，当使用类的实例调用类的方法时，self 是不能够省略的，因为 python 有自动传递参数\r\n\r\n那换一个角度想，如果直接执行 Test.testSelf() 的话，是不是在定义类的时候把 self 去掉了，答案是肯定可以去掉的，因为这时候并没有传递实例进去，但这样适应就没有意思了，对吧\r\n\r\n另外，因为 self 仅仅只是代表一个参数，所以他的名字也就可以变更了，但还是约定成俗的比较好\r\n\r\n最后，因为我们传进去的是相应类的实例对象，所以 self 也就总是指向调用时的类的实例\r\n\r\n也就是说，某一个类里面的 self 不一定指向这个类的实例对象，可能是其他类的\r\n\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/62691-106.jpg', 'faro.jpg', '2017-10-27 07:02:00', '2019-04-05 16:53:13', 'p', 'self 实际上是类的对象', 110, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (64, 'python 进阶(4) -- PEP8 规范', '----------\r\n\r\n![][1]\r\n\r\n<center><p>你让我知道，触摸到头顶的天空是什么感觉</p></center>\r\n\r\n----------\r\n#### 前序\r\n学了 python 也有一段时间了，现在在用着 python3，时间久了，也应该慢慢地精进一下，这里从 PEP8 的[官网][2]翻译整理一下，日后慢慢规范，当然也不能生搬硬套，一个标准而已\r\n\r\n\r\n总的归结为如下几个方面：\r\n- 每个缩进层级使用 4 个空格\r\n- 每行最多 79 个字符\r\n- 采用 ASCII 或 UTF-8 编码文件\r\n- 在文件顶端，注释和文档说明之下，每行每条 import 语句只导入一个模块，同时要按标准库、第三方库和本地库的导入顺序进行分组\r\n- 在大中小之间或者逗号之前没有额外的空格\r\n- 类的命名采用骆驼命名法(CameCase); 异常的定义使用 Error 前缀；函数的命名使用小写字符(separated_by_underscored)\r\n\r\n\r\n\r\n----------\r\n#### 缩进(Indentation)\r\n\r\n最基本的：使用 4 个空格完成一个缩进，一个缩进为一个缩进等级(indent level)\r\n\r\n当存在换行情况时，遵循下面缩进规范：\r\n\r\n1. 当第一行有参数时，对齐界定符排列(比如括号)\r\n```\r\n# Aligned with opening delimiter.\r\nfoo = long_function_name(var_one, var_two,\r\n                         var_three, var_four)\r\n```\r\n\r\n\r\n2. 悬挂缩进(hanging indent): 第一行没有参数\r\n```\r\n# Hanging indents should add a level.\r\nfoo = long_function_name(\r\n    var_one, var_two,\r\n    var_three, var_four)\r\n```\r\n\r\n3.  成对的大中小括号(closing brace/bracket/parenthesis)可以写成多行格式,结束时对齐最后一行,也可以对齐开始行\r\n```\r\nmy_list = [\r\n    1, 2, 3,\r\n    4, 5, 6,\r\n    ]\r\n	\r\nmy_list = [\r\n    1, 2, 3,\r\n    4, 5, 6,\r\n]\r\n	\r\n	\r\n```\r\n\r\n\r\n----------\r\n#### Tabs or Spaces?\r\n在 py3 中只能使用同一种风格，这个之后再解决，在复制黏贴的时候经常报错，还不知道是不是这个原因而且该怎样解决\r\n\r\n\r\n----------\r\n#### 最大行长度\r\n> 所有的行最大长度为 79 个字符，所以需要在适当的时候进行换行处理\r\n\r\n断行在操作符之前\r\n\r\n```\r\nincome = (gross_wages\r\n          + taxable_interest\r\n          + (dividends - qualified_dividends)\r\n          - ira_deduction\r\n          - student_loan_interest)\r\n```\r\n\r\n\r\n----------\r\n#### Black Lines\r\n1. 最顶层的函数或类之间隔两个空行\r\n2. 定义在类里面的方法之间隔一个空行\r\n\r\n\r\n----------\r\n#### Imports\r\n1. 同一行导入同一个库函数\r\n```\r\nimport os\r\nimport sys\r\n```\r\n\r\n2. 按照标准库、第三方库、本地库排序，中间使用一行空行隔开\r\n\r\n\r\n----------\r\n#### 空格\r\n1. 在大中小括号之间不要有空格\r\n```\r\nspam(ham[1], {eggs: 2})\r\n```\r\n\r\n2. 在逗号之后加上小括号间不要空格\r\n```\r\nfoo = (0,)\r\n```\r\n\r\n3. 逗号、冒号、分号之前不要空格\r\n```python\r\nif x == 4: print x, y; x, y = y, x\r\n```\r\n\r\n4.  其他\r\n```python\r\nYes: spam(1)\r\nNo:  spam (1)\r\n```\r\n\r\n```python\r\n# Yes:\r\n\r\nx = 1\r\ny = 2\r\nlong_variable = 3\r\n\r\n# No:\r\n\r\nx             = 1\r\ny             = 2\r\nlong_variable = 3\r\n```\r\n\r\n```\r\ni = i + 1\r\nsubmitted += 1\r\nx = x*2 - 1\r\nhypot2 = x*x + y*y\r\nc = (a+b) * (a-b)\r\n```\r\n\r\n5. 参数的赋值等号两边不要空格\r\n```python\r\ndef complex(real, imag=0.0):\r\n    return magic(r=real, i=imag)\r\n```\r\n\r\n\r\n----------\r\n#### 后续\r\n暂时就整理这些，之后需要或者碰到新的再继续更新\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/112546-106.jpg\r\n  [2]: https://www.python.org/dev/peps/pep-0008/', 'nastroeniya.jpg', '2017-11-08 07:02:00', '2019-04-06 16:23:02', 'p', '你让我知道，触摸到头顶的天空是什么感觉', 124, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (65, 'python 进阶(5) -- 函数和方法的区分', '----------\r\n\r\n\r\n![][1]\r\n\r\n<center><p>这是最好的时代，也是最坏的时代</p></center>\r\n\r\n----------\r\n### 参考抄袭\r\n[http://blog.csdn.net/lastinglate/article/details/7295248][2]\r\n[http://blog.csdn.net/amoscn/article/details/77074403][3]\r\n\r\n----------\r\n### python 中的定义\r\n> function —— A series of statements which returns some value to a caller. It can also be passed zero or more arguments which may be used in the execution of the body\r\n\r\n简单来讲，函数就是一个数学公式，处理传进来的参数，可能返回一些值\r\n\r\n> method —— A function which is defined inside a class body. If called as an attribute of an instance of that class, the method will get the instance object as its first argument (which is usually called self)\r\n\r\n方法是定义在 class 中的函数，跟实例对象有关\r\n\r\n但试了一些例子，发现还是有一些区别的\r\n\r\n----------\r\n### 实例\r\n```python\r\ndef fun():\r\n	pass\r\nprint(fun)\r\n\r\n# Output: <function fun at 0x000001F515002EA0>\r\n```\r\n可以看出，这是单独定义的一个函数，可以理解为，在 class 外部定义的可执行函数都是`函数`\r\n\r\n再看一个 class 内部的：\r\n```python\r\nclass test(object):\r\n\r\n    def fun1(self):\r\n        return \'normal\'\r\n\r\n    @staticmethod\r\n    def fun2():\r\n        return \'staticmethod\'\r\n\r\n    @classmethod\r\n    def fun3(cls):\r\n        return \'classmethod\'\r\n\r\nt = test()\r\nprint(t.fun1)\r\nprint(t.fun2)\r\nprint(t.fun3)\r\n\r\n# Output:\r\n# <bound method test.fun1 of <__main__.test object at 0x0000024A270F2898>>\r\n# <function test.fun2 at 0x0000024A270D47B8>\r\n# <bound method test.fun3 of <class \'__main__.test\'>> \r\n```\r\n\r\n**可以看出：**\r\n- 在 class 内定义的普通方法，如 fun1，因为它是要面向将来实例化对象的，其实它就是一个实例方法。它属于 method，是一个方法。\r\n- 在 class 内定义的静态方法，如 fun2，它与任何对象都没有联系，等同于是在 class 外定义的 function，它属于函数。\r\n- 在 class 内定义的类方法，如 fun3，它第一个参数必须是 cls，它与 class 本身是绑定关系，它属于方法。\r\n\r\n\r\n\r\n\r\n----------\r\n### 总结\r\n1. 与类和实例无绑定关系的function都属于函数（function）\r\n2. 与类和实例有绑定关系的function都属于方法（method）\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/30837-106.jpg\r\n  [2]: http://blog.csdn.net/lastinglate/article/details/7295248\r\n  [3]: http://blog.csdn.net/amoscn/article/details/77074403', 'singapore.jpg', '2017-11-11 07:03:00', '2019-04-05 18:30:24', 'p', '简单来讲，函数就是一个数学公式，处理传进来的参数，可能返回一些值', 96, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (66, 'python 进阶(6) -- 字典排序', '--------\r\n![][1]\r\n\r\n<center><p>所有的突然之前，都伴随着漫长的伏笔</p></center>\r\n\r\n----------\r\n### 排序方法\r\n```\r\nsorted(dic.items(), key=lambda d:d[1], reverse = True)\r\n```\r\n`dic.items()` 得到 [(键)，(值)] 的列表\r\n`key` 表示排序的键值选择，d[0] 表示按照健排序，d[1] 表示按照值排序\r\n`reserve` 表示是否反转，默认为 False，即从小到大排序，反转即为从大到小排序\r\n\r\n\r\n----------\r\n### 实例\r\n```\r\n>>> dict = {\"a\":2,\"b\":3,\"r\":32,\"f\":1}\r\n\r\n# 按值进行排序\r\n>>> d = sorted(dict.items(), key=lambda d:d[1], reverse = True)\r\n>>> d\r\n[(\'r\', 32), (\'b\', 3), (\'a\', 2), (\'f\', 1)]\r\n\r\n>>> d = sorted(dict.items(), key=lambda d:d[1])\r\n>>> d\r\n[(\'f\', 1), (\'a\', 2), (\'b\', 3), (\'r\', 32)]\r\n\r\n# 按键进行排序\r\n>>> d = sorted(dict.items(), key=lambda d:d[0], reverse = True)\r\n>>> d\r\n[(\'r\', 32), (\'f\', 1), (\'b\', 3), (\'a\', 2)]\r\n\r\n>>> d = sorted(dict.items(), key=lambda d:d[0])\r\n>>> d\r\n[(\'a\', 2), (\'b\', 3), (\'f\', 1), (\'r\', 32)]\r\n\r\n```\r\n\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/112565-106.jpg', 'singapur.jpg', '2017-11-13 07:05:00', '2019-04-05 15:00:35', 'p', '所有的突然之前，都伴随着漫长的伏笔', 118, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (67, 'python 进阶(10) -- yield keyword', '-----\r\n\r\n![][1]\r\n\r\n<center><p>你泪如雨花洒满了纸上的天下。爱恨如写意山水画</p></center>\r\n\r\n----------\r\n\r\n\r\n### 参考\r\n[https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do](https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do)\r\n[https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/](https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/)\r\n\r\n这篇笔记主要是翻译了第一个链接的内容\r\n\r\n-----\r\n### 说明\r\n\r\n想要了解 yield 的原理，首先得要了解生成器，而生成器来自于迭代器\r\n\r\n\r\n-----\r\n### 迭代器（Iterables）\r\n简单来讲，当我们对一个对象可以实现遍历它的元素时（比如 list，string 这些数据类型），我们就可以说他们是可迭代的\r\n\r\n比如下面的 list\r\n\r\n```\r\nmylist = [x*x for x in range(3)]\r\n\r\nfor i in mylist:\r\n    print(i)\r\n\r\n# Output:\r\n# 0\r\n# 1\r\n# 4\r\n```\r\n\r\n这些可迭代的对象时一次性将所有值放入内存（memory）的，当我们的可迭代对象数据量很大或者我们只是想用其中少部分数据时，消耗就可能不是我们所想要的了 \r\n\r\n这时候，就有了生成器\r\n\r\n\r\n----------\r\n### 生成器(Generators)\r\n生成器是一种只能够使用一次的迭代器，比如当我们使用一个数据量庞大的 list 时，我们需要使用哪些元素，生成器才会将需要的元素放进内存中，一次只返回一个元素\r\n\r\n\r\n----------\r\n### Yield\r\nYield 是跟 return 差不多用法的关键字，不同的是它返回的是一个生成器\r\n\r\n先看一个例子\r\n\r\n```python\r\n>>> def createGenerator():\r\n...     mylist = range(3)\r\n...     for i in mylist:\r\n...         yield i*i\r\n...\r\n>>> mygenerator = createGenerator()\r\n>>> print(mygenerator)\r\n<generator object createGenerator at 0x000001BFDB604830>\r\n```\r\n\r\n可以看到，函数返回的是生成器类型,继续\r\n\r\n```python\r\n>>> for j in mygenerator:\r\n...     print(j)\r\n...\r\n\r\n0\r\n1\r\n4\r\n```\r\n\r\n上面的这段例子貌似跟以前使用的差不多，但这是不存在的\r\n\r\n现在说说自己困惑了好久的一个过程，也就是 yield 的执行过程\r\n\r\n当一个函数或者方法在自己的 body 内发现有 yield 关键字时，里面的代码是不会执行的，只是返回一个生成器\r\n\r\n来到 `for j in mygenerator` 时，这个时候才开始执行函数 body 中的循环代码，当发现 yield 时，就直接返回 `i*i` 的值并中断，当下次循环来到时，再从断点继续\r\n\r\n稍微修改代码验证一下，有 IDE 的话可以打断点 debug\r\n\r\n```python\r\n>>> def createGenerator():\r\n...     mylist = range(3)\r\n...     for i in mylist:\r\n...         yield i*i\r\n...         print(i)\r\n...\r\n>>> mygenerator = createGenerator()\r\n>>> for j in mygenerator:\r\n...     print(j)\r\n...     print(\"hello\")\r\n...\r\n0\r\nhello\r\n0\r\n1\r\nhello\r\n1\r\n4\r\nhello\r\n2\r\n```\r\n\r\n可以看出，`print(j)` 打印的是 `yield i*i` 返回的值，然后不会直接执行 `print(i)`，因为这里断掉了，程序会执行 `print(\"hello\")`，当下一次执行循环时，`print(i)`在断点处执行\r\n\r\nyield 的原理大致是这样，不过，`for j in mygenerator` 这段循环还是有点不太明白，之后再想办法弄懂呗\r\n\r\n\r\n其实，也可以使用生成器自带的方法 `__next__()` 来实现遍历\r\n\r\n> **Note**:在 python2 中，应使用 `next()` 方法，`__next__()` 是 python3 的\r\n\r\n``` python\r\n>>> mygenerator.__next__()\r\n0\r\n>>> mygenerator.__next__()\r\n1\r\n>>> mygenerator.__next__()\r\n4\r\n>>> mygenerator.__next__()\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nStopIteration\r\n```\r\n\r\n当执行到最后再执行时，就会报 StopIteration 的错误，这个在用 for 循环的时候已经自动处理了\r\n\r\n\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/320684-106.jpg', 'praga.jpg', '2017-11-30 07:07:00', '2019-03-31 19:37:17', 'p', '想要了解 yield 的原理，首先得要了解生成器，而生成器来自于迭代器', 90, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (68, 'python 进阶(7) -- @staticmethod和@classmethod', '----------\r\n![][1]\r\n\r\n<center><p>我若成佛，天下无魔</p></center>\r\n\r\n----------\r\n### 翻译\r\n > [https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner][2]\r\n\r\n在翻译的基础上加些其他地方查资料的总结\r\n\r\n----------\r\n### 区别\r\n`@classmethod` 和 `@staticmethod`相类似，存在的差别在于：\r\n1. `@classmethod`必须使用类对象作为第一个参数，而 `@staticmethod` 可以不需要参数，当成函数来使用\r\n\r\n2. 如果在 `@staticmethod` 中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。\r\n而 `@classmethod` 因为持有 `cls` 参数，可以来调用类的属性，类的方法，实例化对象等\r\n\r\n\r\n----------\r\n### Boilerplate\r\n下面使用一个处理日期的类来说明这两者的使用方法\r\n\r\n```python\r\nclass Date(object):\r\n\r\n    def __init__(self, day=0, month=0, year=0):\r\n        self.day = day\r\n        self.month = month\r\n        self.year = year\r\n```\r\n\r\n可以看到，这是我们平时见到的最简单的初始化方法，也就是典型的 `instancemethod` 类型方法，我们在一般类里面定义的方法都是这种类型\r\n\r\n现在假设我们有很多 `(\'dd-mm-yyyy\')` 格式字符串的日期信息，想要把它们创建成 `Date` 类实例。我们不得不在项目的不同地方做这些事情\r\n```python\r\nday, month, year = map(int, string_date.split(\'-\'))\r\ndate1 = Date(day, month, year)\r\n```\r\n\r\n显然，这样会大大增加了代码的重复性\r\n\r\n因为 python 没有 C++ 关于这些优化的重载功能，所以就引入了`@classmethod`，可以使用它得到下面的代码：\r\n```python\r\n    @classmethod\r\n    def from_string(cls, date_as_string):\r\n        day, month, year = map(int, date_as_string.split(\'-\'))\r\n        date1 = cls(day, month, year)\r\n        return date1\r\n\r\ndate2 = Date.from_string(\'11-09-2012\')\r\n```\r\n通过上面的代码我们可以看出：\r\n1. 第一个参数 `cls` 相当于类名 `Date`，也就是说，它是一个类对象，而不是类实例，注意区分\r\n2. 做到了很好的封装，将功能函数化，更对 `OOP` 的口味\r\n\r\n那么，`@staticmethod` 又是什么呢，其实他说上面的两种方法类型差不多，只是对参数没有了强制性的要求罢了\r\n\r\n现在继续假设我们需要验证一个日期字符串的合法性，通常来说，我们是可以直接在类外面建立一个函数来专门处理这个的，但是想到因为它是日期方面的，是否可以放到 `Date` 类里面了，`@staticmethod` 的作用就在于此\r\n```python\r\n    @staticmethod\r\n    def is_date_valid(date_as_string):\r\n        day, month, year = map(int, date_as_string.split(\'-\'))\r\n        return day <= 31 and month <= 12 and year <= 3999\r\n\r\n    \r\nis_date = Date.is_date_valid(\'11-09-2012\')\r\n```\r\n现在正如我们了解到的staticmethod的使用，我们不需要访问它所属的类，它本质上就是一个函数，调用方式和调用函数一样，不同的是它不关注对象和对象内部属性。\r\n\r\n可以简单的理解为只是将这个函数归一下类而已，免得其过于孤单，![][3]\r\n\r\n\r\n----------\r\n### 总结\r\n1. 方法类型一共有三种：`instancemethod`，`staticmethod` and `@classmethod`\r\n2. `@classmethod` 必须将类对象(名字最好为 `cls`)作为第一个参数，而 `staticmethod` 本质上是函数\r\n3. 都是直接 `类名.方法名()` 来调用\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/340877-106.jpg\r\n  [2]: https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner\r\n  [3]: http://cdn.pinsily.site/1512024057539.jpg', 'devushka.jpg', '2017-11-20 07:16:00', '2019-04-05 16:48:00', 'p', '在翻译的基础上加些其他地方查资料的总结', 120, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (69, 'python 进阶(8) -- enumerate()', '----------\r\n\r\n![][1]\r\n\r\n<center><p>Again and again,and to the end</p></center>\r\n\r\n----------\r\n今天遇到一个新的函数 enumerate(), 可以从一个可迭代对象(dict,list,string 等)同时得到索引和值，这样就避免了另外生成变量来操作了\r\n\r\n```shell\r\n>>> l = [\"hello\",\"this\",\"is\",\"my\",\"name\"]\r\n>>> for index,value in enumerate(l):\r\n...     print(index,value)\r\n...\r\n0 hello\r\n1 this\r\n2 is\r\n3 my\r\n4 name\r\n>>> s = \"hello\"\r\n>>> for index, value in enumerate(s):\r\n...     print(index,value)\r\n...\r\n0 h\r\n1 e\r\n2 l\r\n3 l\r\n4 o\r\n```\r\n\r\n还可以接受第二个参数规定初试索引值\r\n```shell\r\n>>> for index, value in enumerate(s,1):\r\n...     print(index,value)\r\n...\r\n1 h\r\n2 e\r\n3 l\r\n4 l\r\n5 o\r\n```\r\n\r\n----------\r\n\r\n\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/80677-106.jpg', 'gin.jpg', '2017-11-21 07:17:00', '2019-04-06 09:55:56', 'p', '今天遇到一个新的函数 enumerate(), 可以从一个可迭代对象(dict,list,string 等)', 112, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (70, 'python 进阶(9) -- JSON 排版', '----------\r\n\r\n![][1]\r\n\r\n<center><p>你忘了我们的破风格言是什么，风在前，无惧</p></center>\r\n\r\n----------\r\n### 方法\r\n使用 json 的 indent 参数可以控制缩进来达到排版 json \r\n```shell\r\n>>> data\r\n{\'programmers\': [{\'firstName\': \'Brett\', \'lastName\': \'McLaughlin\', \'email\': \'aaaa\'}, {\'firstName\': \'Jason\', \'lastName\': \'Hunter\', \'email\': \'bbbb\'}, {\'firstName\': \'Elliotte\', \'lastName\': \'Harold\', \'email\': \'cccc\'}], \'authors\': [{\'firstName\': \'Isaac\', \'lastName\': \'Asimov\', \'genre\': \'science fiction\'}, {\'firstName\': \'Tad\', \'lastName\': \'Williams\', \'genre\': \'fantasy\'}, {\'firstName\': \'Frank\', \'lastName\': \'Peretti\', \'genre\': \'christian fiction\'}], \'musicians\': [{\'firstName\': \'Eric\', \'lastName\': \'Clapton\', \'instrument\': \'guitar\'}, {\'firstName\': \'Sergei\', \'lastName\': \'Rachmaninoff\', \'instrument\': \'piano\'}]}\r\n\r\n>>> print(json.dumps(data))\r\n{\"programmers\": [{\"firstName\": \"Brett\", \"lastName\": \"McLaughlin\", \"email\": \"aaaa\"}, {\"firstName\": \"Jason\", \"lastName\": \"Hunter\", \"email\": \"bbbb\"}, {\"firstName\": \"Elliotte\", \"lastName\": \"Harold\", \"email\": \"cccc\"}], \"authors\": [{\"firstName\": \"Isaac\", \"lastName\": \"Asimov\", \"genre\": \"science fiction\"}, {\"firstName\": \"Tad\", \"lastName\": \"Williams\", \"genre\": \"fantasy\"}, {\"firstName\": \"Frank\", \"lastName\": \"Peretti\", \"genre\": \"christian fiction\"}], \"musicians\": [{\"firstName\": \"Eric\", \"lastName\": \"Clapton\", \"instrument\": \"guitar\"}, {\"firstName\": \"Sergei\", \"lastName\": \"Rachmaninoff\", \"instrument\": \"piano\"}]}\r\n\r\n>>> print(json.dumps(data, indent=2))\r\n{\r\n  \"programmers\": [\r\n    {\r\n      \"firstName\": \"Brett\",\r\n      \"lastName\": \"McLaughlin\",\r\n      \"email\": \"aaaa\"\r\n    },\r\n    {\r\n      \"firstName\": \"Jason\",\r\n      \"lastName\": \"Hunter\",\r\n      \"email\": \"bbbb\"\r\n    },\r\n    {\r\n      \"firstName\": \"Elliotte\",\r\n      \"lastName\": \"Harold\",\r\n      \"email\": \"cccc\"\r\n    }\r\n  ],\r\n  \"authors\": [\r\n    {\r\n      \"firstName\": \"Isaac\",\r\n      \"lastName\": \"Asimov\",\r\n      \"genre\": \"science fiction\"\r\n    },\r\n    {\r\n      \"firstName\": \"Tad\",\r\n      \"lastName\": \"Williams\",\r\n      \"genre\": \"fantasy\"\r\n    },\r\n    {\r\n      \"firstName\": \"Frank\",\r\n      \"lastName\": \"Peretti\",\r\n      \"genre\": \"christian fiction\"\r\n    }\r\n  ],\r\n  \"musicians\": [\r\n    {\r\n      \"firstName\": \"Eric\",\r\n      \"lastName\": \"Clapton\",\r\n      \"instrument\": \"guitar\"\r\n    },\r\n    {\r\n      \"firstName\": \"Sergei\",\r\n      \"lastName\": \"Rachmaninoff\",\r\n      \"instrument\": \"piano\"\r\n    }\r\n  ]\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341186-106.jpg', '1_dLCck36.jpg', '2017-11-23 12:16:00', '2019-04-01 20:12:01', 'p', '使用 json 的 indent 参数可以控制缩进来达到排版 json', 132, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (71, '树莓派(1) -- 安装系统', '----------\r\n![][1]\r\n\r\n<center>不是这个世界变得有趣了。而是你，变成了有趣的人哦</center>\r\n\r\n----------\r\n### 参考\r\n[树莓派新手入门教程][2]\r\n[介绍树莓派初级用户工具“NOOBS”][3]\r\n\r\n----------\r\n\r\n\r\n### 起由\r\n之前就听说过树莓派，到现在因为项目需要用到，所以也就开始尝试了，加上最近的 Nginx，docker 可能会用到，就一起打包学习了\r\n\r\n\r\n----------\r\n### 机型\r\n\r\n#### Raspberry Pi B 型\r\n还有另外一款是比较简单的 Raspberry Pi zero ，只有一个 USB 接口，没必要去折腾这个了\r\n\r\n<div style=\"width:75%; margin:0 auto; margin-bottom:25px\">\r\n\r\n\r\n   <img src=\"http://cdn.pinsily.site/1508741154196.jpg\" alt=\"\">\r\n\r\n</div>\r\n#### Micro SD 卡\r\n接下来这个 SD 卡就是系统的硬盘了\r\n\r\n<div style=\"width:75%; margin:0 auto; margin-bottom:25px\">\r\n\r\n\r\n   <img src=\"http://cdn.pinsily.site/1508741105849.jpg\" alt=\"\">\r\n\r\n</div>\r\n\r\n----------\r\n### 安装系统\r\n直接使用官方提供的安装器 NOOBS\r\n> New Out of Box Software （NOOBS）是树莓派官方发布的工具，是一种新颖的设置程序，很方便的让第一接触Linux和树莓派的玩家能更轻松的运行上树莓派。可以抛开各种复杂的网络和镜像安装软件，甚至可以抛开电脑就能让你安装上你想要的系统。\r\n\r\n[下载NOOBS][6]\r\n\r\n\r\n<div style=\"width:75%; margin:0 auto; margin-bottom:25px\">\r\n\r\n\r\n   <img src=\"http://cdn.pinsily.site/1508741661747.jpg\" alt=\"\">\r\n\r\n</div>\r\n下载好之后将其解压\r\n\r\n在下载和解压的等待时间里，将 SD 卡格式化为 FAT 格式\r\n\r\n<div style=\"width:50%; margin:0 auto; margin-bottom:25px\">\r\n   <img src=\"http://cdn.pinsily.site/1512659409454.jpg\" alt=\"\">\r\n</div>\r\n将解压好的文件目录里的所有文件，注意，是目录里的文件拷贝到 SD 卡的根目录下\r\n\r\n接着插入 Micro SD 卡到树莓派底部的卡槽，将树莓派通过 HDMI 接口连接到显示屏\r\n\r\n*如果显示屏使用的是 VGA 接口的线，可以使用 HDMI 转 VGA 转接线*\r\n\r\n接通电源，启动系统，缓冲完之后，显示屏会列出相关系统，这里选择 Raspbian 系统，选择点击左上角的安装即可，之后系统会重启，进入系统桌面模式\r\n<div style=\"width:75%; margin:0 auto; margin-bottom:25px\">\r\n\r\n\r\n   <img src=\"http://cdn.pinsily.site/1508742526076.jpg\" alt=\"\">\r\n\r\n</div>\r\n\r\n----------\r\n### 设置 SSH 连接\r\nSSH 连接系统是默认关闭的，因为之后就不怎么需要显示屏了，就把他顺便打开\r\n\r\n打开如图设置，OK 保存\r\n\r\n<div style=\"width:75%; margin:0 auto; margin-bottom:25px\">\r\n\r\n\r\n   <img src=\"http://cdn.pinsily.site/1508742736765.jpg\" alt=\"\">\r\n\r\n</div>\r\n\r\n通过命令行命令获取树莓派 IP\r\n```\r\npi@raspberrypi:~$ ifconfig\r\n```\r\n\r\n使用同一局域网的电脑尝试 SSH 登录树莓派\r\n```\r\nssh pi@192.168.199.128\r\n```\r\n\r\n后面的数字为获取的 IP，初始密码为 `raspberry`,**输入的密码是不显示的**\r\n\r\n使用 SSH 进入之后，就可以进行相关的操作了，比如修改密码\r\n```\r\npi@raspberrypi:~ $ passwd\r\nChanging password for pi.\r\n(current) UNIX password:\r\nEnter new UNIX password:\r\nRetype new UNIX password:\r\npasswd: password updated successfully\r\n```\r\n\r\n\r\n----------\r\n### 后续\r\n基本 OK 了，对于安装，因为直接使用了安装器，简单了很多，以后需要的话在慢慢折腾镜像之类的\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/87271-106.jpg\r\n  [2]: http://www.ruanyifeng.com/blog/2017/06/raspberry-pi-tutorial.html\r\n  [3]: http://shumeipai.nxez.com/2013/10/03/introduction-raspberry-pi-primary-user-tools-noobs.html\r\n  [4]: http://cdn.pinsily.site/1508741154196.jpg\r\n  [5]: http://cdn.pinsily.site/1508741105849.jpg\r\n  [6]: https://www.raspberrypi.org/downloads/noobs/\r\n  [7]: http://cdn.pinsily.site/1508741661747.jpg\r\n  [8]: http://cdn.pinsily.site/1508742031153.jpg\r\n  [9]: http://cdn.pinsily.site/1512659409454.jpg\r\n  [10]: http://cdn.pinsily.site/1508742526076.jpg\r\n  [11]: http://cdn.pinsily.site/1508742736765.jpg', '2.jpg', '2017-11-13 12:17:00', '2019-03-29 19:39:37', 'p', '不是这个世界变得有趣了。而是你，变成了有趣的人哦', 118, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (72, '树莓派(2) -- mysql 安装', '----------\r\n\r\n![][1]\r\n<center><p>Yesterday is a history, tomorrow is a mystery, but today is a gift.</p></center>\r\n\r\n----------\r\n### 前序\r\nmysql 在树莓派 raspberry pi 上的安装和在 Linux 上的差不多，因为网上的教程只是记述了一部分且遇到了情况，就整理下来\r\n\r\n----------\r\n### 安装\r\n- 因为不知道突然执行了什么操作，然后系统执行什么命令都要权限了，都要加上 sudo 才能执行，这个看个人情况吧\r\n- 更新软件库\r\n```\r\nsudo apt-get update\r\n```\r\n\r\n- 安装 mysql\r\n```\r\nsudo apt-get install mysql-server\r\n```\r\n\r\n接下来就是安装过程了，本来以为中间会提示输入密码，结果一口气就安装完了，想到该怎么登陆啊\r\n\r\n- 以空密码登陆\r\n```\r\nsudo mysql -u root\r\n```\r\n```\r\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.\r\nYour MariaDB connection id is 6\r\nServer version: 10.1.23-MariaDB-9+deb9u1 Raspbian 9.0\r\n\r\nCopyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.\r\n\r\nType \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\r\n\r\nMariaDB [(none)]>\r\n```\r\n\r\n**注**：遇到陌生的 MariaDB，百科了发现是 mysql 的一个分支，完全继承 mysql 的用法，所以也不担心了，不过，这个应该是看个人情况的\r\n\r\n\r\n- 修改密码\r\n```shell\r\n# 数据库中使用\r\n# 连接数据库\r\nuse mysql;\r\n\r\n# 修改密码为123456，自己定\r\nUPDATE user SET password=PASSWORD(\'123456\') WHERE user=\'root\';\r\n\r\n# 刷新\r\nflush privileges;\r\n\r\n# 退出\r\nexit;\r\n```\r\n\r\n- 操作数据库服务\r\n```\r\nsudo /etc/init.d/mysql status/start/stop/restart\r\n```\r\n\r\n\r\n----------\r\n### 总结\r\n安装之后需要修改密码，不然密码为空\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/354905-106.jpg', '3.jpg', '2017-11-15 12:18:00', '2019-04-03 23:16:08', 'p', 'mysql 在树莓派 raspberry pi 上的安装和在 Linux 上的差不多，因为网上的教程只是记述', 106, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (73, '树莓派(3) -- 编译安装 Python3.6 更新', '----------\r\n\r\n![][1]\r\n\r\n<center><p>时间的齿轮从未停止转动，让每个生命得以平行前进</p></center>\r\n\r\n----------\r\n### 安装\r\n- 更新软件库\r\n```\r\nsudo apt-get update\r\n```\r\n\r\n- 安装依赖\r\n```\r\nsudo apt-get install build-essential libsqlite3-dev sqlite3 bzip2 libbz2-dev libssl-dev openssl libgdbm-dev liblzma-dev libreadline-dev libncursesw5-dev\r\n```\r\n\r\n- 下载 py3.6 源码，解压\r\n```shell\r\nwget https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz\r\ntar -zxvf Python-3.6.0.tgz\r\n```\r\n\r\n- 配置\r\n将 python3.6 安装到 /opt/python3.6 中，LTO 为优化选项，还不懂\r\n\r\n```shell\r\ncd ./Python-3.6.0\r\n./configure --prefix=/opt/python3.6 --with-lto  \r\n```\r\n\r\n- 编译\r\nmake 两次，第一次 make 时间比较久，我的大概半个钟左右\r\n```shell\r\nmake\r\nmake\r\n```\r\n\r\n- 安装\r\n```shell\r\nsudo make install\r\n```\r\n\r\n- 创建软链接\r\n```shell\r\n# 删掉原来指向 py2 的链接\r\nsudo rm /usr/bin/python\r\n\r\n# 定义 python 指向 python3.6\r\nsudo ln -s /opt/python3.4/bin/python3.6  /usr/bin/python\r\n\r\n# 因为怕 pip 出现错误，所以也给 pip3.6 创建了链接，不知道有没必要 \r\nsudo ln -s /opt/python3.4/bin/pip3.6 /usr/bin/pip3.6\r\n```\r\n\r\n- 更新完成，可以自己完成测试了\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/30837-106.jpg', '4.jpg', '2017-11-22 12:18:00', '2019-04-03 18:07:54', 'p', '时间的齿轮从未停止转动，让每个生命得以平行前进', 112, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (74, '﻿日志 -- 2017.12.07', '----------\r\n今天早上把服务器系统重装了，突然感觉自己是不是学艺不精了，碰到了这么多的问题，解决了一个又来一个，怎样来说，都是很无奈的事情，而这次的无奈，仅仅只是因为自己懒得调一个小错误，或许上网搜搜就能解决的事情，结果偷懒去重启了服务器，mysql 数据库崩溃得一塌糊涂，再则是被自己整得不堪入目\r\n\r\n几个月来的博客都成了落花流水，说有情有义，都有点假了，看着重新搭建起来的博客，唯一的欣慰只能是重新安装的东西速度重新跟上来了，想想也是算了，之前安装的乱七八糟的，现在也算是可以重新来过了\r\n\r\n重新来过，打下这几个字的，还是蛮容易的，想到要把差不多上百篇的博客重新复制黏贴上去，总还是有些泄气的，想把所有的格式都统一一遍，或者换一种新的风格来适当地减轻一下视觉疲劳，还是有些有心无力吧，翻了以前写的内容笔记，现在看来，未免变得有些滥竽充数之嫌了，以前的陈词滥调，编成了一首怎样的歌\r\n\r\n洗澡的时候，听着歌，梳理着，诚觉又好像表面上忙得团团转的状态了，还没过的六级又再次裸考的状态，还是无所谓的感觉，虽不必须，也是鸡肋的错觉，自然而然，懒得来了\r\n\r\n研究者的态势，还是有些不适应，况且，自己还是一个简单的旁观者，在这里，不像在社团一般，随时可以找个人都可以开几句玩笑，在他们面前，感觉重新回到了最初，或许，这就是每次进入一个新群体的必然吧，反正，也决定不了什么罢了，以后就会了吧\r\n\r\n和小巴开的玩笑，五十步笑百步的始作俑者，大抵也是会继续笑着说道，仅仅只是个玩笑而已，虽不可否认，记忆力真的降低了不少，还是会拿着大脑内存有限的借口，讲着这是因为自己在不断学习着新的知识，但是忘记陈旧的，会不会得不偿失呢？停了，扯得好像是要面临老年痴呆的风险那般\r\n\r\n再怎么算，还是学艺不精吧，见异思迁，偶尔为之就好\r\n\r\n当思维的速度跟上了打字速度的时候，会发现，码下的很多字，都是废话\r\n\r\n记，一次重装服务器引发的连篇累牍\r\n\r\n这次，不配文，不配图\r\n\r\n----------', '5.jpg', '2017-12-07 12:19:00', '2019-04-03 16:29:06', 'p', '今天早上把服务器系统重装了，突然感觉自己是不是学艺不精了，碰到了这么多的问题，解决了一个又来一个', 96, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (75, 'win10 -- cmd 获取连接过的 wifi 密码', '----------\r\n\r\n![][1]\r\n\r\n<center><p>时间可以治愈？如果时间也病了怎么办？</p></center>\r\n\r\n----------\r\n### 方法\r\n1. `win+R` 输入 `cmd` 打开命令行界面\r\n\r\n2. 输入一下命令，回车执行\r\n\r\n``` shell\r\nfor /f \"skip=9 tokens=1,2 delims=:\" %i in (\'netsh wlan show profiles\') do  @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear\r\n```\r\n\r\n3. 效果\r\n\r\n![][2]\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341186-106.jpg\r\n  [2]: http://cdn.pinsily.site/1512820757199.jpg', '6.jpg', '2017-12-09 12:20:00', '2019-04-10 04:26:27', 'p', '时间可以治愈？如果时间也病了怎么办？', 98, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (76, 'win10 - 淡绿色护眼背景(注册表)', '----------\r\n\r\n![][1]\r\n<center>提笔思念，落笔无言。炉中的香，让它消散吧，桌上的茶，随它渐凉。知道你还在张望，就足够温暖。</center>\r\n\r\n----------\r\n\r\n### 效果图\r\n\r\n记事本背景\r\n\r\n<div style=\"width:50%;margin:0 auto; margin-bottom:25px;\">\r\n\r\n    <img src=\"http://cdn.pinsily.site/1507361983517.jpg\" alt=\"\" />\r\n    \r\n\r\n</div>\r\n\r\n\r\nword 文档背景\r\n\r\n<div style=\"width:50%;margin:0 auto; margin-bottom:25px;\">\r\n\r\n    \r\n    <img src=\"http://cdn.pinsily.site/1507362037880.jpg\" alt=\"\" />\r\n</div>\r\n\r\n\r\n还有其他的一些编辑界面也会改为此颜色，个人调整\r\n\r\n这个模式貌似电脑管家这些都会有所配置，可惜电脑不喜欢安装这些管家，就只能找注册表了\r\n\r\n\r\n----------\r\n### 修改\r\n1. 打开注册表（win+R ,输入 regedit）\r\n<div style=\"width:50%;margin:0 auto; margin-bottom:25px;\">\r\n    <img src=\"http://cdn.pinsily.site/1507362191750.jpg\" alt=\"\" />\r\n</div>\r\n\r\n\r\n2. 定位到 `HKEY_CURRENT_USER\\Control Panel\\Color`，右侧找到「Windows」双击打开，将 `255 255 255`（默认是白色背景）三组颜色数值改成`202 234 206`（淡绿色），确定保存\r\n<div style=\"width:50%;margin:0 auto; margin-bottom:25px;\">\r\n\r\n    <img src=\"http://cdn.pinsily.site/1507362361466.jpg\" alt=\"\" />\r\n</div>\r\n\r\n\r\n3. 定位到`[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes\\DefaultColors\\Standard]`，一样右侧找到 Window ，将 `ffffff` 修改为 `caeace`，确定保存\r\n<div style=\"width:50%;margin:0 auto; margin-bottom:25px;\">\r\n\r\n    <img src=\"http://cdn.pinsily.site/1507362507195.jpg\" alt=\"\" />\r\n</div>\r\n\r\n\r\n4. 之后重启电脑或重新启动文件资源管理器就可以看到效果了，颜色的话可以很久个人习惯调整，淡绿色护眼，只是听说是这样\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/290641-106.jpg\r\n  [2]: http://cdn.pinsily.site/1507361983517.jpg\r\n  [3]: http://cdn.pinsily.site/1507362037880.jpg\r\n  [4]: http://cdn.pinsily.site/1507362191750.jpg\r\n  [5]: http://cdn.pinsily.site/1507362361466.jpg\r\n  [6]: http://cdn.pinsily.site/1507362507195.jpg', '7.jpg', '2017-12-09 12:22:00', '2019-04-05 01:12:29', 'p', '提笔思念，落笔无言。炉中的香，让它消散吧，桌上的茶，随它渐凉。知道你还在张望，就足够温暖', 130, 0, 0, 'pinsily', 12);
INSERT INTO `article` VALUES (77, 'win10 -- 增加新建 TXT 文档快捷键', '----------\r\n\r\n![][1]\r\n<center>向这污秽不堪丑陋不堪的世界中所相遇的奇迹致谢</center>\r\n\r\n----------\r\n### 效果\r\n右键，按 w,t 之后就会新建一个文档\r\n<div style=\"width:50%;margin:0 auto;margin-bottom:25px;\">\r\n    <img src=\"http://cdn.pinsily.site/1507364711536.jpg\" alt=\"\" />\r\n</div>\r\n\r\n\r\n### 解决\r\n\r\n1. 打开注册表（win+R ,输入 regedit）\r\n<div style=\"width:50%;margin:0 auto;margin-bottom:25px;\">\r\n    <img src=\"http://cdn.pinsily.site/1507362191750.jpg\" alt=\"\" />\r\n</div>\r\n\r\n\r\n2. 定位到 `HKEY_CLASSES_ROOT\\Local Settings\\MuiCache\\63\\AAF68885`（这个路径的 63 不同电脑是不同的，以自己的为准），之后找到右侧的 `@C:\\Windows\\system32\\notepad.exe,-469`，将 `文本文档` 改为 `文本文档(&T)`\r\n<div style=\"width:50%;margin:0 auto;margin-bottom:25px;\">\r\n    <img src=\"http://cdn.pinsily.site/1507365091951.jpg\" alt=\"\" />\r\n</div>\r\n\r\n\r\n3. 之后重启电脑或重新启动文件资源管理器就可以看到效果了，使用 右键，w,t, 就可以新建一个 TXT 文档了\r\n<div style=\"width:50%;margin:0 auto;margin-bottom:25px;\">\r\n    <img src=\"http://cdn.pinsily.site/1507365181105.jpg\" alt=\"\" />\r\n</div>\r\n\r\n4. 也可以按照这种方法增加其他新建的快捷键\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/209278-106.jpg', '8.jpg', '2017-12-09 12:23:00', '2019-03-29 18:41:44', 'p', '右键，按 w,t 之后就会新建一个文档', 108, 0, 0, 'pinsily', 12);
INSERT INTO `article` VALUES (78, 'SSH -- 建立本地GIT仓库和Github的连接', '----------\r\n\r\n![][1]\r\n\r\n<center><p>你再不来，我要下雪了</p></center>\r\n\r\n----------\r\n\r\n\r\nGit是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。\r\n\r\nGithub的SSH配置如下：\r\n\r\n## 设置Git的user name和email\r\n\r\n``` shell\r\n$ git config --global user.name \"pinsily\"\r\n$ git config --global user.email \"13160724868@163.com\"\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n## 生成SSH密钥\r\n\r\nNote ：查看是否已经有了ssh密钥：cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除\r\n\r\n### 生成新的Key：（引号内的内容替换为你自己的邮箱）\r\n\r\n利用 Git 自带的 ssh-keygen\r\n\r\n`ssh-keygen -t rsa -C \"13160724868@163.com\"`\r\n\r\nNote：如果提示没有 ssh-keygen 不存在的话，将 C:\\Soft Ware\\Git\\usr\\bin 添加到环境变量中\r\n\r\n### 输出显示：\r\n\r\n``` shell?linenums\r\nGenerating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):\r\n```\r\n\r\n\r\n### 直接回车，不要修改默认路径。\r\n\r\n``` shell?linenums\r\nEnter passphrase (empty for no passphrase):\r\nEnter same passphrase again:\r\n```\r\n\r\n\r\n这里需设置一个密码短语，在每次远程操作之前会要求输入密码短语！嫌麻烦可以直接回车，不设置。\r\n\r\n### 成功：\r\n``` shell\r\nYour identification has been saved in /Users/your_user_directory/.ssh/id_rsa. \r\nYour public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub. The key fingerprint is: ... ...\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n## 提交公钥：\r\n\r\n 找到.ssh文件夹，用文本编辑器打开“id_rsa.pub”文件，复制内容到剪贴板。\r\n\r\n打开 <https://github.com/settings/ssh> ，点击 Add SSH Key 按钮，粘贴进去保存即可。\r\n\r\n![](http://cdn.pinsily.site/1506130279329.jpg \"\")\r\n\r\n\r\n----------\r\n\r\n\r\n## 测试\r\n``` shell\r\n$ssh git@github.com\r\n\r\nThe authenticity of host ‘github.com (207.97.227.239)’ can’t be established.\r\nRSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\r\nAre you sure you want to continue connecting (yes/no)? yes\r\nWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts.\r\nERROR: Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell access\r\nConnection to github.com closed.\r\n```\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341383-106.jpg', '9.jpg', '2017-12-09 12:26:00', '2019-04-08 16:07:28', 'p', 'Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置', 158, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (79, 'win10 -- SQL server 2012 下载安装', '----------\r\n\r\n\r\n\r\n![][1]\r\n\r\n<center><p>他淡淡地说：“我也想成为伟大的人，可是妈妈喊我回家种田。”</p></center>\r\n\r\n----------\r\n### 下载\r\n官网地址：[https://www.microsoft.com/zh-cn/download/details.aspx?id=29066][2]\r\n\r\n![][3]\r\n\r\n第一个必选，剩下的根据自己的系统位数选择相应的下载\r\n\r\n----------\r\n### 安装\r\n- 将下载好的文件放在同一个临时文件中\r\n- 执行 SQLFULL_x64_CHS_Install.exe 程序，目录中会增加一个新文件夹\r\n\r\n![][4]\r\n\r\n- 进入新增文件夹，执行 SETUP.exe 开始安装\r\n\r\n![][5]\r\n\r\n![][6]\r\n\r\n- 系统配置检查，确保通过，以减少安装过程中的错误\r\n\r\n![][7]\r\n\r\n![][8]\r\n\r\n- 全新安装\r\n\r\n![][9]\r\n\r\n- 产品密匙：使用默认免费的\r\n\r\n![][10]\r\n\r\n- 许可条款\r\n\r\n![][11]\r\n\r\n- 产品更新：允许的话尽量选择\r\n\r\n![][12]\r\n\r\n![][13]\r\n\r\n- 安装程序支持规则：出现防火墙警告，网上说可以跳过……\r\n\r\n![][14]\r\n\r\n- 设置角色：默认\r\n\r\n![][15]\r\n\r\n- 功能选择\r\n> 网上综合了一下，初学的话勾选 数据库引擎服务、客户端工具连接、客户端工具SDK、管理工具、SQL 客户端连接SDK 这些就可以正常了\r\n\r\n![][16]\r\n\r\n- 再检查\r\n\r\n![][17]\r\n\r\n- 实例配置：实例 ID 将与实例根目录拼接成路径\r\n\r\n![][18]\r\n\r\n- 磁盘空间要求：查看是否符合要求\r\n\r\n![][19]\r\n\r\n- 服务器配置：默认\r\n\r\n![][20]\r\n\r\n- 数据库引擎配置\r\n也可以使用混合模式设置账户密码\r\n添加当前用户，因为本人电脑就自己使用\r\n\r\n![][21]\r\n\r\n- 错误报告：默认\r\n\r\n![][22]\r\n\r\n- 接续检查\r\n\r\n![][23]\r\n\r\n- 准备安装：检查无误点击安装\r\n\r\n![][24]\r\n\r\n- 慢慢等待\r\n\r\n![][25]\r\n\r\n- 完成\r\n\r\n![][26]\r\n\r\n\r\n----------\r\n### 总结\r\n使用 SQL server 只是因为课程需要，可能之后也不怎么会接触了，留个参考也好\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/340840-106.jpg\r\n  [2]: https://www.microsoft.com/zh-cn/download/details.aspx?id=29066\r\n  [3]: http://cdn.pinsily.site/1511846788145.jpg\r\n  [4]: http://cdn.pinsily.site/1511853021298.jpg\r\n  [5]: http://cdn.pinsily.site/1511853095527.jpg\r\n  [6]: http://cdn.pinsily.site/1511853112120.jpg\r\n  [7]: http://cdn.pinsily.site/1511853233324.jpg\r\n  [8]: http://cdn.pinsily.site/1511853318708.jpg\r\n  [9]: http://cdn.pinsily.site/1511853461368.jpg\r\n  [10]: http://cdn.pinsily.site/1511853679999.jpg\r\n  [11]: http://cdn.pinsily.site/1511853736031.jpg\r\n  [12]: http://cdn.pinsily.site/1511853817639.jpg\r\n  [13]: http://cdn.pinsily.site/1511853847114.jpg\r\n  [14]: http://cdn.pinsily.site/1511854273225.jpg\r\n  [15]: http://cdn.pinsily.site/1511854516191.jpg\r\n  [16]: http://cdn.pinsily.site/1511856645730.jpg\r\n  [17]: http://cdn.pinsily.site/1511856783087.jpg\r\n  [18]: http://cdn.pinsily.site/1511856953959.jpg\r\n  [19]: http://cdn.pinsily.site/1511857015695.jpg\r\n  [20]: http://cdn.pinsily.site/1511857121288.jpg\r\n  [21]: http://cdn.pinsily.site/1511857217622.jpg\r\n  [22]: http://cdn.pinsily.site/1511857314103.jpg\r\n  [23]: http://cdn.pinsily.site/1511857352804.jpg\r\n  [24]: http://cdn.pinsily.site/1511857410948.jpg\r\n  [25]: http://cdn.pinsily.site/1511857475742.jpg\r\n  [26]: http://cdn.pinsily.site/1511858564377.jpg', '10.jpg', '2017-12-09 12:26:00', '2019-04-04 02:44:48', 'p', '使用 SQL server 只是因为课程需要，可能之后也不怎么会接触了，留个参考也好', 120, 0, 0, 'pinsily', 7);
INSERT INTO `article` VALUES (80, 'python -- py3  安装Pillow(PIL)', '----------\r\n![][1]\r\n\r\n\r\n<center><p>成也容止，败也容止</p></center>\r\n\r\n----------\r\n#### **关于Pillow与PIL**\r\n<br/>\r\nPIL(Python Imaging Library)是Python一个强大方便的图像处理库，名气也比较大。不过只支持到Python 2.7\r\n\r\n- [PIL 官网][2]\r\n\r\n\r\nPillow是PIL的一个派生分支，但如今已经发展成为比PIL本身更具活力的图像处理库。目前最新版本是3.0.0\r\n\r\n- [Pillow github][3]\r\n- [Pillow 官方文档][4]\r\n- [Pillow 中文文档][5]\r\n\r\n\r\n----------\r\n#### **py3 安装**\r\n```\r\npip install Pillow\r\n```\r\n\r\n\r\n----------\r\n#### **简单使用**\r\n```\r\nfrom PIL import Image\r\nim = Image.open(\"bride.jpg\")\r\nim.rotate(45).show()\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341206-106.jpg\r\n  [2]: http://www.pythonware.com/products/pil/\r\n  [3]: https://github.com/python-pillow/Pillow\r\n  [4]: https://pillow.readthedocs.org/en/latest/handbook/index.html\r\n  [5]: http://pillow-cn.readthedocs.org/en/latest/', '10_XuPxJ6f.jpg', '2017-12-09 12:27:00', '2019-04-03 23:27:02', 'p', 'PIL(Python Imaging Library)是Python一个强大方便的图像处理库，名气也比较大。', 160, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (81, 'python -- ﻿pycharm 界面乱码', '----------\r\n![][1]\r\n\r\n<center>在理所当然的地方，过着理所当然的日常生活。</center>\r\n\r\n----------\r\n之前学习 python 的时候因为电脑配置问题打开 IDE 速度太慢，所以就一直在使用 sublime 编辑器，这个过程也算是受益匪浅，没有代码补全功能还是记住了挺多的代码，哈哈~\r\n\r\n想想，现在也是该方便方便学习使用 IDE 了\r\n\r\n可惜，刚开始就出现了界面乱码的问题\r\n\r\n----------\r\n### 乱码问题\r\n\r\n![][2]\r\n\r\n\r\n----------\r\n### 解决\r\n\r\n  开始的时候以为是编码问题，所以就找了相关的设置，发现换了 UTF-8 或是 GBK 都解决不了问题\r\n  \r\n  ![][3]\r\n  \r\n上网了解到，这种情况也可能出现在字体上面，尝试了一下，发现把默认字体 Microsoft YaHei UI Light 换成 Microsoft YaHei Light ，问题就解决了\r\n\r\n![][4]\r\n\r\n\r\n  \r\n\r\n\r\n----------\r\n\r\n继续继续……\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/9302-106.jpg\r\n  [2]: http://cdn.pinsily.site/pycharm_1.png\r\n  [3]: http://cdn.pinsily.site/1506842105773.jpg\r\n  [4]: http://cdn.pinsily.site/1506842263367.jpg', '12.jpg', '2017-09-29 12:30:00', '2019-04-01 18:16:43', 'p', '之前学习 python 的时候因为电脑配置问题打开 IDE 速度太慢，所以就一直在使用 sublime 编辑', 118, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (82, '﻿git -- 上传文件到 github', '---\r\n\r\n![](http://cdn.pinsily.site/288369-106.jpg)\r\n<center>给你一句忠告…世上有些事最好还是让它永远成迷...</center>\r\n\r\n\r\n----------\r\n### 额\r\n只是简单的记录一下经常用的步骤，不详解\r\n\r\n----\r\n### 使用方法\r\n\r\n\r\n1. 使用 ssh 链接上自己的 github\r\n[ssh -- 建立本地GIT仓库和Github的连接](http://blog.pinsily.site/article/78)\r\n\r\n2. 初始化本地 git 库\r\n```\r\n$ git init\r\n```\r\n\r\n3. 添加所有文件到缓冲区\r\n```\r\n$ git add .\r\n```\r\n\r\n4. 提交文件\r\n```\r\n$ git commit -m \'add initialize files\'\r\n```\r\n\r\n5. 关联 github 库\r\n```\r\n$ git remote add origin https://github.com/pinsily/Clown\r\n```\r\n\r\n6. 提交上传\r\n```\r\n$ git push origin master\r\n```', '13.jpg', '2017-12-10 12:32:00', '2019-04-04 00:57:06', 'p', '给你一句忠告…世上有些事最好还是让它永远成迷...', 110, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (83, 'python ﻿ --  pip：Failed building wheel for XXX', '----------\r\n![][1]\r\n<center><p>尽力，尽心</p></center>\r\n\r\n----------\r\n在使用 pip install 安装命令时，结果安装失败，出现了 Failed building wheel for Twisted 的错误，结果发现这类问题是通用的\r\n\r\n![][2]\r\n\r\n----------\r\n### 解决\r\n在网页 [www.lfd.uci.edu/~gohlke/pythonlibs][3] 上找到相应的 XXX，这个网页是一些 window 上的 Python Extension Packages\r\n\r\n![][4]\r\n\r\n找到相应版本的下载好\r\n\r\n![][5]\r\n\r\n进入下载的文件目录使用 pip install 安装即可\r\n\r\n![][6]\r\n\r\n如果版本不对头的话会出现错误，重新下载对应版本\r\n\r\n![][7]\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/356781-106.jpg\r\n  [2]: http://cdn.pinsily.site/1506845651074.jpg\r\n  [3]: www.lfd.uci.edu/~gohlke/pythonlibs\r\n  [4]: http://cdn.pinsily.site/1506846162510.jpg\r\n  [5]: http://cdn.pinsily.site/1506846132235.jpg\r\n  [6]: http://cdn.pinsily.site/1506846105224.jpg\r\n  [7]: http://cdn.pinsily.site/1506846944145.jpg', '14.jpg', '2017-10-03 12:34:00', '2019-04-06 15:27:31', 'p', '在使用 pip install 安装命令时，结果安装失败，出现了 Failed building wheel', 122, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (84, 'python -- 傻瓜函数式编程', '---\r\n### 说明\r\n> 转载，[github.com/justinyhuang][1]\r\n\r\n\r\n\r\n2006年6月19日，星期一\r\n\r\n### 开篇 \r\n我们这些码农做事都是很拖拉的。每天例行报到后，先来点咖啡，看看邮件还有RSS订阅的文章。然后翻翻新闻还有那些技术网站上的更新，再过一遍编程论坛口水区里那些无聊的论战。最后从头把这些再看一次以免错过什么精彩的内容。然后就可以吃午饭了。饭饱过后，回来盯着IDE发一会呆，再看看邮箱，再去搞杯咖啡。光阴似箭，可以回家了……\r\n\r\n（在被众人鄙视之前）我唯一想说的是，在这些拖拉的日子里总会时不时读到一些不明觉厉的文章。如果没有打开不应该打开的网站，每隔几天你都可以看到至少一篇这样的东西。它们的共性：难懂，耗时，于是这些文章就慢慢的堆积成山了。很快你就会发现自己已经累积了一堆的收藏链接还有数不清的PDF文件，此时你只希望隐入一个杳无人烟的深山老林里什么也不做，用一年半载好好的消化这些私藏宝贝。当然，我是说最好每天还是能有人来给送吃的顺带帮忙打扫卫生倒垃圾，哇哈哈。\r\n\r\n我不知道你都收藏了些什么，我的阅读清单里面相当大部分都是函数式编程相关的东东：基本上是最难啃的。这些文章充斥着无比枯燥的教科书语言，我想就连那些在华尔街浸淫10年以上的大牛都无法搞懂这些函数式编程（简称FP）文章到底在说什么。你可以去花旗集团或者德意志银行找个项目经理来问问1：你们为什么要选JMS而不用Erlang？答案基本上是：我认为这个学术用的语言还无法胜任实际应用。可是，现有的一些系统不仅非常复杂还需要满足十分严苛的需求，它们就都是用函数式编程的方法来实现的。这，就说不过去了。\r\n关于FP的文章确实比较难懂，但我不认为一定要搞得那么晦涩。有一些历史原因造成了这种知识断层，可是FP概念本身并不难理解。我希望这篇文章可以成为一个“FP入门指南”，帮助你从指令式编程走向函数式编程。先来点咖啡，然后继续读下去。很快你对FP的理解就会让同事们刮目相看了。\r\n\r\n什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？倘若它真的像那些鼓吹FP的人说的那么好，为什么实际应用中那么少见？为什么只有那些在读博士的家伙想要用它？而最重要的是，它母亲的怎么就那么难学？那些所谓的closure、continuation，currying，lazy evaluation还有no side effects都是什么东东（译者：本着保留专用术语的原则，此处及下文类似情形均不译）？如果没有那些大学教授的帮忙怎样把它应用到实际工程里去？为什么它和我们熟悉的万能而神圣的指令式编程那么的不一样？\r\n\r\n我们很快就会解开这些谜团。刚才我说过实际工程和学术界之间的知识断层是有其历史原因的，那么就先让我来解释一下这个问题。答案，就在接下来的一次公园漫步中：\r\n\r\n###公园漫步 \r\n时间机器启动……我们来到公元前380年，也就是2000多年前的雅典城外。这是一个阳光明媚的久违的春天，柏拉图和一个帅气的小男仆走在一片橄榄树荫下。他们正准备前往一个学院。天气很好，吃得很饱，渐渐的，两人的谈话转向了哲学。\r\n\r\n“你看那两个学生，哪一个更高一些？”，柏拉图小心的选择用字，以便让这个问题更好的引导眼前的这个小男孩。\r\n小男仆望向水池旁边的两个男生，“他们差不多一样高。”。\r\n“‘差不多一样高’是什么意思？”柏拉图问。\r\n“嗯……从这里看来他们是一样高的，但是如果走近一点我肯定能看出差别来。”\r\n柏拉图笑了。他知道这个小孩已经朝他引导的方向走了。“这么说来你的意思是世界上没有什么东西是完全相同的咯？”\r\n思考了一会，小男孩回答：“是的。万物之间都至少有一丁点差别，哪怕我们无法分辨出来。”\r\n说到点子上了！“那你说，如果世界上没有什么东西是完全相等的，你怎么理解‘完全相等’这个概念？”\r\n小男仆看起来很困惑。“这我就不知道了。”\r\n\r\n这是人类第一次试图了解数学的本质。柏拉图认为我们所在的世界中，万事万物都是完美模型的一个近似。他同时意识到虽然我们不能感受到完美的模型，但这丝毫不会阻止我们了解完美模型的概念。柏拉图进而得出结论：完美的数学模型只存在于另外一个世界，而因为某种原因我们却可以通过联系着这两个世界的一个纽带来认识这些模型。一个简单的例子就是完美的圆形。没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。\r\n\r\n如此说来，什么是数学呢？为什么可以用数学法则来描述我们的这个宇宙？我们所处的这个世界中万事万物都可以用数学来描述吗？2 数理哲学是一门很复杂的学科。它和其他多数哲学一样，更着重于提出问题而不是给出答案。数学就像拼图一样，很多结论都是这样推导出来的：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。如果你想做的话，可以用形式系统描述俄罗斯方块这个游戏。而事实上，俄罗斯方块这个游戏的实现，只要它正确运行，就是一个形式系统。只不过它以一种不常见的形式表现出来罢了。\r\n\r\n如果半人马阿尔法上有文明存在的话，那里的生物可能无法解读我们的俄罗斯方块形式系统甚至是简单的圆形的形式系统，因为它们感知世界的唯一器官可能只有鼻子（译者：偶的妈你咋知道？）也许它们是无法得知俄罗斯方块的形式系统了，但是它们很有可能知道圆形。它们的圆形我们可能没法解读，因为我们的鼻子没有它们那么灵敏（译者：那狗可以么？）可是只要越过形式系统的表示方式（比如通过使用“超级鼻子”之类的工具来感知这些用味道表示的形式系统，然后使用标准的解码技术把它们翻译成人类能理解的语言），那么任何有足够智力的文明都可以理解这些形式系统的本质。\r\n\r\n有意思的是，哪怕宇宙中完全不存在任何文明，类似俄罗斯方块还有圆形这样的形式系统依旧是成立的：只不过没有智慧生物去发现它们而已。这个时候如果忽然一个文明诞生了，那么这些具有智慧的生物就很有可能发现各种各样的形式系统，并且用它们发现的系统去描述各种宇宙法则。不过它们可能不会发现俄罗斯方块这样的形式系统，因为在它们的世界里没有俄罗斯方块这种东西嘛。有很多像俄罗斯方块这样的形式系统是与客观世界无关的，比如说自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。\r\n\r\n### 历史回眸\r\n再次启动时间机……这次到达的是20世纪30年代，离今天近了很多。无论新旧大陆，经济大萧条都造成了巨大的破坏。社会各阶层几乎每一个家庭都深受其害。只有极其少数的几个地方能让人们免于遭受穷困之苦。几乎没有人能够幸运的在这些避难所里度过危机，注意，我说的是几乎没有，还真的有这么些幸运儿，比如说当时普林斯顿大学的数学家们。\r\n\r\n新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫阿隆佐·邱奇(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有艾伦·图灵、约翰·冯·诺伊曼、库尔特·哥德尔。\r\n\r\n这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？\r\n\r\n在与这些人的合作下，阿隆佐设计了一个名为lambda演算的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（λ），这种系统因此得名4。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。\r\n\r\n除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。\r\n\r\n如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。\r\n\r\n战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。\r\n\r\n到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！\r\n\r\n函数式编程\r\n\r\n函数式编程是阿隆佐思想的在现实世界中的实现。不过不是全部的lambda演算思想都可以运用到实际中，因lambda演算在设计的时候就不是为了在各种现实世界中的限制下工作的。所以，就像面向对象的编程思想一样，函数式编程只是一系列想法，而不是一套严苛的规定。有很多支持函数式编程的程序语言，它们之间的具体设计都不完全一样。在这里我将用Java写的例子介绍那些被广泛应用的函数式编程思想（没错，如果你是受虐狂你可以用Java写出函数式程序）。在下面的章节中我会在Java语言的基础上，做一些修改让它变成实际可用的函数式编程语言。那么现在就开始吧。\r\n\r\nLambda演算在最初设计的时候就是为了研究计算相关的问题。所以函数式编程主要解决的也是计算问题，而出乎意料的是，是用函数来解决的！（译者：请理解原作者的苦心，我想他是希望加入一点调皮的风格以免读者在中途睡着或是转台……）。函数就是函数式编程中的基础元素，可以完成几乎所有的操作，哪怕最简单的计算，也是用函数完成的。我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式（这样我们就不用把所有的代码都写在同一行里了）。所以我们这里所说的‘变量’是不能被修改的。所有的变量只能被赋一次初值。在Java中就意味着每一个变量都将被声明为final（如果你用C++，就是const）。在FP中，没有非final的变量。\r\n```java\r\nfinal int i = 5;\r\nfinal int j = i + 3;\r\n```\r\n既然FP中所有的变量都是final的，可以引出两个规定：一是变量前面就没有必要再加上final这个关键字了，二是变量就不能再叫做‘变量’了……于是现在开始对Java做两个改动：所有Java中声明的变量默认为final，而且我们把所谓的‘变量’称为‘符号’。\r\n\r\n到现在可能会有人有疑问：这个新创造出来的语言可以用来写什么有用的复杂一些的程序吗？毕竟，如果每个符号的值都是不能修改的，那么我们就什么东西都不能改变了！别紧张，这样的说法不完全正确。阿隆佐在设计lambda演算的时候他并不想要保留状态的值以便稍后修改这些值。他更关心的是基于数据之上的操作（也就是更容易理解的“计算”）。而且，lambda演算和图灵机已经被证明了是具有同样能力的系统，因此指令式编程能做到的函数式编程也同样可以做到。那么，怎样才能做到呢？\r\n\r\n事实上函数式程序是可以保存状态的，只不过它们用的不是变量，而是函数。状态保存在函数的参数中，也就是说在栈上。如果你需要保存一个状态一段时间并且时不时的修改它，那么你可以编写一个递归函数。举个例子，试着写一个函数，用来反转一个Java的字符串。记住咯，这个程序里的变量都是默认为final的5。\r\n\r\n``` scala\r\nString reverse(String arg) {\r\n    if(arg.length == 0) {\r\n        return arg;\r\n    }\r\n    else {\r\n        return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1);\r\n    }\r\n}\r\n```\r\n\r\n\r\n这个方程运行起来会相对慢一些，因为它重复调用自己。同时它也会大量的消耗内存，因为它会不断的分配创建内存对象。无论如何，它是用函数式编程思想写出来的。这时候可能有人要问了，为什么要用这种奇怪的方式编写程序呢？嘿，我正准备告诉你。\r\n\r\n### FP之优点 \r\n你大概已经在想：上面这种怪胎函数怎么也不合理嘛。在我刚开始学习FP的时候我也这样想的。不过后来我知道我是错的。使用这种方式编程有很多好处。其中一些是主观的。比如说有人认为函数式程序更容易理解。这个我就不说了，哪怕街上随便找个小孩都知道‘容易理解’是多么主观的事情。幸运的是，客观方面的好处还有很多。\r\n\r\n#### 单元测试 \r\n因为FP中的每个符号都是final的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。\r\n\r\n这正是单元测试工程师梦寐以求的啊。现在测试程序中的函数时只需要关注它的参数就可以了。完全不需要担心函数调用的顺序，也不用费心设置外部某些状态值。唯一需要做的就是传递一些可以代表边界条件的参数给这些函数。相对于指令式编程，如果FP程序中的每一个函数都能通过单元测试，那么我们对这个软件的质量必将信心百倍。反观Java或者C++，仅仅检查函数的返回值是不够的：代码可能修改外部状态值，因此我们还需要验证这些外部的状态值的正确性。在FP语言中呢，就完全不需要。\r\n\r\n#### 调试查错 \r\n如果一段FP程序没有按照预期设计那样运行，调试的工作几乎不费吹灰之力。这些错误是百分之一百可以重现的，因为FP程序中的错误不依赖于之前运行过的不相关的代码。而在一个指令式程序中，一个bug可能有时能重现而有些时候又不能。因为这些函数的运行依赖于某些外部状态， 而这些外部状态又需要由某些与这个bug完全不相关的代码通过某个特别的执行流程才能修改。在FP中这种情况完全不存在：如果一个函数的返回值出错了，它一直都会出错，无论你之前运行了什么代码。\r\n一旦问题可以重现，解决它就变得非常简单，几乎就是一段愉悦的旅程。中断程序的运行，检查一下栈，就可以看到每一个函数调用时使用的每一个参数，这一点和指令式代码一样。不同的是指令式程序中这些数据还不足够，因为函数的运行还可能依赖于成员变量，全局变量，还有其他类的状态（而这些状态又依赖于类似的变量）。FP中的函数只依赖于传给它的参数，而这些参数就在眼前！还有，对指令式程序中函数返回值的检查并不能保证这个函数是正确运行的。还要逐一检查若干作用域以外的对象以确保这个函数没有对这些牵连的对象做出什么越轨的行为（译者：好吧，翻译到这里我自己已经有点激动了）。对于一个FP程序，你要做的仅仅是看一下函数的返回值。\r\n把栈上的数据过一遍就可以得知有哪些参数传给了什么函数，这些函数又返回了什么值。当一个返回值看起来不对头的那一刻，跳进这个函数看看里面发生了什么。一直重复跟进下去就可以找到bug的源头！\r\n\r\n#### 并发执行 \r\n不需要任何改动，所有FP程序都是可以并发执行的。由于根本不需要采用锁机制，因此完全不需要担心死锁或是并发竞争的发生。在FP程序中没有哪个线程可以修改任何数据，更不用说多线程之间了。这使得我们可以轻松的添加线程，至于那些祸害并发程序的老问题，想都不用想！\r\n既然是这样，为什么没有人在那些高度并行的那些应用程序中采用FP编程呢？事实上，这样的例子并不少见。爱立信开发了一种FP语言，名叫Erlang，并应用在他们的电信交换机上，而这些交换机不仅容错度高而且拓展性强。许多人看到了Erlang的这些优势也纷纷开始使用这一语言。在这里提到的电信交换控制系统远远要比华尔街上使用的系统具有更好的扩展性也更可靠。事实上，用Erlang搭建的系统并不具备可扩展性和可靠性，而Java可以提供这些特性。Erlang只是像岩石一样结实不容易出错而已。\r\nFP关于并行的优势不仅于此。就算某个FP程序本身只是单线程的，编译器也可以将其优化成可以在多CPU上运行的并发程序。以下面的程序为例：\r\n\r\n``` scala\r\nString s1 = somewhatLongOperation1();\r\nString s2 = somewhatLongOperation2();\r\nString s3 = concatenate(s1, s2);\r\n```\r\n\r\n如果是函数式程序，编译器就可以对代码进行分析，然后可能分析出生成字符串s1和s2的两个函数可能会比较耗时，进而安排它们并行运行。这在指令式编程中是无法做到的，因为每一个函数都有可能修改其外部状态，然后接下来的函数又可能依赖于这些状态的值。在函数式编程中，自动分析代码并找到适合并行执行的函数十分简单，和分析C的内联函数没什么两样。从这个角度来说用FP风格编写的程序是“永不过时”的（虽然我一般不喜欢说大话空话，不过这次就算个例外吧）。硬件厂商已经没办法让CPU运行得再快了。他们只能靠增加CPU核的数量然后用并行来提高运算的速度。这些厂商故意忽略一个事实：只有可以并行的软件才能让你花大价钱买来的这些硬件物有所值。指令式的软件中只有很小一部分能做到跨核运行，而所有的函数式软件都能实现这一目标，因为FP的程序从一开始就是可以并行运行的。\r\n\r\n#### 热部署 \r\n在Windows早期，如果要更新系统那可是要重启电脑的，而且还要重启很多次。哪怕只是安装一个新版本的播放器。到了XP的时代这种情况得到比较大的改善，尽管还是不理想（我工作的时候用的就是Windows，就在现在，我的系统托盘上就有个讨厌的图标，我不重启机子就不消失）。这一方面Unix好一些，曾经。只需要暂停一些相关的部件而不是整个操作系统，就可以安装更新了。虽然是要好一些了，对很多服务器应用来说这也还是不能接受的。电信系统要求的是100%的在线率，如果一个救急电话因为系统升级而无法拨通，成千上万的人就会因此丧命。同样的，华尔街的那些公司怎么也不能说要安装软件而在整个周末停止他们系统的服务。\r\n\r\n最理想的情况是更新相关的代码而不用暂停系统的其他部件。对指令性程序来说是不可能的。想想看，试着在系统运行时卸载掉一个Java的类然后再载入这个类的新的实现，这样做的话系统中所有该类的实例都会立刻不能运行，因为该类的相关状态已经丢失了。这种情况下可能需绞尽脑汁设计复杂的版本控制代码，需要将所有这种类正在运行的实例序列化，逐一销毁它们，然后创建新类的实例，将现有数据也序列化后装载到这些新的实例中，最后希望负责装载的程序可以正确的把这些数据移植到新实例中并正常的工作。这种事很麻烦，每次有新的改动都需要手工编写装载程序来完成更新，而且这些装载程序还要很小心，以免破坏了现有对象之间的联系。理论上是没问题，可是实际上完全行不通。\r\nFP的程序中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。其它的事情有FP的语言工具自动完成！如果还有人认为这只存在于科幻小说中，他需要再想想：多年来Erlang工程师已经使用这种技术对它们的系统进行升级而完全不用暂停运行了。\r\n\r\n#### 机器辅助优化及证明 \r\nFP语言有一个特性很有意思，那就是它们是可以用数学方法来分析的。FP语言本身就是形式系统的实现，只要是能在纸上写出来的数学运算就可以用这种语言表述出来。于是只要能够用数学方法证明两段代码是一致的，编译器就可以把某段代码解析成在数学上等同的但效率又更高的另外一段代码7。 关系数据库已经用这种方法进行优化很多年了。没有理由在常规的软件行业就不能应用这种技术。 另外，还可以用这种方法来证明代码的正确性，甚至可以设计出能够自动分析代码并为单元测试自动生成边缘测试用例的工具出来！对于那些对缺陷零容忍的系统来说，这一功能简直就是无价之宝。例如心脏起搏器，例如飞行管控系统，这几乎就是必须满足的需求。哪怕你正在开发的程序不是为了完成什么重要核心任务，这些工具也可以帮助你写出更健壮的程序，直接甩竞争对手n条大街。\r\n\r\n### 高阶函数 \r\n我还记得在了解到FP以上的各种好处后想到：“这些优势都很吸引人，可是，如果必须非要用这种所有变量都是final的蹩脚语言，估计还是不怎么实用吧”。其实这样的想法是不对的。对于Java这样的指令式语言来说，如果所有的变量都是必须是final的，那么确实很束手束脚。然而对函数式语言来说，情况就不一样了。函数式语言提供了一种特别的抽象工具，这种工具将帮助使用者编写FP代码，让他们甚至都没想到要修改变量的值。高阶函数就是这种工具之一。\r\nFP语言中的函数有别于Java或是C。可以说这种函数是一个全集：Java函数可以做到的它都能做，同时它还有更多的能力。首先，像在C里写程序那样创建一个函数：\r\n\r\n``` java\r\nint add(int i, int j) {\r\n    return i + j;\r\n}\r\n```\r\n\r\n\r\n看起来和C程序没什么区别，但是很快你就可以看出区别来。接下来我们扩展Java的编译器以便支持这种代码，也就是说，当我们写下以上的程序编译器会把它转化成下面的Java程序（别忘了，所有的变量都是final的）：\r\n\r\n``` java\r\nclass add_function_t {\r\n    int add(int i, int j) {\r\n        return i + j;\r\n    }\r\n}\r\n\r\n\r\n\r\nadd_function_t add = new add_function_t();\r\n\r\n```\r\n在这里，符号add并不是一个函数，它是只有一个函数作为其成员的简单的类。这样做有很多好处，可以在程序中把add当成参数传给其他的函数，也可以把 add 赋给另外一个符号，还可以在运行时创建add_function_t 的实例然后在不再需要这些实例的时候由系统回收机制处理掉。这样做使得函数成为和 integer 或是 string 这样的第一类对象。对其他函数进行操作（比如说把这些函数当成参数）的函数，就是所谓的高阶函数。别让这个看似高深的名字吓倒你（译者：好死不死起个这个名字，初一看还准备搬出已经尘封的高数教材……），它和Java中操作其他类（也就是把一个类实例传给另外的类）的类没有什么区别。可以称这样的类为“高阶类”，但是没人会在意，因为Java圈里就没有什么很强的学术社团。（译者：这是高级黑吗？）\r\n\r\n那么什么时候该用高阶函数，又怎样用呢？我很高兴有人问这个问题。设想一下，你写了一大堆程序而不考虑什么类结构设计，然后发现有一部分代码重复了几次，于是你就会把这部分代码独立出来作为一个函数以便多次调用（所幸学校里至少会教这个）。如果你发现这个函数里有一部分逻辑需要在不同的情况下实现不同的行为，那么你可以把这部分逻辑独立出来作为一个高阶函数。搞晕了？下面来看看我工作中的一个真实的例子。\r\n\r\n假设有一段Java的客户端程序用来接收消息，用各种方式对消息做转换，然后发给一个服务器。\r\n\r\n``` java\r\nclass MessageHandler {\r\n    void handleMessage(Message msg) {\r\n        // ...\r\n        msg.setClientCode(\"ABCD_123\");\r\n        // ...\r\n       \r\n        sendMessage(msg);\r\n    }\r\n   \r\n    // ...\r\n}\r\n```\r\n再进一步假设，整个系统改变了，现在需要发给两个服务器而不再是一个了。系统其他部分都不变，唯独客户端的代码需要改变：额外的那个服务器需要用另外一种格式发送消息。应该如何处理这种情况呢？我们可以先检查一下消息要发送到哪里，然后选择相应的格式把这个消息发出去：\r\n\r\n``` java\r\nclass MessageHandler {\r\n    void handleMessage(Message msg) {\r\n        // ...\r\n        if(msg.getDestination().equals(\"server1\") {\r\n            msg.setClientCode(\"ABCD_123\");\r\n        } else {\r\n            msg.setClientCode(\"123_ABC\");\r\n        }\r\n        // ...\r\n       \r\n        sendMessage(msg);\r\n    }\r\n   \r\n    // ...\r\n}\r\n```\r\n\r\n\r\n可是这样的实现是不具备扩展性的。如果将来需要增加更多的服务器，上面函数的大小将呈线性增长，使得维护这个函数最终变成一场噩梦。面向对象的编程方法告诉我们，可以把MessageHandler变成一个基类，然后将针对不同格式的消息编写相应的子类。\r\n\r\n``` scala\r\nabstract class MessageHandler {\r\n    void handleMessage(Message msg) {\r\n        // ...\r\n        msg.setClientCode(getClientCode());\r\n        // ...\r\n       \r\n        sendMessage(msg);\r\n    }\r\n   \r\n    abstract String getClientCode();\r\n   \r\n    // ...\r\n}\r\n\r\nclass MessageHandlerOne extends MessageHandler {\r\n    String getClientCode() {\r\n        return \"ABCD_123\";\r\n    }\r\n}\r\n\r\nclass MessageHandlerTwo extends MessageHandler {\r\n    String getClientCode() {\r\n        return \"123_ABCD\";\r\n    }\r\n}\r\n```\r\n\r\n\r\n这样一来就可以为每一个接收消息的服务器生成一个相应的类对象，添加服务器就变得更加容易维护了。可是，这一个简单的改动引出了很多的代码。仅仅是为了支持不同的客户端行为代码，就要定义两种新的类型！现在来试试用我们刚才改造的语言来做同样的事情，注意，这种语言支持高阶函数：\r\n\r\n``` scala\r\nclass MessageHandler {\r\n    void handleMessage(Message msg, Function getClientCode) {\r\n        // ...\r\n        Message msg1 = msg.setClientCode(getClientCode());\r\n        // ...\r\n       \r\n        sendMessage(msg1);\r\n    }\r\n   \r\n    // ...\r\n}\r\n\r\nString getClientCodeOne() {\r\n    return \"ABCD_123\";\r\n}\r\n\r\nString getClientCodeTwo() {\r\n    return \"123_ABCD\";\r\n}\r\n\r\nMessageHandler handler = new MessageHandler();\r\nhandler.handleMessage(someMsg, getClientCodeOne);\r\n```\r\n\r\n\r\n在上面的程序里，我们没有创建任何新的类型或是多层类的结构。仅仅是把相应的函数作为参数进行传递，就做到了和用面向对象编程一样的事情，而且还有额外的好处：一是不再受限于多层类的结构。这样做可以做运行时传递新的函数，可以在任何时候改变这些函数，而且这些改变不仅更加精准而且触碰的代码更少。这种情况下编译器其实就是在替我们编写面向对象的“粘合”代码（译者：又称胶水代码，粘接代码）！除此之外我们还可以享用FP编程的其他所有优势。函数式编程能提供的抽象服务还远不止于此。高阶函数只不过是个开始。\r\n\r\n\r\n----------\r\n\r\n\r\n### Currying \r\n我遇见的大多数码农都读过“四人帮”的那本《设计模式》。任何稍有自尊心的码农都会说这本书和语言无关，因此无论你用什么编程语言，当中提到的那些模式大体上适用于所有软件工程。听起来很厉害，然而事实却不是这样。\r\n函数式语言的表达能力很强。用这种语言编程的时候基本不需要设计模式，因为这种语言层次已经足够高，使得使用者可以以概念编程，从而完全不需要设计模式了。以适配器模式为例（有人知道这个模式和外观模式有什么区别吗？怎么觉得有人为了出版合同的要求而硬生生凑页数？）（译者：您不愧是高级黑啊）。对于一个支持currying技术的语言来说，这个模式就是多余的。\r\n在Java中最有名的适配器模式就是在其“默认”抽象单元中的应用：类。在函数式语言中这种模式其实就是函数。在这个模式中，一个接口被转换成另外一个接口，让不同的用户代码调用。接下来就有一个适配器模式的例子：\r\n\r\n``` scala\r\nint pow(int i, int j);\r\nint square(int i)\r\n{\r\n    return pow(i, 2);\r\n}\r\n```\r\n\r\n\r\n上面的代码中square函数计算一个整数的平方，这个函数的接口被转换成计算一个整数的任意整数次幂。在学术圈里这种简单的技术就被叫做currying（因为逻辑学家哈斯凯尔·加里用其数学技巧将这种技术描述出来，于是就以他的名字来命名了）。在一个FP语言中函数（而不是类）被作为参数进行传递，currying常常用于转化一个函数的接口以便于其他代码调用。函数的接口就是它的参数，于是currying通常用于减少函数参数的数量（见前例）。\r\n函数式语言生来就支持这一技术，于是没有必要为某个函数手工创建另外一个函数去包装并转换它的接口，这些函数式语言已经为你做好了。我们继续拓展Java来支持这一功能。\r\n\r\n``` scala\r\nsquare = int pow(int i, 2);\r\n```\r\n\r\n\r\n上面的语句实现了一个平方计算函数，它只需要一个参数。它会继而调用pow函数并且把第二个参数置为2。编译过后将生成以下Java代码：\r\n\r\n``` scala\r\nclass square_function_t {\r\n    int square(int i) {\r\n        return pow(i, 2);\r\n    }\r\n}\r\n\r\nsquare_function_t square = new square_function_t();\r\n```\r\n\r\n从上面的例子可以看到，很简单的，函数pow的封装函数就创建出来了。在FP语言中currying就这么简单：一种可以快速且简单的实现函数封装的捷径。我们可以更专注于自己的设计，编译器则会为你编写正确的代码！什么时候使用currying呢？很简单，当你想要用适配器模式（或是封装函数）的时候，就是用currying的时候。\r\n\r\n\r\n----------\r\n\r\n\r\n### 惰性求值 \r\n惰性求值（或是延迟求值）是一种有趣的技术，而当我们投入函数式编程的怀抱后这种技术就有了得以实现的可能。前面介绍并发执行的时候已经提到过如下代码：\r\n\r\n``` scala\r\nString s1 = somewhatLongOperation1();\r\nString s2 = somewhatLongOperation2();\r\nString s3 = concatenate(s1, s2);\r\n```\r\n\r\n\r\n在指令式语言中以上代码执行的顺序是显而易见的。由于每个函数都有可能改动或者依赖于其外部的状态，因此必须顺序执行。先是计算somewhatLongOperation1，然后到somewhatLongOperation2，最后执行concatenate。函数式语言就不一样了。\r\n在前面讨论过，somewhatLongOperation1 和somewhatLongOperation2是可以并发执行的，因为函数式语言保证了一点：没有函数会影响或者依赖于全局状态。可是万一我们不想要这两个函数并发执行呢？这种情况下是不是也还是要顺序执行这些函数？答案是否定的。只有到了执行需要s1、s2作为参数的函数的时候，才真正需要执行这两个函数。于是在concatenate这个函数没有执行之前，都没有需要去执行这两个函数：这些函数的执行可以一直推迟到concatenate()中需要用到s1和s2的时候。假如把concatenate换成另外一个函数，这个函数中有条件判断语句而且实际上只会需要两个参数中的其中一个，那么就完全没有必要执行计算另外一个参数的函数了！Haskell语言就是一个支持惰性求值的例子。Haskell不能保证任何语句会顺序执行（甚至完全不会执行到），因为Haskell的代码只有在需要的时候才会被执行到。\r\n除了这些优点，惰性求值也有缺点。这里介绍了它的优点，我们将在下一章节介绍这些缺点以及如何克服它们。\r\n\r\n#### 代码优化 \r\n惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序：抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至是减少错误。在此基础上优化是不会破坏代码正常运行的。严格使用形式系统的基本元素进行编程带来的最大的好处，是可以用数学方法分析处理代码，因为这样的程序是完全符合数学法则的。\r\n\r\n#### 抽象化控制结构 \r\n惰性求值技术提供了更高阶的抽象能力，这提供了实现程序设计独特的方法。比如说下面的控制结构：\r\n\r\n``` scala\r\nunless(stock.isEuropean()) {\r\n    sendToSEC(stock);\r\n}\r\n```\r\n\r\n\r\n程序中只有在stock为European的时候才执行sendToSEC。如何实现例子中的unless？如果没有惰性求值就需要求助于某种形式的宏（译者：用if不行么？），不过在像Haskell这样的语言中就不需要那么麻烦了。直接实现一个unless函数就可以！\r\n\r\n``` scala\r\nvoid unless(boolean condition, List code) {\r\n    if(!condition)\r\n        code;\r\n}\r\n```\r\n\r\n\r\n请注意，如果condition值为真，那就不会计算code。在其他严格语言（见严格求值）中这种行为是做不到的，因为在进入unless这个函数之前，作为参数的code已经被计算过了。 ####无穷数据结构 惰性求值技术允许定义无穷数据结构，这要在严格语言中实现将非常复杂。例如一个储存Fibonacci数列数字的列表。很明显这样一个列表是无法在有限的时间内计算出这个无穷的数列并存储在内存中的。在像Java这样的严格语言中，可以定义一个Fibonacci函数，返回这个序列中的某个数。而在Haskell或是类似的语言中，可以把这个函数进一步抽象化并定义一个Fibonacci数列的无穷列表结构。由于语言本身支持惰性求值，这个列表中只有真正会被用到的数才会被计算出来。这让我们可以把很多问题抽象化，然后在更高的层面上解决它们（比如可以在一个列表处理函数中处理无穷多数据的列表）。 ####不足之处 俗话说天下没有免费的午餐™。惰性求值当然也有其缺点。其中最大的一个就是，嗯，惰性。现实世界中很多问题还是需要严格求值的。比如说下面的例子：\r\n\r\n``` java\r\nSystem.out.println(\"Please enter your name: \");\r\nSystem.in.readLine();\r\n```\r\n\r\n\r\n在惰性语言中没人能保证第一行会中第二行之前执行！这也就意味着我们不能处理IO，不能调用系统函数做任何有用的事情（这些函数需要按照顺序执行，因为它们依赖于外部状态），也就是说不能和外界交互了！如果在代码中引入支持顺序执行的代码原语，那么我们就失去了用数学方式分析处理代码的优势（而这也意味着失去了函数式编程的所有优势）。幸运的是我们还不算一无所有。数学家们研究了不同的方法用以保证代码按一定的顺序执行（in a functional setting?）。这一来我们就可以同时利用到函数式和指令式编程的优点了！这些方法有continuations，monads以及uniqueness typing。这篇文章仅仅介绍了continuations，以后再讨论monads和uniqueness typing。有意思的是呢，coutinuations处理强制代码以特定顺序执行之外还有其他很多出处，这些我们在后面也会提及。\r\n\r\n\r\n----------\r\n\r\n\r\n### Continuation \r\ncontinuation对于编程，就像是达芬奇密码对于人类历史一样：它揭开了人类有史以来最大的谜团。好吧，也许没有那么夸张，不过它们的影响至少和当年发现负数有平方根不相上下。\r\n\r\n我们对函数的理解只有一半是正确的，因为这样的理解基于一个错误的假设：函数一定要把其返回值返回给调用者。按照这样的理解，continuation就是更加广义的函数。这里的函数不一定要把返回值传回给调用者，相反，它可以把返回值传给程序中的任意代码。continuation就是一种特别的参数，把这种参数传到函数中，函数就能够根据continuation将返回值传递到程序中的某段代码中。说得很高深，实际上没那么复杂。直接来看看下面的例子好了：\r\n\r\n``` scala\r\nint i = add(5, 10);\r\nint j = square(i);\r\n```\r\n\r\n\r\nadd这个函数将返回15然后这个值会赋给i，这也是add被调用的地方。接下来i的值又会被用于调用square。请注意支持惰性求值的编译器是不能打乱这段代码执行顺序的，因为第二个函数的执行依赖于第一个函数成功执行并返回结果。这段代码可以用Continuation Pass Style（CPS）技术重写，这样一来add的返回值就不是传给其调用者，而是直接传到square里去了。\r\n\r\n``` scala\r\nint j = add(5, 10, square);\r\n```\r\n\r\n\r\n在上例中，add多了一个参数：一个函数，add必须在完成自己的计算后，调用这个函数并把结果传给它。这时square就是add的一个continuation。上面两段程序中j的值都是225。\r\n\r\n这样，我们学习到了强制惰性语言顺序执行两个表达式的第一个技巧。再来看看下面IO程序（是不是有点眼熟？）：\r\n\r\n``` java\r\nSystem.out.println(\"Please enter your name: \");\r\nSystem.in.readLine();\r\n```\r\n\r\n\r\n这两行代码彼此之间没有依赖关系，因此编译器可以随意的重新安排它们的执行顺序。可是只要用CPS重写它，编译器就必须顺序执行了，因为重写后的代码存在依赖关系了。\r\n\r\n``` java\r\nSystem.out.println(\"Please enter your name: \", System.in.readLine);\r\n```\r\n\r\n\r\n这段新的代码中println需要结合其计算结果调用readLine，然后再返回readLine的返回值。这使得两个函数得以保证按顺序执行而且readLine总被执行（这是由于整个运算需要它的返回值作为最终结果）。Java的println是没有返回值的，但是如果它可以返回一个能被readnLine接受的抽象值，问题就解决了！（译者：别忘了，这里作者一开始就在Java的基础上修改搭建自己的语言）当然，如果一直把函数按照这种方法串下去，代码很快就变得不可读了，可是没有人要求你一定要这样做。可以通过在语言中添加语法糖的方式来解决这个问题，这样程序员只要按照顺序写代码，编译器负责自动把它们串起来就好了。于是就可以任意安排代码的执行顺序而不用担心会失去FP带来的好处了（包括可以用数学方法来分析我们的程序）！如果到这里还有人感到困惑，可以这样理解，函数只是有唯一成员的类的实例而已。试着重写上面两行程序，让println和readLine编程这种类的实例，所有问题就都搞清楚了。\r\n到这里本章基本可以结束了，而我们仅仅了解到continuation的一点皮毛，对它的用途也知之甚少。我们可以用CPS完成整个程序，程序里所有的函数都有一个额外的continuation作为参数接受其他函数的返回值。还可以把任何程序转换为CPS的，需要做的只是把当中的函数看作是特殊的continuation（总是将返回值传给调用者的continuation）就可以了，简单到完全可以由工具自动完成（史上很多编译器就是这样做的）。\r\n\r\n一旦将程序转为CPS的风格，有些事情就变得显而易见了：每一条指令都会有一些continuation，都会将它的计算结果传给某一个函数并调用它，在一个普通的程序中这个函数就是该指令被调用并且返回的地方。随便找个之前提到过的代码，比如说add(5,10)好了。如果add属于一个用CPS风格写出的程序，add的continuation很明显就是当它执行结束后要调用的那个函数。可是在一个非CPS的程序中，add的continuation又是什么呢？当然我们还是可以把这段程序转成CPS的，可是有必要这样做吗？\r\n\r\n事实上没有必要。注意观察整个CPS转换过程，如果有人尝试要为CPS程序写编译器并且认真思考过就会发现：CPS的程序是不需要栈的！在这里完全没有函数需要做传统意义上的“返回”操作，函数执行完后仅需要接着调用另外一个函数就可以了。于是就不需要在每次调用函数的时候把参数压栈再将它们从中取出，只要把这些参数存放在一片内存中然后使用跳转指令就解决问题了。也完全不需要保留原来的参数：因为这种程序里的函数都不返回，所以它们不会被用第二次！\r\n简单点说呢，用CPS风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。非CPS风格的程序不需要额外的参数但又需要栈才能运行。栈里面存的是什么？仅仅是参数还有一个供函数运行结束后返回的程序指针而已。这个时候你是不是已经恍然大悟了？对啊，栈里面的数据实际上就是continuation的信息！栈上的程序返回指针实质上就是CPS程序中需要调用的下一个函数！想要知道add(5, 10)的continuation是什么？只要看它运行时栈的内容就可以了。\r\n\r\n接下来就简单多了。continuation和栈上指示函数返回地址的指针其实是同一样东西，只是continuation是显式的传递该地址并且因此代码就不局限于只能返回到函数被调用的地方了。前面说过，continuation就是函数，而在我们特制的语言中函数就是类的实例，那么可以得知栈上指向函数返回地址的指针和continuation的参数是一样的，因为我们所谓的函数（就像类的一个实例）其实就是指针。这也意味着在程序运行的任何时候，你都可以得到当前的continuation（就是栈上的信息）。\r\n\r\n好了，我们已经搞清楚当前的continuation是什么了。接下来要弄明白它的存在有什么意义。只要得到了当前的continuation并将它保存起来，就相当于保存了程序的当前状态：在时间轴上把它冻结起来了。这有点像操作系统进入休眠状态。continuation对象保存了足够的信息随时可以从指定的某个状态继续运行程序。在切换线程的时候操作系统也是这样做的。唯一的区别在于它保留了所有的控制权利。当请求某个continuation对象时（在Scheme语言中是通过调用call-with-current-continuation函数实现的）得到的是一个存有当前continuation的对象，也就是栈对象（在CPS中也就是下一个要执行的函数）。可以把这个对象保存做一个变量中（或者是存在磁盘上）。当以该continuation对象“重启”该程序时，程序的状态就会立即“转换”为该对象中保存的状态。这一点和切换回一个被暂停的线程或是从系统休眠中唤醒很相像，唯一不同的是continuatoin对象可以反复的这样使用。当系统唤醒后，休眠前保存的信息就会销毁，否则你也可以反复的从该点唤醒系统，就像乘时光机回到过去一样。有了continuation你就可以做到这一点！\r\n\r\n那么continuation在什么情况下有用呢？有一些应用程序天生就没有状态，如果要在这样的系统中模拟出状态以简化工作的时候，就可以用到continuation。最合适的应用场合之一就是网页应用程序。微软的ASP.NET为了让程序员更轻松的编写应用程序，花了大量的精力去模拟各种状态。假如C#支持continuation的话，那么ASP.NET的复杂度将减半：因为只要把某一时刻的continuation保存起来，下次用户再次发起同样请求的时候，重新载入这个continuation即可。对于网络应用的程序员来说就再也没有中断了：轻轻松松程序就从下一行开始继续运行了！对于一些实际问题来说，continuation是一种非常有用的抽象工具。如今大量的传统胖客户端（见瘦客户端）正纷纷走进网络，continuation在未来将扮演越来越重要的角色。\r\n\r\n\r\n----------\r\n\r\n\r\n### 模式匹配 \r\n模式匹配并不是什么新功能。而事实上它和函数式编程也没有什么太大的关系。它之所以常常被认为是FP的一个特性，是因为在函数式语言已经支持模式匹配很长一段时间后的今天，指令式语言是还没有这个功能。\r\n\r\n还是直接用例子来看看什么是模式匹配吧，这是一个用Java写的Fibonacci函数：\r\n\r\n``` scala\r\nint fib(int n) {\r\n    if(n == 0) return 1;\r\n    if(n == 1) return 1;\r\n       \r\n    return fib(n - 2) + fib(n - 1);\r\n}\r\n```\r\n\r\n\r\n再看看用我们基于Java修改过的新语言写出来的Fibonacci函数，这种新语言就支持模式匹配：\r\n\r\n``` scala\r\nint fib(0) {\r\n    return 1;\r\n}\r\nint fib(1) {\r\n    return 1;\r\n}\r\nint fib(int n) {\r\n    return fib(n - 2) + fib(n - 1);\r\n}\r\n```\r\n\r\n\r\n区别在哪里呢？在于后者的编译器替我们实现了程序的分支。\r\n这有什么了不起的？确实也没什么。只是有人注意到很多函数中有非常复杂的switch结构（对于函数式程序而言更是如此），于是想到如果能把这层结构也抽象化就更好了。然后就把这个复杂的函数拆分成若干新的函数，并在这些函数的某些参数中应用模式（这和重载有点类似）。这样依赖当这个函数被调用的时候，编译器会在运行时将调用者传入的参数与各个新函数的参数定义进行比较，找出合适的那个函数来执行。合适的函数往往是参数定义上最具体最接近传入参数的那个函数。在这个例子中，当n为1时，可以用函数int fib(int n)，不过真正调用的是int fib(1)因为这个函数更具体更接近调用者的要求。\r\n模式匹配一般来说要比这里举的例子更加复杂。比如说，高级模式匹配系统可以支持下面的操作：\r\n\r\n``` java\r\nint f(int n < 10) { ... }\r\nint f(int n) { ... }\r\n```\r\n\r\n\r\n那么什么情况下模式匹配会有用呢？在需要处理一大堆程序分支的时候！每当需要实现复杂的嵌套if语句的时候，模式匹配可以帮助你用更少的代码更好的完成任务。我所知道的一个这样的函数是标准的WndProc函数，该函数是所有Win32应用程序必须具备的（尽管它经常会被抽象化）。模式匹配系统一般都可以像匹配简单数值一样匹配数据集合。举个例子，对于一个接受数组作为参数的函数，可以通过模式匹配数组中第一个数字为1并且第三个数字大于3的输入。 模式匹配的另外一个好处是每当需要添加或者修改程序分支时，再也不用面对那个庞大臃肿的函数了。只要添加（或者修改）相关的函数定义即可。有了模式匹配就不再需要四人帮的很多设计模式了。程序分支越多越复杂，模式匹配就越有用。而在习惯使用这一技术之后，你可能会怀疑没有它你一天都过不下去了。\r\n\r\n\r\n----------\r\n\r\n\r\n### Closure \r\n目前为止关于函数式编程各种功能的讨论都只局限在“纯”函数式语言范围内：这些语言都是lambda演算的实现并且都没有那些和阿隆佐形式系统相冲突的特性。然而，很多函数式语言的特性哪怕是在lambda演算框架之外都是很有用的。确实，如果一个公理系统的实现可以用数学思维来看待程序，那么这个实现还是很有用的，但这样的实现却不一定可以付诸实践。很多现实中的语言都选择吸收函数式编程的一些元素，却又不完全受限于函数式教条的束缚。很多这样的语言（比如Common Lisp）都不要求所有的变量必须为final，可以修改他们的值。也不要求函数只能依赖于它们的参数，而是可以读写函数外部的状态。同时这些语言又包含了FP的特性，如高阶函数。与在lambda演算限制下将函数作为参数传递不同，在指令式语言中要做到同样的事情需要支持一个有趣的特性，人们常把它称为lexical closure。还是来看看例子。要注意的是，这个例子中变量不是final，而且函数也可以读写其外部的变量：\r\n\r\n``` scala\r\nFunction makePowerFn(int power) {\r\n   int powerFn(int base) {\r\n       return pow(base, power);\r\n   }\r\n\r\n   return powerFn;\r\n}\r\n\r\nFunction square = makePowerFn(2);\r\nsquare(3); // returns 9\r\n```\r\n\r\n\r\nmakePowerFn函数返回另一个函数，这个新的函数需要一个整数参数然后返回它的平方值。执行square(3)的时候具体发生了什么事呢？变量power并不在powerFn的域内，因为makePowerFn早就运行结束返回了，所以它的栈也已经不存在了。那么square又是怎么正常工作的呢？这个时候需要语言通过某种方式支持继续存储power的值，以便square后面继续使用。那么如果再定义一个函数，cube，用来计算立方，又应该怎么做呢？那么运行中的程序就必须存储两份power的值，提供给makePowerFn生成的两个函数分别使用。这种保存变量值的方法就叫做closure。closure不仅仅保存宿主函数的参数值，还可以用在下例的用法中：\r\n\r\n``` java\r\nFunction makeIncrementer() {\r\n   int n = 0;\r\n\r\n   int increment() {\r\n       return ++n;\r\n   }\r\n}\r\n\r\nFunction inc1 = makeIncrementer();\r\nFunction inc2 = makeIncrementer();\r\n\r\ninc1(); // returns 1;\r\ninc1(); // returns 2;\r\ninc1(); // returns 3;\r\ninc2(); // returns 1;\r\ninc2(); // returns 2;\r\ninc2(); // returns 3;\r\n```\r\n\r\n\r\n运行中的程序负责存储n的值，以便incrementer稍后可以访问它。与此同时，程序还会保存多份n的拷贝，虽然这些值应该在makeIncrementer返回后就消失，但在这个情况下却继续保留下来给每一个incrementer对象使用。这样的代码编译之后会是什么样子？closure幕后的真正工作机理又是什么？这次运气不错，我们有一个后台通行证，可以一窥究竟。\r\n一点小常识往往可以帮大忙。乍一看这些本地变量已经不再受限于基本的域限制并拥有无限的生命周期了。于是可以得出一个很明显的结论：它们已经不是存在栈上，而是堆上了8。这么说来closure的实现和前面讨论过的函数差不多，只不过closure多了一个额外的引用指向其外部的变量而已：\r\n\r\n``` java\r\nclass some_function_t {\r\n   SymbolTable parentScope;\r\n  \r\n   // ...\r\n}\r\n```\r\n\r\n\r\n当closure需要访问不在它本地域的变量时，就可以通过这个引用到更外一层的父域中寻找该变量。谜底揭开了！closure将函数编程与面向对象的方法结合了起来。下一次为了保存并传递某些状态而创建类的时候，想想closure。它能在运行时从相应的域中获得变量，从而可以把该变量当初“成员变量”来访问，也因为这样，就不再需要去创建一个成员变量了。\r\n\r\n\r\n----------\r\n\r\n\r\n### 路在何方？ \r\n这篇文章仅仅涉及到函数式编程的一些皮毛。考虑到有时候星星之火可以燎原，所以如果它能给你一些帮助那就再好不过了。接下来我计划就范畴论、monads、函数式编程数据结构、函数式语言中的类型系统、并行函数式编程、数据库的函数式编程以及更多的话题写些类似的文章。如果我可以写出（在我学习的同时）以上清单的一半，我的人生就完整了。于此同时，Google将是我们的良师益友。\r\n\r\n\r\n----------\r\n\r\n\r\n### 欢迎联系 \r\n如果您有任何问题，评价或者建议，请发邮件到coffeemug@gmail.com（译者：如果翻译方面的问题／建议请发到yang.huang@ymail.com:)）。期待您的回复。\r\n\r\nNote：\r\n1. 当我在2005年求职时的的确确经常问别人这个问题。看着那些茫然的面孔实在是很好玩的事情。你们这些年薪30万美金的家伙，至少应该对自己可以利用的工具有个起码的理解嘛。\r\n2. 这是个有争议的问题。物理学家和数学家不得不承认目前还无法确定宇宙万物是不是都遵从可以用数学方法描述的各种法则。\r\n3. 我一直一来都很讨厌在历史课上罗列一堆枯燥无味的时间、人名、事件。对我来说历史就是关于那些改变世界的人们活生生的故事，是他们行为背后的个人动机，是那些他们用以影响芸芸众生的方法和工具。从这个角度来说，接下来的这堂历史课是不完整的，很遗憾。只有那些非常相关的人和事会被提及。\r\n4. 在我学习函数式编程的时候，“lambda”这个术语搞得我很烦，因为我不知道它到底是什么意思。在这里lambda就是一个函数，在数学符号中用这个希腊字母只是因为它更容易写。所以以后在谈及函数式编程的时候只要你听到lambda，把它在脑中翻译为“函数”就可以了。\r\n5. 有意思的是不论如何Java中的字符串总是不可修改的。讨论这种背叛Java的设计背后的原因会很有意思，可惜这样会让我们跑题的。\r\n6. 大部分函数式语言的编译器都会尽量将迭代函数转换为对等的循环语句。这种做法叫做尾调用优化。\r\n7. 反之则不一定成立。尽管有时候可以证明两段代码是等价的，但不是在所有的情况下都可以得出这样的结论。\r\n8. 实际上这样做并不比栈上存储要慢，因为在引入垃圾回收机制后，内存分配操作的时间代价仅为O(1)。\r\n \r\n\r\n\r\n  [1]: https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn/blob/master/FunctionalProgrammingForTheRestOfUs.cn.md', '15.jpg', '2017-09-23 12:36:00', '2019-04-03 15:33:59', 'p', '我们这些码农做事都是很拖拉的。每天例行报到后，先来点咖啡，看看邮件还有RSS订阅的文章。然后翻翻新闻还有那些', 126, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (85, 'chrome -- 全键盘快捷键 Vimium', '----------\r\n\r\n![][1]\r\n\r\n<center>有一个捉迷藏社团，他们团长现在还没找到</center>\r\n\r\n----------\r\n### 缘由\r\n这个插件装了许久，只会有`gg`，还是高效点的好，留在这里，权当忘记的时候翻阅\r\n\r\n> Vimium is a Google Chrome extension which provides keyboard shortcuts for navigation and control in the spirit of the Vim editor.\r\n\r\n----------\r\n### 快捷键笔记\r\n\r\n> 注：大写字母的快捷键其实就是 `Shift+字母`, `<c-e>`表示 `Ctrl+e`，另外，只记录自己可以用到的\r\n \r\n1. 查看帮助 `Shift+/` 不过是英文版的\r\n\r\n![][2]\r\n\r\n2. `h`, `j(\\<c-e>)`, `k(\\<c-y>)`,`l` 分别是向 左，下，上，右滚动页面，相当于方向键\r\n\r\n3. `u`：向上移动半个屏幕（相当于 `PageUp`）；`d`：向下滚动半个屏幕。（相当于 `PageDown`）\r\n\r\n4. `o`：相当于Chrome中的地址栏（贼方便）\r\n\r\n5. `gs`：查看页面源代码\r\n\r\n6. `gi`：将光标定位到输入框，如果有多个可以按Tab键切换（贼方便）\r\n\r\n7. `gg`：跳转到页面的顶部。`G`：跳转到页面的底部\r\n\r\n8. `r`：刷新页面，相当于`F5`，发现 `r` 会方便一点，也是可以用的\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/112548-106.jpg\r\n  [2]: http://cdn.pinsily.site/1510618351341.jpg', '17.jpg', '2017-11-14 12:38:00', '2019-04-06 04:30:44', 'p', '这个插件装了许久，只会有`gg`，还是高效点的好，留在这里，权当忘记的时候翻阅', 110, 0, 0, 'pinsily', 13);
INSERT INTO `article` VALUES (86, '算法 -- 四皇后问题(回溯法)', '![][10]\r\n\r\n<center><p>昔我往矣，杨柳依依。今我来思，雨雪霏霏</p></center>\r\n\r\n----------\r\n## 问题描述\r\n> 在 4*4 的棋盘上无冲突的摆放 4 个皇后，无冲突是指一个皇后所在位置的水平、竖直以及斜线上不能出现其他的皇后，其他的 n 皇后问题以此类推\r\n\r\n## 解决方法\r\n按行来摆放棋子，下一行的摆放满足于与上一行的棋子没有冲突，否则就返回上一步走其他的路线，这就是所谓的回溯法\r\n\r\n### 详细说明\r\n1. 在第一行有四种可能，选择第一个位置放上皇后\r\n![][1]\r\n\r\n2. 第二行原本可以有四种可能摆放，但是第一第二个已经和第一行的皇后冲突了，因此只剩下第三第四个格子了，先选择第三个格子\r\n![][2]\r\n\r\n3. 接下来是第三行，根据规则可以看出，第三行已经没有位置放了，因为都跟第一第二行的皇后冲突，此时返回到第二行第四个\r\n![][3]\r\n\r\n4. 继续来到第三行，发现只有第二个满足条件\r\n![][4]\r\n\r\n5. 然后发现第四行已经不能放了，只能继续返回，返回到第一行，开始下一种可能\r\n![][5]\r\n\r\n6. 按照 1-5 的步骤，可以找到下面的其中一种解法\r\n![enter description here][6]\r\n\r\n总而言之，回溯法就是开始一路到底，碰到南墙了就返回走另外一条路，有点像穷举法那样走遍所有的路\r\n\r\n## 算法实现\r\n构建二维数组，增加规则，利用递归实现回溯效果\r\n\r\n``` c\r\n# include <stdio.h>\r\n# define N 4         // 可以调整\r\n\r\nint count=0;\r\n\r\n// 判断 Q[i][j] 是否存在冲突 \r\nint isCorrect(int i, int j, int (*Q)[N]) {\r\n    \r\n    int s,t;\r\n    // 判断行 \r\n    for(s=i,t=0; t<N; t++)\r\n        if(Q[s][t]==1 && t!=j)\r\n            return 0;\r\n            \r\n    // 判断列 \r\n    for(s=0,t=j; s<N; s++)\r\n        if(Q[s][t]==1 && s!=i)\r\n            return 0;\r\n    \r\n    // 判断左上角    \r\n    for(s=i-1,t=j-1; s>=0&&t>=0; s--,t--)\r\n        if(Q[s][t]==1)\r\n            return 0;\r\n    \r\n    // 右下角 \r\n    for(s=i+1,t=j+1; s<N&&t<N; s++,t++)\r\n        if(Q[s][t]==1)\r\n            return 0;\r\n    \r\n    // 右上角 \r\n    for(s=i-1,t=j+1; s>=0&&t<N; s--,t++)\r\n        if(Q[s][t]==1)\r\n            return 0;\r\n            \r\n    // 左下角 \r\n    for(s=i+1,t=j-1; s<N&&t>=0; s++,t--)\r\n        if(Q[s][t]==1)\r\n            return 0;\r\n            \r\n    return 1;\r\n    \r\n    \r\n    \r\n}\r\n\r\n// 递归函数，第 i+1 行的遍历  \r\nvoid Queue(int i, int (*Q)[N]) {\r\n     \r\n     int j,k;\r\n     \r\n     // 第四行已经遍历完，打印符合条件的结果，结束 \r\n     if(i==N) {\r\n         \r\n         count++;\r\n         printf(\"No.%d slove way\\n\",count);   \r\n         for(k=0;k<N; k++) {\r\n         \r\n             for(j=0; j<N; j++)\r\n                 printf(\"%-5d\", Q[k][j]);\r\n             printf(\"\\n\");\r\n             \r\n             //return;\r\n         }\r\n         printf(\"\\n\");\r\n              \r\n     }\r\n      \r\n     // 遍历第 i+1 行的 j+1 列 \r\n     for(j=0;j<N; j++) {\r\n                  \r\n         if(isCorrect(i,j,Q)) {\r\n                              \r\n             Q[i][j]=1;\r\n             Queue(i+1,Q);   // 遍历下一行 \r\n             Q[i][j]=0;      // 如果下一行不成立，则回溯，重置 0                      \r\n         \r\n         }  \r\n     }  \r\n}\r\n\r\nint main() {\r\n    \r\n    int Q[N][N];\r\n    int i,j;\r\n    \r\n    // 初始化二维数组并打印 \r\n    for (i=0; i<N; i++) { \r\n        \r\n        for(j=0; j<N; j++) {\r\n            Q[i][j] = 0;\r\n            printf(\"%-5d\",Q[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n        \r\n    }\r\n    printf(\"\\n\");\r\n    Queue(0, Q); // 从第一行开始递归 \r\n    printf(\"solve count is %d\\n\", count);\r\n    getchar();\r\n    getchar();\r\n    return 0; \r\n\r\n    \r\n    \r\n}\r\n\r\n```\r\n### 效果展示\r\nN = 4 时，有两种解法\r\n![][7]\r\n\r\nN = 8 时，有 92 种解法\r\n![][8]\r\n\r\n\r\n然后手贱试了一下 N = 16 的，结果跑了 7-8 分钟这样，已经到了第23028 种解法了，第一行还在第一个位置，果断放弃\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/1512978059938.jpg\r\n  [2]: http://cdn.pinsily.site/1512978094910.jpg\r\n  [3]: http://cdn.pinsily.site/1512978135466.jpg\r\n  [4]: http://cdn.pinsily.site/1512978175838.jpg\r\n  [5]: http://cdn.pinsily.site/1512978217401.jpg\r\n  [6]: http://cdn.pinsily.site/1512978242146.jpg\r\n  [7]: http://cdn.pinsily.site/1512978266763.jpg\r\n  [8]: http://cdn.pinsily.site/1512978285388.jpg\r\n  [9]: http://cdn.pinsily.site/1512978314483.jpg\r\n\r\n[10]: http://cdn.pinsily.site/130796-106.jpg', '18.jpg', '2017-09-24 12:40:00', '2019-04-04 02:42:56', 'p', '在 4*4 的棋盘上无冲突的摆放 4 个皇后，无冲突是指一个皇后所在位置的水平、竖直以及斜线上不能出现其他', 96, 0, 0, 'pinsily', 14);
INSERT INTO `article` VALUES (87, '﻿mongodb -- 基本操作', '----------\r\n\r\n\r\n![][1]\r\n\r\n<center><p>昔我往矣，杨柳依依。今我来思，雨雪霏霏</p></center>\r\n\r\n----------\r\n\r\n##### **查看数据库**\r\n```shell\r\n> db;\r\n\r\n\r\n\r\n> show tables;\r\ncities\r\norders\r\nschools\r\nwx_behaves\r\n\r\n> show collections\r\ncities\r\norders\r\nschools\r\nwx_behaves\r\n\r\n```\r\n\r\n##### **使用数据库**\r\n```shell\r\n> db.orders\r\nyouxue.orders\r\n```\r\n\r\n##### **查询**\r\n```\r\n# 杂乱无章\r\n> db.orders.find()\r\n\r\n# 排好文档格式\r\n> db.schools.find().pretty()\r\n\r\n# \r\n> db.col.find({\"title\": \'MongoDB 教程\'}).pretty()\r\n\r\n```\r\n\r\n##### **插入**\r\n```shell\r\n> document=( {title: \'MongoDB 教程\', \r\n    description: \'MongoDB 是一个 Nosql 数据库\',\r\n});\r\n\r\n{\r\n        \"title\" : \"MongoDB 教程\",\r\n        \"description\" : \"MongoDB 是一个 Nosql 数据库\",\r\n}\r\n\r\n> db.orders.insert(document)\r\nWriteResult({ \"nInserted\" : 1 })\r\n\r\n```\r\n\r\n##### **更新**\r\n```shell\r\n# 找到对应文档，修改属性\r\n> db.orders.update({\'title\':\'MongoDB 教程\'},{$set:{\'title\':\'MongoDB\'}})\r\n```\r\n\r\n##### **删除**\r\n```shell\r\n# 删除此标题的文档\r\n> db.orders.remove({\'title\':\'MongoDB 教程\'})\r\n\r\n# 删除全部数据\r\n> db.orders.remove({})\r\n```\r\n\r\n\r\n----------\r\n [1]: http://cdn.pinsily.site/130796-106.jpg', '19.jpg', '2017-08-29 12:43:00', '2019-04-08 18:56:56', 'p', '昔我往矣，杨柳依依。今我来思，雨雪霏霏', 100, 0, 0, 'pinsily', 15);
INSERT INTO `article` VALUES (88, 'linux -- swap file “*.swp”already exists！', '----------\r\n\r\n![][1]\r\n\r\n<center><p>慕言，思慕的慕，无言以对的言，我的名字</p></center>\r\n\r\n----------\r\n### 问题\r\n在使用 vim 的时候，出现了以下问题\r\n\r\n![][2]\r\n\r\n\r\n使用vim编辑文件实际是先 copy 一份临时文件并映射到内存给你编辑， 编辑的是临时文件， 当执行：w 后才保存临时文件到原文件，执行：q 后才删除临时文件。\r\n\r\n每次启动检索是否有临时文件， 有则询问如何处理，就会出现如上情景\r\n\r\n----------\r\n### 解决\r\n在文件目录下使用 `ls -a` 会看到交换文件，将它删除即可\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341191-106.jpg\r\n  [2]: http://cdn.pinsily.site/1512980175813.jpg', '20.jpg', '2017-09-13 12:44:00', '2019-04-06 08:52:48', 'p', '使用vim编辑文件实际是先 copy 一份临时文件并映射到内存给你编辑， 编辑的是临时文件', 90, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (89, '﻿linux -- ls 命令', '----------\r\n\r\n![][1]\r\n\r\n<center><p>从此故乡只有冬夏，再无春秋</p></center>\r\n\r\n---------\r\n### emmmm\r\n> ls 是 list 的缩写，在 linux 中用于列出文件和目录,在这里只是记录常用的\r\n\r\n----------\r\n### 用法\r\n- 直接使用\r\n> 列出目录下的所有文件或文件夹\r\n```\r\nroot@pinsily:~# ls\r\npinsily_1  pinsily_2  pinsily_3  test.html\r\n```\r\n\r\n- 获得详细信息\r\n> 使用参数 `-l`\r\n```shell\r\nroot@pinsily:~# ls -l\r\ntotal 16\r\ndrwxr-xr-x 2 root root 4096 Dec 15 15:55 pinsily_1\r\ndrwxr-xr-x 2 root root 4096 Dec 15 15:55 pinsily_2\r\ndrwxrwxrwx 2 root root 4096 Dec 15 15:55 pinsily_3\r\n-rw-r--r-- 1 root root   14 Dec 11 16:12 test.html\r\n```\r\n\r\n|   列数  |   解释  |\r\n| --- | --- |\r\n|   1  |  第一个字母：`d`表示目录，`-`表示文件，`l`表示链接    |\r\n|   1   |   第2-10个字母：三位一组，分别表示文件所有者、所有组、其他用户的权限  |\r\n|   2  |   数字表示有多少个链接指向这个文件  |\r\n|   3  |    文件的所有者 |\r\n|   4  |   文件的所有组  |\r\n|  5   |  文件大小，字节数   |\r\n|   6  |    文件最后的修改时间 |\r\n|   7  |  文件名或者目录名   |\r\n\r\n\r\n----------\r\n\r\n\r\n- 人性化展示信息\r\n> 使用参数`-h`，比如可以把上面的字节数改为我们熟悉的单位\r\n```\r\nroot@pinsily:~# ls -lh\r\ntotal 16K\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 15:55 pinsily_1\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 15:55 pinsily_2\r\ndrwxrwxrwx 2 root root 4.0K Dec 15 15:55 pinsily_3\r\n-rw-r--r-- 1 root root   14 Dec 11 16:12 test.html\r\n```\r\n\r\n- 隐藏文件\r\n> 在 linux 中，以`.`开头的文件都是隐藏文件，可以使用参数`-a`打印\r\n```\r\nroot@pinsily:~# ls -al\r\ntotal 60\r\ndrwx------  8 root root 4096 Dec 15 16:08 .\r\ndrwxr-xr-x 23 root root 4096 Dec  7 11:12 ..\r\n-rw-------  1 root root 1157 Dec 11 16:43 .bash_history\r\n-rw-r--r--  1 root root 3106 Feb 20  2014 .bashrc\r\ndrwx------  3 root root 4096 Aug 24 20:53 .cache\r\n-rw-------  1 root root    0 Dec  7 11:32 .mysql_history\r\n-rw-r--r--  1 root root    0 Dec 15 16:08 .pinsily\r\ndrwxr-xr-x  2 root root 4096 Dec 15 15:55 pinsily_1\r\ndrwxr-xr-x  2 root root 4096 Dec 15 15:55 pinsily_2\r\ndrwxrwxrwx  2 root root 4096 Dec 15 15:55 pinsily_3\r\ndrwxr-xr-x  2 root root 4096 Aug 24 20:53 .pip\r\n-rw-r--r--  1 root root  140 Feb 20  2014 .profile\r\n-rw-r--r--  1 root root   64 Aug 24 20:53 .pydistutils.cfg\r\ndrwx------  2 root root 4096 Dec  7 10:59 .ssh\r\n-rw-r--r--  1 root root   14 Dec 11 16:12 test.html\r\n-rw-------  1 root root 4215 Dec 11 16:43 .viminfo\r\n```\r\n\r\n- 按文件大小排序\r\n> 使用参数`-S`,按文件大小从大到小排序\r\n```\r\nroot@pinsily:~# ls -lhS\r\ntotal 64K\r\n-rw-r--r-- 1 root root  51K Dec 15 16:18 test.html\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 16:17 pinsily_1\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 15:55 pinsily_2\r\ndrwxrwxrwx 2 root root 4.0K Dec 15 15:55 pinsily_3\r\n```\r\n\r\n- 输出反转\r\n> 使用参数 `-r`,比如可以将排序从小到大输出\r\n```\r\nroot@pinsily:~# ls -lhSr\r\ntotal 64K\r\ndrwxrwxrwx 2 root root 4.0K Dec 15 15:55 pinsily_3\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 15:55 pinsily_2\r\ndrwxr-xr-x 2 root root 4.0K Dec 15 16:17 pinsily_1\r\n-rw-r--r-- 1 root root  51K Dec 15 16:18 test.html\r\n```\r\n\r\n- 只列出目录条目\r\n> 使用参数 `-d`,不过后面得加上参考(通配符)，这个可以自己定\r\n```\r\nroot@pinsily:~# ls -d */\r\npinsily_1/  pinsily_2/  pinsily_3/\r\n```\r\n-- ls 版本\r\n> 使用参数 `--version`\r\n```\r\nroot@pinsily:~# ls --version\r\nls (GNU coreutils) 8.21\r\nCopyright (C) 2013 Free Software Foundation, Inc.\r\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\r\nThis is free software: you are free to change and redistribute it.\r\nThere is NO WARRANTY, to the extent permitted by law.\r\nWritten by Richard M. Stallman and David MacKenzie.\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/248913-106.jpg', '21.jpg', '2017-12-15 12:44:00', '2019-03-31 16:08:12', 'p', 'ls 是 list 的缩写，在 linux 中用于列出文件和目录,在这里只是记录常用的', 106, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (90, '﻿python 进阶(12) -- try 异常处理', '----------\r\n\r\n![][1]\r\n\r\n<center><p>纯白是黑夜的给予，鲜红铸就生命之美丽</p></center>\r\n\r\n---------\r\n### 缘由\r\n虽然很久以前就接触了这块，但由于每次写程序的时候都是没有意识的进行异常处理的节奏，搞得需要运行挺久的程序后续出错了又得重来，实在是有些浪费时间，所以也算是好好地复习一下这块，之后尽量使用\r\n\r\n----------\r\n### 异常与错误的区别\r\n#### 错误\r\n   1. 代码运行前的语法或语法错误\r\n   2. 语法错误在执行前修改，逻辑错误无法修改\r\n\r\n#### 异常\r\n  1. 异常产生：检查到错误且解释器认为是异常，抛出异常\r\n  2. 异常处理：截获异常，忽略或者终止程序处理异常\r\n\r\n----------\r\n### 常见错误\r\npython 的标准错误在官网上貌似有几十种，但是很多都是比较少接触的，这里就简单地错一下，找个\'榜样\'\r\n\r\n1. NameError\r\n```\r\n>>> a\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nNameError: name \'a\' is not defined\r\n```\r\n\r\n2. SyntaxError\r\n```\r\n>>> a = 5\r\n>>> if a\r\n  File \"<stdin>\", line 1\r\n    if a\r\n       ^\r\nSyntaxError: invalid syntax\r\n```\r\n\r\n\r\n\r\n3. ZeroDivisionError\r\n```\r\n>>> a = 3/0\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nZeroDivisionError: division by zero\r\n```\r\n\r\n4. ValueError\r\n```\r\n>>> a = int(\"a12\")\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nValueError: invalid literal for int() with base 10: \'a12\'\r\n```\r\n\r\n\r\n----------\r\n### try-except 异常处理\r\n当捕获的异常和 except 设置的异常相同时，进入 except 执行，如果不相同则交由 python 解释器处理错误\r\n\r\n```\r\nIn [5]: try:\r\n   ...:     a\r\n   ...: except NameError as e:\r\n   ...:     print(\"Error is -- \",e)\r\n   ...:\r\nError is --  name \'a\' is not defined\r\n```\r\n\r\n\r\n----------\r\n### try-except-else 异常处理\r\n如果没有捕获到异常，就执行 else 语句内容\r\n```\r\nIn [6]: try:\r\n   ...:     a=1\r\n   ...: except NameError as e:\r\n   ...:     print(\"Error is -- \",e)\r\n   ...: else:\r\n   ...:     print(\"no Error.\")\r\n   ...:\r\nno Error. \r\n```\r\n\r\n\r\n----------\r\n### try-finally 异常处理\r\n\r\n无论是否检测到异常，都会执行 `finally` 代码\r\n为异常处理提供清理机制，用来关闭文件或释放资源\r\n\r\n比如，我们打开一个文件之后，如果在处理文件的过程中出现错误的话，可以现在 `finally` 中把文件关掉，之后再由 `except` 或 python 解释器处理异常\r\n\r\n\r\n----------\r\n### assert 和 raise\r\n\r\n`arise` 用于主动抛出异常\r\n```\r\nIn [13]: raise ValueError(\"hello\")\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-13-d7ed59243d37> in <module>()\r\n----> 1 raise ValueError(\"hello\")\r\n\r\nValueError: hello\r\n```\r\n`assert` 为断言语句，用于检测语句是否为真，假的话会抛出异常\r\n```\r\nIn [14]: assert 0,\"hello\"\r\n---------------------------------------------------------------------------\r\nAssertionError                            Traceback (most recent call last)\r\n<ipython-input-14-06268a1684c1> in <module>()\r\n----> 1 assert 0,\"hello\"\r\n\r\nAssertionError: hello\r\n\r\nIn [15]: assert 1,\"hello\"\r\n```\r\n\r\n`arise` 和 `assert` 因为之前没有遇到过，所以当做是简单了解一下吧\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/248978-106.jpg', '22.jpg', '2017-12-15 12:45:00', '2019-04-07 09:46:03', 'p', '虽然很久以前就接触了这块，但由于每次写程序的时候都是没有意识的进行异常处理的节奏，搞得需要运行挺久的程序后续', 174, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (91, '﻿linux -- 开机启动(bootstrap)', '----------\r\n\r\n\r\n<center><p>醒来，方知是梦</p></center>\r\n\r\n----------\r\n### 转载\r\n> 作者：Vamei 出处：[http://www.cnblogs.com/vamei][1]\r\n\r\n----------\r\n### 起始\r\n\r\n计算机开机是一个神秘的过程。我们只是按了开机键，就看到屏幕上的进度条或者一行行的输出，直到我们到达登录界面。然而，计算机开机又是个异常脆弱的过程，我们满心期望的登录界面可能并不会出现，而是一个命令行或者错误信息。了解计算机开机过程有助于我们修复开机可能出现的问题。\r\n\r\n \r\n\r\n\r\n----------\r\n### 最初始阶段\r\n\r\n当我们打开计算机电源，计算机会自动从主板的 `BIOS(Basic Input/Output System)`读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。\r\n\r\n下一步，计算机将从你所选择的存储设备中读取`起始的 512 个字节(bytes)`。如果我们从光盘启动的话，那么计算机就会读取光盘最开始的 512 个字节。这 512 个字节叫做`主引导记录 MBR (master boot record)`。MBR会告诉电脑从该设备的`某一个分区(partition)`来装载`引导加载程序(boot loader)`。引导加载程序储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (内核)所在位置等。常用的引导加载程序有 `GRUB` 和 `LILO`。\r\n\r\n随后，引导加载程序会帮助我们加载`内核(kernel)`。内核实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过内核传达给硬件。Windows和Linux各自有自己内核。狭义的操作系统就是指内核，广义的操作系统包括内核以及内核之上的各种应用。\r\n\r\n（Linus Torvalds 与其说是 Linux 之父，不如说是 Linux 内核之父。他依然负责 Linux 内核的开发和维护。至于 Ubuntu, Red Hat, 它们都是基于相同的内核之上，囊括了不同的应用和界面构成的一个更加完整的操作系统版本。)\r\n\r\n实际上，我们可以在多个分区安装引导加载程序，每个引导加载程序对应不同的操作系统，在读取MBR的时候选择我们想要启动的引导加载程序。这就是多操作系统的原理。\r\n\r\n\r\n小结：BIOS -> MBR -> 引导加载程序 -> 内核\r\n\r\n \r\n\r\n\r\n----------\r\n\r\n\r\n### 内核\r\n\r\n如果我们加载的是Linux内核，Linux内核开始工作。内核会首先预留自己运行所需的内存空间，然后通过`驱动程序(driver)`检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，内核会启动一个 `init 进程`。它是Linux系统中的 1 号进程(Linux系统没有0号进程)。到此，内核就完成了在计算机启动阶段的工作，交接给 init 来管理。\r\n\r\n \r\n\r\n小结: 内核 -> init process\r\n\r\n \r\n\r\n#### init process\r\n\r\n(根据 boot loader 的选项，Linux 此时可以进入`单用户模式(single user mode)`。在此模式下，初始脚本还没有开始执行，我们可以检测并修复计算机可能存在的错误)\r\n\r\n随后，init会运行一系列的`初始脚本(startup scripts)`，这些脚本是Linux中常见的shell scripts。这些脚本执行如下功能：\r\n\r\n设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……\r\n\r\n当这些初始脚本，操作系统已经完全准备好了，只是，还没有人可以登录。init会给出登录(login)对话框，或者是图形化的登录界面。\r\n\r\n \r\n\r\n输入用户名(比如说vamei)和密码，DONE！\r\n\r\n在此后的过程中，你将以用户(user)vamei的身份操作电脑。此外，根据你创建用户时的设定，Linux还会将你归到某个组(group)中，比如可以是stupid组，或者是vamei组。\r\n\r\n所以你将是用户vamei， 同时是vamei组的组员。(注意，组vamei和用户vamei只是重名而已，就好想你可以叫Dell, 同时还是Dell公司的老板一样。你完全也可以是用户vamei，同时为stupid组的组员)\r\n\r\n \r\n\r\n\r\n----------\r\n\r\n\r\n### 总结\r\n\r\nBIOS -> MBR -> 引导加载程序 -> 内核 -> init process -> login\r\n\r\n用户，组。\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://www.cnblogs.com/vamei', '22_V1qDWUJ.jpg', '2017-12-19 12:47:00', '2019-04-05 14:06:05', 'p', '计算机开机是一个神秘的过程。我们只是按了开机键，就看到屏幕上的进度条或者一行行的输出，直到我们到达登录界面', 98, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (92, '﻿android -- eclipse 环境搭建', '----------\r\n\r\n![][1]\r\n\r\n<center>甚爱必大费；多藏必厚亡。故知足不辱，知止不殆，可以长久</center>\r\n\r\n----------\r\n### 记在开始\r\n开始接触安卓，当时只是因为自己的一时兴起，加上选了一个不怎么在意的课程，拖拖拉拉得也就到现在才算慢慢开始，之前有折腾过一段时间，但都以失败告终，使用 Android Studio ，弄得程序崩溃了，只能回到 eclipse 中来重新开始\r\n\r\n这里，记下安装配置的磕磕绊绊\r\n\r\n\r\n----------\r\n### 参考\r\n> [Eclipse+ADT+Android SDK 搭建安卓开发环境][2]\r\n\r\n\r\n----------\r\n### 主要步骤\r\n1. 安装 eclipse\r\n2. 安装 ADT\r\n3. 安装 SDK，更新并下载\r\n4. 使用 AVD \r\n\r\n----------\r\n### 安装 eclipse\r\n1. 进入到官网 [下载页面][3]，选择 Download packages，直接下载的话是 exe 文件，要另外更新下载才能使用，而且巨慢，会绝望的\r\n\r\n![][4]\r\n\r\n2. 选择相应的位数（win+pause break 健查看电脑位数）\r\n\r\n![][5]\r\n\r\n3. 下载 zip 安装包，或者下载其他版本的\r\n\r\n![][6]\r\n\r\n4. 下载好之后解压 zip 文件，放到任意目录下（方便为前提）即可直接使用\r\n\r\n5. 打开目录下的 eclipse.exe 开始使用，选择好工作目录等\r\n\r\n\r\n----------\r\n\r\n### 安装 ADT\r\n> ADT 全称是 Android Development Tools，即 Android 开发工具，在Eclipse 编译 IDE 环境中，安装 ADT，为 Android 开发提供开发工具的升级或者变更，简单理解为在 Eclipse 下开发工具的升级下载工具\r\n\r\nADT 的安装可以在线安装，也可以离线安装，因为在线安装连接的是国外的网站，巨慢，所以就采用离线的安装了\r\n\r\n1. 下载离线zip（不用解压）： [ADT-23.0.6.zip][7]\r\n\r\n2. 启动Eclipse, 然后在菜单栏上选择 Help > Install New Software，点击 Add\r\n\r\n![][8]\r\n\r\n3. 在\"Add Repository\"对话框，名字随意，单击 \"Archive\"，选择好下载的 adt-23.0.6.zip 文件，点击 \'ok\'\r\n\r\n![][9]\r\n\r\n4.  选择\'select all\',并去掉 contact all update sites during install to find required sofeware\r\n\r\n![][10]\r\n\r\n5. 接下来按照提示进行安装就行了，其中有一个是接受协议\r\n\r\n6. 安装完成后，重新启动 eclipse\r\n\r\n----------\r\n\r\n\r\n### 安装 SDK\r\n\r\n> SDK(Software Development Kit)，一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。在Android中，他为开发者提供了库文件以及其他开发所用到的工具。简单理解为开发工具包集合，是整体开发中所用到的工具包，如果你不用Eclipse作为你的开发工具，你就不需要下载ADT，只下载SDK即可开发\r\n\r\n1. 下载独立 SDK(需解压) [android-sdk_r24.0.2-windows.zip][11]\r\n\r\n2. 启动 Eclipse, 选择 windows>preferences>android\r\n3. 在选项卡中选择 \"Browse\", 选择之前下载的 Android SDK 的 zip 文件(需要解压)的目录(解压后的目录),点击 apply\r\n\r\n![][12]\r\n\r\n4. 可能需要重启 eclipse\r\n\r\n#### 通过 Android SDK Manage 添加新的软件包\r\n1. 在菜单栏上找到 ![][13] 并点击，没有的话则在 window 选项卡中，打开 SDK Manage\r\n2. 选择好相应的版本，最少要有一个 Android 版本(建议 4.0 以上的)，然后进行安装，也需要接受协议\r\n\r\n![][14]\r\n\r\n3. 如果下载或者更新缓慢的话，可以考虑使用代理 [Android -- 解决 SDK下载和更新失败][15]\r\n\r\n安卓的环境搭建基本就是这些了，接下来还差一个安卓虚拟机的创建\r\n\r\n\r\n----------\r\n\r\n### 创建 AVD\r\n> AVD,全称 Android Virtual Device，即安卓虚拟机\r\n\r\n1. 启动 Eclipse,在菜单栏上点击 ![][16]，没有的话在 window 选项卡中，选择 \'create\'\r\n\r\n![][17]\r\n\r\n2. 选择相关配置，点击 ‘ok’\r\n\r\n![][18]\r\n\r\n3. 如果出现了 \'no images system installed for this target\' 或者没有 target 的错误，可参考 [android AVD坑(1) -- no images system installed for this target][19]\r\n\r\n\r\n----------\r\n### 总结\r\n在安装配置这些的时候老是碰坑，一个个解决了也算是成功了，继续接下来的学习喽\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/292659-106.jpg\r\n  [2]: http://blog.csdn.net/linyingzhi829/article/details/50589875\r\n  [3]: https://www.eclipse.org/downloads/\r\n  [4]: http://cdn.pinsily.site/1509499981105.jpg\r\n  [5]: http://cdn.pinsily.site/1509500033178.jpg\r\n  [6]: http://cdn.pinsily.site/1509500139135.jpg\r\n  [7]: https://dl.google.com/android/ADT-23.0.6.zip\r\n  [8]: http://cdn.pinsily.site/1509515365743.jpg\r\n  [9]: http://cdn.pinsily.site/1509515461011.jpg\r\n  [10]: http://cdn.pinsily.site/1509515666268.jpg\r\n  [11]: http://dl.google.com/android/android-sdk_r24.0.2-windows.zip\r\n  [12]: http://cdn.pinsily.site/1509515997803.jpg\r\n  [13]: http://cdn.pinsily.site/1509516218719.jpg\r\n  [14]: http://cdn.pinsily.site/1509516389295.jpg\r\n  [15]: http://pinsily.site/index.php/archives/103/\r\n  [16]: http://cdn.pinsily.site/1509516573820.jpg\r\n  [17]: http://cdn.pinsily.site/1509516622590.jpg\r\n  [18]: http://cdn.pinsily.site/1509516694843.jpg\r\n  [19]: http://pinsily.site/index.php/archives/222/', '23.jpg', '2017-11-01 12:48:00', '2019-04-08 17:31:18', 'p', '开始接触安卓，当时只是因为自己的一时兴起，加上选了一个不怎么在意的课程，拖拖拉拉得也就到现在才算慢慢开始', 112, 0, 0, 'pinsily', 8);
INSERT INTO `article` VALUES (93, '﻿python 进阶(13) -- python 是一种怎样的语言', '----------\r\n\r\n![][1]\r\n\r\n<center><p>你曾经是谁的英雄呢</p></center>\r\n\r\n---------\r\n\r\n### 转载\r\n> [http://mp.weixin.qq.com/s/KbEjTm5jRs7tBNP3ZZck4Q][2]\r\n\r\n\r\n----------\r\n### 前言\r\n\r\n「当我们在使用一个工具时，首先要做的就是尝试去了解它。」\r\n\r\n面试题：解释/编译？动态/静态？强/弱？Python 到底是一门怎样的语言\r\n\r\n\r\n----------\r\n### 编译 or 解释\r\n\r\n编译、解释都是指将（与人类亲和的）编程语言翻译成（计算机能够理解的）机器语言(Machine code)的过程。它们有什么区别呢？看一个例子：\r\n\r\n![][3]\r\n\r\nEmmmmmmmmmmmmm~ 神比喻 !!\r\n\r\n没错，编译型语言会将全部源代码一次性翻译完成，最终得到可执行文件，所以其主要特征为「一次编译，多次执行」，虽然编译时间长，但运行效率奇高，毕竟可执行文件就是一连串可以被计算机直接执行机器指令集。但缺点是可移植性差（异构平台的 CPU 指令集不兼容）、编译耗时与程序规模成正比，而且每次修改源码都要重新编译，所以 debug 体验糟糕。典型的编译型语言有 C/C++，常见于偏底层，执行环境苛刻且追求速度的场景（e.g. 嵌入式、硬件开发、矿工）；\r\n\r\n反观解释型语言并不会直接将源码翻译成机器码，而是先翻译成中间码，再交由语言自身提供的解释器逐条解释执行，所以解释型语言的特征之一就是「边解释，边执行」，导致了解释型程序的运行效率会更低。解释，或者说解释器存在的目的是为了提供一个与平台无关的托管运行时环境，使同一个程序能够运行在不同的操作系统之上，这就是解释型型语言的另一大特征「跨平台」。\r\n\r\n值得注意的是，Python 因为含有解释器，所以常被归类为解释型语言。实际上这一论断并不严谨，因为 Python 程序的运行同样需要经历编译的过程。Python 自身也包含了编译器，它会将源码先编译为中间状态的字节码(Bytecode)，再由解释器解释。默认的，Python 会将这些字节码保存在临时文件 .pyc 中，以避免重复进行编译，直到下一次源码修改为止。\r\n\r\n这样做的根本目的是为了在支撑跨平台的基础上进一步提升程序的运行效率，也正因如此使得编译和解释的界限变得模糊。如果单纯的将 Python 定性为解释型语言，难免会造成理解上的缺失。比如，不了解 .pyc 文件存在的意义。\r\n\r\n所以，我更愿意将 Python 定义为一门既有编译又有解释的更高级的编程语言。\r\n\r\n\r\n----------\r\n### 动态 or 静态\r\n动态、静态指的是编程语言类型系统对数据类型检查的严格程度。\r\n\r\n静态类型语言会进行严格的数据类型检查，在程序编译时(compile time)，就需要确定所有变量的数据类型，所以静态类型语言强制要求在使用变量之前事先声明变量的数据类型。因为类型声明机制，静态类型语言的编译器或 IDE 能够拥有良好的代码感知能力，使程序员更易于开发出复杂且庞大的应用系统程序。典型代表有 C、Java。\r\n\r\n``` c\r\nint anInt;\r\nchar aString[10];\r\nanInt = 1;\r\naString = {\"a\",\"b\",\"c\",\"d\",\"\\0”};\r\n```\r\n\r\n动态类型语言则相反，属于非严格数据类型检查。程序在实际运行时(runtime)，变量的数据类型才被确定。典型代表就是 Python\r\n\r\n``` c\r\n>>> obj = 123\r\n>>> obj = \'abc\'\r\n```\r\n\r\n动态类型语言不需要类型声明，同一个变量可以在不同的位置被赋予各种数据类型。只有当程序执行到某条具体的赋值语句时，变量类型才会由赋值对象的数据类型决定。因此，Python 程序的开发具有很强的灵活性，同时开发效率也不是 Java 能够比拟的。不过，虽然 Python 程序员可以不关注变量的数据类型，但解释器却需要去推断变量的数据类型，这也在一定程序上影响了程序的运行效率。而且数据类型检查不严格，也更容易埋下不易察觉的 bug。所以，Python 更适合开发中小型应用系统\r\n\r\n\r\n----------\r\n### 强类型 or 弱类型\r\n强、弱类型指的是编译程序时能否容忍隐式的数据类型转换\r\n\r\n弱类型语言能够容忍在程序运行时对变量进行隐式的数据类型转换，是一种几乎可以忽略数据类型的编程语言。可见，弱类型语言是类型非安全的。例如 JavaScript：\r\n\r\n```\r\n> \'1\' + 2\r\n\'12\'\r\n```\r\n\r\n强类型语言则相反，它是类型安全的。变量的数据类型一旦被确定，除非使用强制类型转换，否则其数据类型永远不会改变。强类型语言在速度上会稍逊于弱类型语言，但强类型带来的严谨性能够更好的避免许多错误。例如 Python：\r\n\r\n```\r\n>>> \'1\' + 2\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: cannot concatenate \'str\' and \'int’ objects\r\n```\r\n\r\n那类型安全具有什么意义呢？\r\n\r\n> 描述类型安全系统的最简单的方法就是描述它的对立面。有的语言（尤其是C和C++）允许做一些非常“不正当”的事情。但在合适的时候，其功能可能会很强大。但是，世界上没有免费的午餐。所谓“合适的时候”实际很少能够遇到。如使用不当，反而极有可能“搬起石头砸自己的脚”。滥用类型系统就属于这种情况\r\n\r\n打个比方，当程序将一个变量当作类型 A 来执行时，却意外的发现这个变量可能是类型 B，也可能什么都不是。但此时的程序可能已经通过了编译，正在运行的阶段。在这样的情形下，就很可能会导致程序崩溃或异常退出的问题。\r\n\r\n当然了，这里描述的是编程语言的类型安全问题。但很多时候即便编程语言是类型安全的，也可能会实现出类型非安全的应用程序，这属于两个层面的事情。所以即便 Python 是类型安全的，我们仍需谨慎的处理数据类型问题\r\n\r\n\r\n----------\r\n### 最后\r\n对于此次的面试题，我们可以简单的用一句「Python 是一门动态的强类型解释语言」来回答，但这样难免流于表面。我们通过对比编程语言的「编译/解释、动态/静态、强/弱」等类型特征之后应该可以更深刻的理解 Python 的语言特性。\r\n\r\n- Python 具有非常好的跨平台特性，同一套代码能够在不同的平台上正常的运行；\r\n\r\n- Python 虽然在编译上作出了努力，但同比其他编程语言依旧会慢；\r\n\r\n- Python 编程很灵活、效率很高，为此也牺牲了代码的严谨性，不适合多人协同开发大规模应用程序；\r\n\r\n- Python 虽然是类型安全的编程语言，但因其太多灵活，所以很容易实现出类型非安全的应用程序；\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/342483-106.jpg\r\n  [2]: http://mp.weixin.qq.com/s/KbEjTm5jRs7tBNP3ZZck4Q\r\n  [3]: http://cdn.pinsily.site/1513928178487.jpg', '24.jpg', '2017-12-22 12:49:00', '2019-04-03 07:00:55', 'p', '当我们在使用一个工具时，首先要做的就是尝试去了解它', 98, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (94, 'python 进阶(14) -- 内存管理机制', '----------\r\n\r\n![][1]\r\n\r\n<center><p>那是，未满45秒的邂逅</p></center>\r\n\r\n----------\r\n### 转载\r\n> 作者：Vamei 出处：http://www.cnblogs.com/vamei \r\n\r\n----------\r\n### 前言\r\n\r\n语言的内存管理是语言设计的一个重要方面。它是决定语言性能的重要因素。无论是C语言的手工管理，还是Java的垃圾回收，都成为语言最重要的特征。这里以Python语言为例子，说明一门动态类型的、面向对象的语言的内存管理方式\r\n\r\n----------\r\n### 对象的内存使用\r\n赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵。Python的赋值语句就很值得研究\r\n```python\r\na = 1\r\n```\r\n整数1为一个对象。而a是一个引用。利用赋值语句，引用a指向对象1。Python是动态类型的语言(参考动态类型)，对象与引用分离。Python像使用“筷子”那样，通过`引用`来接触和翻动真正的食物——对象\r\n\r\n![][2]\r\n\r\n----------\r\n ### 引用和对象\r\n\r\n为了探索对象在内存的存储，我们可以求助于Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址\r\n```python\r\na = 1\r\n\r\nprint(id(a))\r\nprint(hex(id(a)))\r\n```\r\n\r\n计算机上，它们返回的是:\r\n\r\n```python\r\n11246696\r\n\'0xab9c68\'\r\n```\r\n分别为内存地址的十进制和十六进制表示\r\n\r\n在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象\r\n```\r\na = 1\r\nb = 1\r\n\r\nprint(id(a))\r\nprint(id(b))\r\n```\r\n上面程序返回\r\n```\r\n11246696\r\n11246696\r\n```\r\n可见a和b实际上是指向同一个对象的两个引用\r\n\r\n为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同\r\n```\r\n# True\r\na = 1\r\nb = 1\r\nprint(a is b)\r\n\r\n# True\r\na = \"good\"\r\nb = \"good\"\r\nprint(a is b)\r\n\r\n# False\r\na = \"very good morning\"\r\nb = \"very good morning\"\r\nprint(a is b)\r\n\r\n# False\r\na = []\r\nb = []\r\nprint(a is b)\r\n```\r\n\r\n上面的注释为相应的运行结果。可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象\r\n\r\n在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)\r\n\r\n我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1\r\n\r\n```\r\nfrom sys import getrefcount\r\n\r\na = [1, 2, 3]\r\nprint(getrefcount(a))\r\n\r\nb = a\r\nprint(getrefcount(b))\r\n```\r\n由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。\r\n\r\n----------\r\n\r\n\r\n### 对象引用对象\r\nPython的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用\r\n\r\n我们也可以自定义一个对象，并引用其它对象:\r\n\r\n```\r\nclass from_obj(object):\r\n    def __init__(self, to_obj):\r\n        self.to_obj = to_obj\r\n\r\nb = [1,2,3]\r\na = from_obj(b)\r\nprint(id(a.to_obj))\r\nprint(id(b))\r\n```\r\n可以看到，a引用了对象b。\r\n\r\n对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值\"a\"的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典\r\n\r\n当一个对象A被另一个对象B引用时，A的引用计数将增加1\r\n\r\n```\r\nfrom sys import getrefcount\r\n\r\na = [1, 2, 3]\r\nprint(getrefcount(a))\r\n\r\nb = [a, a]\r\nprint(getrefcount(a))\r\n```\r\n由于对象b引用了两次a，a的引用计数增加了2\r\n\r\n容器对象的引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系，比如\r\n\r\n```\r\nx = [1, 2, 3]\r\ny = [x, dict(key1=x)]\r\nz = [y, (x, y)]\r\n\r\nimport objgraph\r\nobjgraph.show_refs([z], filename=\'ref_topo.png\')\r\n```\r\n\r\n<div style=\"margin:0 auto;width:50%;\">\r\n\r\n   <img src=\"http://cdn.pinsily.site/three.png\" alt=\"\">\r\n\r\n</div>\r\n\r\nobjgraph是Python的一个第三方包。安装之前需要安装xdot。\r\n```\r\nsudo apt-get install xdot\r\nsudo pip install objgraph\r\n```\r\n[objgraph官网][4]\r\n\r\n两个对象可能相互引用，从而构成所谓的引用环(reference cycle)\r\n```\r\na = []\r\nb = [a]\r\na.append(b)\r\n```\r\n即使是一个对象，只需要自己引用自己，也能构成引用环\r\n```\r\na = []\r\na.append(a)\r\nprint(getrefcount(a))\r\n```\r\n引用环会给垃圾回收机制带来很大的麻烦，我将在后面详细叙述这一点\r\n\r\n----------\r\n\r\n\r\n### 引用减少\r\n某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用:\r\n\r\n```\r\nfrom sys import getrefcount\r\n\r\na = [1, 2, 3]\r\nb = a\r\nprint(getrefcount(b))\r\n\r\ndel a\r\nprint(getrefcount(b))\r\n```\r\n\r\ndel也可以用于删除容器元素中的元素，比如:\r\n```\r\na = [1,2,3]\r\ndel a[0]\r\nprint(a)\r\n ```\r\n如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少:\r\n\r\n```\r\nfrom sys import getrefcount\r\n\r\na = [1, 2, 3]\r\nb = a\r\nprint(getrefcount(b))\r\n\r\na = 1\r\nprint(getrefcount(b))\r\n```\r\n----------\r\n### 垃圾回收\r\n吃太多，总会变胖，Python也是这样。当Python中的对象越来越多，它们将占据越来越大的内存。不过你不用太担心Python的体形，它会乖巧的在适当的时候“减肥”，启动垃圾回收(garbage collection)，将没用的对象清除。在许多语言中都有垃圾回收机制，比如Java和Ruby。尽管最终目的都是塑造苗条的提醒，但不同语言的减肥方案有很大的差异 (这一点可以对比本文和Java内存管理与垃圾回收)\r\n\r\n从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。比如下面的表:\r\n```\r\na = [1, 2, 3]\r\ndel a\r\n```\r\ndel a后，已经没有任何引用指向之前建立的[1, 2, 3]这个表。用户不可能通过任何方式接触或者动用这个对象。这个对象如果继续待在内存里，就成了不健康的脂肪。当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空\r\n\r\n然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动\r\n\r\n我们可以通过gc模块的get_threshold()方法，查看该阈值:\r\n```\r\nimport gc\r\nprint(gc.get_threshold())\r\n```\r\n返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置\r\n\r\n我们也可以手动启动垃圾回收，即使用gc.collect()\r\n\r\n----------\r\n### 分代回收\r\nPython同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率\r\n\r\nPython将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描\r\n\r\n这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收\r\n\r\n同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描\r\n```\r\nimport gc\r\ngc.set_threshold(700, 10, 5)\r\n```\r\n----------\r\n\r\n\r\n### 孤立的引用环\r\n引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象 \r\n\r\n```\r\na = []\r\nb = [a]\r\na.append(b)\r\n\r\ndel a\r\ndel b\r\n```\r\n上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收\r\n\r\n<div style=\"margin:0 auto;width:50%;\">\r\n\r\n   <img src=\"http://cdn.pinsily.site/five.png\" alt=\"\">\r\n\r\n</div>\r\n\r\n为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1 \r\n\r\n\r\n<div style=\"margin:0 auto;width:50%;\">\r\n\r\n   <img src=\"http://cdn.pinsily.site/six.png\" alt=\"\">\r\n\r\n</div>\r\n\r\n在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收 \r\n\r\n----------\r\n### 总结\r\nPython作为一种动态类型的语言，其对象和引用分离。这与曾经的面向过程语言有很大的区别。为了有效的释放内存，Python内置了垃圾回收的支持。Python采取了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341383-106.jpg\r\n  [2]: http://cdn.pinsily.site/two.jpg\r\n  [3]: http://cdn.pinsily.site/three.png\r\n  [4]: https://mg.pov.lt/objgraph/\r\n  [5]: http://cdn.pinsily.site/five.png\r\n  [6]: http://cdn.pinsily.site/six.png', '26.jpg', '2017-12-26 12:51:00', '2019-04-03 23:29:40', 'p', '语言的内存管理是语言设计的一个重要方面。它是决定语言性能的重要因素。无论是C语言的手工管理，还是Java的垃', 110, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (95, '﻿python 进阶(15) -- 字典计数优化', '----------\r\n![][1]\r\n\r\n<center><p>若是不相见，心中难免有牵挂</p></center>\r\n----------\r\n### 缘由\r\n在需要使用python进行数据处理的地方，经常需要使用字典来进行计数，如下：\r\n```\r\ncity = [\'Guangzhou\',\'Shanghai\',\'Tianjin\',\'Guangzhou\',\'Beijing\']\r\n\r\ndic = {}\r\n\r\nfor c in city:\r\n    if c not in dic:\r\n        dic[c] = 1\r\n    else:\r\n        dic[c] += 1    \r\n```\r\n\r\n\r\n----------\r\n### 改进\r\n在网上看到一个更为简单的方法，直接使用字典的 get 方法直接精简代码\r\n```\r\ncity = [\'Guangzhou\',\'Shanghai\',\'Tianjin\',\'Guangzhou\',\'Beijing\']\r\n\r\ndic = {}\r\n\r\nfor c in city:\r\n    dic[c] = dic.get(c,0) + 1\r\n```\r\ndict的 `get(key,default)` 方法用于获取字典中 key 的值，若不存在该 key，则将 key 赋默认值default,直接省掉了 `if-else` 语句\r\n\r\n\r\n----------\r\n\r\n  [1]: http://cdn.pinsily.site/112560-106.jpg', '27.jpg', '2017-12-26 12:52:00', '2019-04-07 09:46:06', 'p', '在需要使用python进行数据处理的地方，经常需要使用字典来进行计数', 134, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (96, '﻿python 进阶(16) -- 上下文管理器（with）', '----------\r\n![][1]\r\n\r\n  [1]: http://cdn.pinsily.site/112560-106.jpg\r\n  	\r\n<center><p>生我者何人，又岂由得我</p></center>\r\n----\r\n\r\n### 什么是上下文管理器\r\n我们经常在写 Python 代码的时候，会经常碰到下面的情况：\r\n- 当某条件为真时，执行某个代码块\r\n- 当某条件为真时，循环执行某个代码块\r\n\r\n另外，某些情况下，当我们需要执行上面所提到的某个代码块时，需要提前准备\r\n\r\n某些，也可能需要在执行后结束某种状态\r\n\r\n举个例子，比如写文件操作，也是下面需要使用到的，当我们执行写文件操作前\r\n\r\n，必须得打开一个文件，写了完成之后，也必须要关闭这个文件\r\n\r\n这样的一个过程，就称之为上下文管理，而实现这个过程的，就称之为上下文管\r\n\r\n理器了\r\n\r\n----\r\n### 上下文管理协议\r\n就像迭代器中有迭代协议（实现__iter__方法）一样,上下文管理器也有其对应的\r\n\r\n协议，既上下文管理协议，其规定，上下文协议需要实现如下两个方法：\r\n\r\n- `__enter__` 方法将在进入代码块前被调用\r\n\r\n- `__exit__` 方法则在离开代码块之后被调用(即使在代码块中遇到了异常)\r\n\r\n也就是对应上了上面所说到的执行前准备，执行后打扫的任务\r\n\r\n另外，exit方法中有三个参数（exc_type, exc_val, exc_tb），分别表示：\r\n- exc_type：　错误的类型 \r\n- exc_val：　错误类型对应的值 \r\n- exc_tb：　代码中错误发生的位置 \r\n\r\n当然，参数的名字是可以更改的\r\n\r\n---\r\n### 实现上下文管理器\r\n\r\n上下文管理器的实现由 with 语句生成，with + 后面的语句构成了上下文表达式\r\n\r\n我们最常接触到的上下文管理器也就是上面所提到的例子，对文件的处理，如下：\r\n\r\n```\r\nwith open(filename) as f:\r\n    f.write(sometext)\r\n```\r\n\r\n翻译成比较通俗的就是下面的代码：\r\n```\r\nf = open(r\'somefileName\')\r\ntry:\r\n    f.write(sometext)\r\nfinally:\r\n    f.close()\r\n```\r\n\r\n诚如所见，with 语句的使用，大大精简了代码\r\n\r\n---\r\n### with 原理\r\n\r\n\r\n下面试着讲讲 with 关于文件方面的具体实现过程\r\n\r\n先来看看一段代码：\r\n```\r\nclass A:\r\n    def __enter__(self):\r\n        print(\'__enter__() is called\')\r\n \r\n    def __exit__(self, e_t, e_v, t_b):\r\n        print(\'__exit__() is called\')\r\n \r\n \r\nwith A() as a:\r\n    print(\'got instance\')\r\n```\r\n如果能够理解上下文协议的话，应该不难知道输出的结果\r\n```\r\n__enter__() is called\r\ngot instance\r\n__exit__() is called\r\n```\r\n\r\n\r\n----\r\n### 函数 nested\r\nnested 可以将多个上下文管理器组织在一起，避免使用嵌套 with 语句,跟 zip\r\n\r\n() 函数有点相似\r\n```\r\nwith nested(A(), B(), C()) as (X, Y, Z):\r\n     # with-body\r\n```\r\n展开来：\r\n```\r\nwith A() as X:\r\n    with B() as Y:\r\n        with C() as Z:\r\n             # with-body\r\n```\r\n> 需要注意的是，发生异常后，如果某个上下文管理器的 __exit__() 方法对异常处理返回 False，则更外层的上下文管理器不会监测到异常', '29.jpg', '2017-12-27 12:54:00', '2019-04-07 08:19:06', 'p', '当我们执行写文件操作前  ，必须得打开一个文件，写了完成之后，也必须要关闭这个文件', 100, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (97, '﻿numpy  -- 基本操作', '----------\r\n\r\n![][1]\r\n\r\n<center><p>有一个捉迷藏社团，他们团长现在还没找到</p></center>\r\n\r\n---------\r\n\r\n### 参考翻译\r\n\r\n> [官网 Quickstart tutorial][2]\r\n\r\n\r\n----------\r\n### Array Creation\r\n> numpy 生成 Array 会返回一个 ndarray 对象\r\n\r\n```python\r\n>>> import numpy as np\r\n>>> a = np.array([[1,2,3],[4,5,6]])  # 直接生成\r\n>>> a\r\narray([[1, 2, 3],\r\n       [4, 5, 6]])\r\n	   \r\n>>> b = np.arange(1,10,2)  # 随机生成，1-10 步长为 2\r\n>>> b\r\narray([1, 3, 5, 7, 9])\r\n\r\n>>> c = np.arange(15)    # 默认 0-15 步长为 1\r\n>>> c\r\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\r\n\r\n\r\n>>> c = np.arange(15).reshape(3,5)  # 更改维度为 3*5\r\n>>> c\r\narray([[ 0,  1,  2,  3,  4],\r\n       [ 5,  6,  7,  8,  9],\r\n       [10, 11, 12, 13, 14]])\r\n	   \r\n	   \r\n>>> d = np.zeros((2,3))  # 生成元素全为 0 的 2*3 \r\n>>> d\r\narray([[ 0.,  0.,  0.],\r\n       [ 0.,  0.,  0.]])\r\n	   \r\n>>> e = np.ones((2,3,4)) # 生成元素全为 1 的三维矩阵\r\n>>> e\r\narray([[[ 1.,  1.,  1.,  1.],\r\n        [ 1.,  1.,  1.,  1.],\r\n        [ 1.,  1.,  1.,  1.]],\r\n\r\n       [[ 1.,  1.,  1.,  1.],\r\n        [ 1.,  1.,  1.,  1.],\r\n        [ 1.,  1.,  1.,  1.]]])\r\n		\r\n\r\n>>> f = np.linspace(1,10,3)  # 生成 1-10 含 3 个元素的等差数列\r\n>>> f\r\narray([  1. ,   5.5,  10. ])\r\n\r\n\r\n>>> g = np.logspace(1,10,3)  # 生成1-10 含 3 个元素的等比数列\r\n>>> g\r\narray([  1.00000000e+01,   3.16227766e+05,   1.00000000e+10])\r\n\r\n>>> s = \"hello\"         # 按照字符 ACSII 码生成矩阵\r\n>>> h = np.fromstring(s,dtype=np.int8)\r\n>>> h\r\narray([104, 101, 108, 108, 111], dtype=int8)\r\n\r\n# 自定义结构体矩阵\r\n>>> person = np.dtype({\'names\':[\'name\',\'age\'],\'formats\':[\'S32\',\'i\']})\r\n>>> person\r\ndtype([(\'name\', \'S32\'), (\'age\', \'<i4\')])\r\n>>> j = np.array([(\'zhang\',21)],dtype=person)\r\n>>> j\r\narray([(b\'zhang\', 21)],\r\n      dtype=[(\'name\', \'S32\'), (\'age\', \'<i4\')])\r\n```\r\n\r\n\r\n\r\n----------\r\n### ndarray 属性\r\n```\r\n>>> a = np.arange(15).reshape((3,5))\r\n>>> a\r\narray([[ 0,  1,  2,  3,  4],\r\n       [ 5,  6,  7,  8,  9],\r\n       [10, 11, 12, 13, 14]])\r\n>>> a.shape\r\n(3, 5)\r\n>>> a.ndim\r\n2\r\n>>> a.dtype\r\ndtype(\'int32\')\r\n>>> a.size\r\n15\r\n>>> type(a)\r\n<class \'numpy.ndarray\'>\r\n```\r\n\r\n\r\n----------\r\n### 基本运算\r\n记过运算之后，生成的结果会存放在一个新的 ndarray 对象中，原矩阵不会被改变，除非你重新对他赋值了\r\n```\r\n>>> a = np.array( [20,30,40,50] )\r\n>>> b = np.arange( 4 )\r\n>>> b\r\narray([0, 1, 2, 3])\r\n>>> c = a - b\r\n>>> c\r\narray([20, 29, 38, 47])\r\n>>> b**2\r\narray([0, 1, 4, 9], dtype=int32)\r\n>>> np.sin(a)\r\narray([ 0.91294525, -0.98803162,  0.74511316, -0.26237485])\r\n>>> a<35\r\narray([ True,  True, False, False], dtype=bool)\r\n```\r\n\r\n**注**：`a*b`表示的是矩阵对应元素的乘法，不是矩阵乘法，矩阵乘法使用  `dot` 来实现\r\n```\r\n>>> a = np.array([[1,1],[0,1]])\r\n>>> b = np.array([[2,0],[3,4]])\r\n>>> a * b\r\narray([[2, 0],\r\n       [0, 4]])\r\n	   \r\n>>> a.dot(b)\r\narray([[5, 4],\r\n       [3, 4]])\r\n	   \r\n>>> np.dot(a,b)\r\narray([[5, 4],\r\n       [3, 4]])\r\n```\r\n\r\n一些运算，比如`*=`，`+=`，会修改原来的矩阵而不是新增一个\r\n```\r\n>>> a\r\narray([[1, 1],\r\n       [0, 1]])\r\n	   \r\n>>> a *= 3\r\n\r\n>>> a\r\narray([[3, 3],\r\n       [0, 3]])\r\n```\r\n\r\n\r\n----------\r\n### Universal Functions\r\n基本方法如下所示，一般都可以见名知意\r\n```\r\nall, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, exp, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, sqrt, std, sum, trace, transpose, var, vdot, vectorize, where\r\n```\r\n\r\n\r\n----------\r\n### Shape Manipulation\r\n#### Changing the shape of an array\r\n下面的方法返回一个新的矩阵\r\n```\r\n>>> a = np.arange(15).reshape((3,5))\r\n>>> a\r\narray([[ 0,  1,  2,  3,  4],\r\n       [ 5,  6,  7,  8,  9],\r\n       [10, 11, 12, 13, 14]])\r\n\r\n>>> a.ravel()  # 将所有元素展成一维数组\r\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\r\n\r\n>>> a.T     # 反转\r\narray([[ 0,  5, 10],\r\n       [ 1,  6, 11],\r\n       [ 2,  7, 12],\r\n       [ 3,  8, 13],\r\n       [ 4,  9, 14]])\r\n	   \r\n>>> a.reshape(15,1)  # 重整\r\narray([[ 0],\r\n       [ 1],\r\n       [ 2],\r\n       [ 3],\r\n       [ 4],\r\n       [ 5],\r\n       [ 6],\r\n       [ 7],\r\n       [ 8],\r\n       [ 9],\r\n       [10],\r\n       [11],\r\n       [12],\r\n       [13],\r\n       [14]])\r\n	   \r\n>>> a   # 原矩阵不发生变化\r\narray([[ 0,  1,  2,  3,  4],\r\n       [ 5,  6,  7,  8,  9],\r\n       [10, 11, 12, 13, 14]])\r\n\r\n```\r\n\r\n#### 合并矩阵\r\n```python\r\nIn [2]: import numpy as np\r\n\r\nIn [3]: a = np.floor(10*np.random.random((2,2)))\r\n\r\nIn [4]: a\r\nOut[4]:\r\narray([[ 7.,  8.],\r\n       [ 7.,  5.]])\r\n\r\nIn [5]: b = np.floor(10*np.random.random((2,2)))\r\n\r\nIn [6]: b\r\nOut[6]:\r\narray([[ 5.,  0.],\r\n       [ 1.,  2.]])\r\n```\r\n\r\n**垂直合并**\r\n\r\n```\r\nIn [7]: np.vstack((a,b))   # 垂直合并\r\nOut[7]:\r\narray([[ 7.,  8.],\r\n       [ 7.,  5.],\r\n       [ 5.,  0.],\r\n       [ 1.,  2.]])\r\n```\r\n\r\n**水平合并**\r\n\r\n```\r\nIn [8]: np.hstack((a,b))\r\nOut[8]:\r\narray([[ 7.,  8.,  5.,  0.],\r\n       [ 7.,  5.,  1.,  2.]])\r\n```\r\n\r\n### 切分矩阵\r\n```\r\nIn [9]: a = np.floor(10*np.random.random((2,12)))\r\n\r\nIn [10]: a\r\nOut[10]:\r\narray([[ 8.,  2.,  2.,  5.,  4.,  4.,  8.,  0.,  1.,  6.,  4.,  2.],\r\n       [ 4.,  8.,  4.,  3.,  7.,  1.,  0.,  8.,  3.,  5.,  2.,  6.]])\r\n```\r\n\r\n**平均切割为 3 列**\r\n\r\n```\r\nIn [11]: np.hsplit(a,3)\r\nOut[11]:\r\n[array([[ 8.,  2.,  2.,  5.],\r\n        [ 4.,  8.,  4.,  3.]]), array([[ 4.,  4.,  8.,  0.],\r\n        [ 7.,  1.,  0.,  8.]]), array([[ 1.,  6.,  4.,  2.],\r\n        [ 3.,  5.,  2.,  6.]])]\r\n```\r\n\r\n**第 3、4 列为界限分开**\r\n\r\n```\r\nIn [12]: np.hsplit(a,(3,4))\r\nOut[12]:\r\n[array([[ 8.,  2.,  2.],[ 4.,  8.,  4.]]), \r\n  array([[ 5.],[ 3.]]), \r\n  array([[ 4.,  4.,  8.,  0.,  1.,  6.,  4.,  2.],\r\n        [ 7.,  1.,  0.,  8.,  3.,  5.,  2.,  6.]])]\r\n```\r\n\r\n----------\r\n### 总结\r\n上面所记录的差不多可以应付基本的使用了，简单查阅\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/343115-106.jpg\r\n  [2]: https://docs.scipy.org/doc/numpy-dev/user/quickstart.html', '30.jpg', '2017-12-28 12:55:00', '2019-04-07 10:35:03', 'p', '有一个捉迷藏社团，他们团长现在还没找到', 134, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (98, 'linux -- 常用命令含义', '----------\r\n\r\n![][1]\r\n\r\n<center><p>在那过去未来，时光两端，青史之外，记忆之前，我可曾，见过你</p></center>\r\n\r\n---------\r\n### 前言\r\n主要记录日常会使用到的命令，偏门的遇上再添加\r\n\r\n----------\r\n### 命令\r\n\r\n| 命令    |  原文   |\r\n| --- | --- |\r\n|   ls  | list    |\r\n|   cd   | change directory    |\r\n|   su  | switch user    |\r\n|   pwd  |  print work directory   |\r\n|   ps  |  process status   |\r\n|   df  |  disk free   |\r\n|   rmdir  |  remove directory   |\r\n|   rm  |  remove   |\r\n|   cat  | concatenate    |\r\n|   ln -s  |  link -soft   |\r\n|   mkdir  | make directory    |\r\n|   man  |  manual   |\r\n|   pwd | print working directory    |\r\n|   mv  |  move   |\r\n|   cp  |  copy   |\r\n|   chown  | change owner    |\r\n|   chmod  | change mode    |\r\n|   bin  | binaries    |\r\n|   etc  | etcetera    |\r\n|   lib  |  library   |\r\n|   proc  | processes    |\r\n|   sbin  | superuser binaries    |\r\n|   tmp  |  temporary   |\r\n|   usr  |  unix shared resources   |\r\n|   var  | variable    |\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/343210-106.jpg', '30_82di8lR.jpg', '2018-01-20 12:56:00', '2019-04-07 02:00:22', 'p', '在那过去未来，时光两端，青史之外，记忆之前，我可曾，见过你', 116, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (99, 'linux -- vim 配置', '----------\r\n\r\n![][1]\r\n\r\n<center><p>人间四月，暖到落泪</p></center>\r\n\r\n---------\r\n### 安装\r\n```\r\napt-get update\r\napt-get install vim\r\n```\r\n\r\n----------\r\n### 配置\r\n```\r\nvim /etc/vim/vimrc\r\n```\r\n\r\n```\r\n\" 去掉有关vi一致性模式，这个我也不知道是什么\r\nset nocompatible\r\n\r\n\"显示行号\r\nset number\r\n\r\n\"检测文件的类型\r\nfiletype on \r\n\r\n\"记录历史的行数\r\nset history=1000 \r\n\r\n\"背景使用黑色\r\nset background=dark \r\n\r\n\"vim使用自动对起，也就是把当前行的对起格式应用到下一行\r\nset autoindent\r\n\r\n\"依据上面的对起格式，智能的选择对起方式\r\nset smartindent\r\n\r\n\"设置tab键为4个空格\r\nset tabstop=4\r\n\r\n\"设置当行之间交错时使用4个空格\r\nset shiftwidth=4\r\n\r\n\"设置匹配模式，类似当输入一个左括号时会匹配相应的那个右括号\r\nset showmatch\r\n\r\n\"默认情况下，寻找匹配是高亮度显示的，该设置关闭高亮显示\r\nset nohls\r\n\r\n\"快速查找匹配\r\nset incsearch\r\n```\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/343210-106.jpg', '31.jpg', '2018-01-20 12:57:00', '2019-04-03 21:47:24', 'p', '人间四月，暖到落泪', 96, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (100, '﻿python -- pip 更新包', '----------\r\n\r\n![][1]\r\n\r\n<center><p>茕茕白兔，东走西顾。衣不如新，人不如故</p></center>\r\n\r\n---------\r\n### pip 更新 Python 包\r\n\r\npip是一个可执行的脚本文件，设置了环境变量就可以在终端(CMD)里面使用pip命令，而这个命令有一个--upgrade或者-U参数，英文的意思是升级，用来更新包\r\n\r\n```\r\npip install --upgrade packageName\r\npip install -U packageName\r\n```\r\n\r\n\r\n----------\r\n### pip 自我更新\r\n由于pip本身就是一个Python的包，那么用pip来自我更新也是可以的\r\n```\r\npip install --upgrade pip\r\npip install -U pip\r\n```\r\n\r\n或者用Python命令参数-m选项来安装也是可以的，-m的意思是用Python解释器来运行pip再更新\r\n```\r\npython -m pip install --upgrade pip\r\npython -m pip install -U pip\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/341018-106.jpg', '33.jpg', '2018-01-20 12:58:00', '2019-04-05 03:13:46', 'p', 'pip是一个可执行的脚本文件，设置了环境变量就可以在终端(CMD)里面使用pip命令', 110, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (101, '﻿typecho -- nginx 部署', '----------\r\n\r\n![][1]\r\n\r\n<center><p>我年华虚度，空有一身疲倦</p></center>\r\n\r\n\r\n----------\r\n#### 前言\r\nLAMP 环境不详细记录了，反正，从 apache 转过来是折腾了\r\n\r\n---------\r\n### 方法\r\n#### 安装 nginx\r\n```\r\napt-get install nginx\r\n```\r\n\r\n#### 配置 PHP 环境\r\n```\r\npt-get install php5-fpm php-apc\r\n```\r\n\r\n```\r\nservice php5-fpm restart\r\n```\r\n\r\n#### 默认虚拟主机失效\r\n```\r\nservice nginx stop\r\nunlink /etc/nginx/sites-enabled/default\r\n```\r\n\r\n#### 配置 nginx 主机\r\n```\r\nvim /etc/nginx/sites-available/typechosite\r\n```\r\n```\r\nserver {\r\n    listen 80;\r\n    root /var/www/html;\r\n    index index.php index.html index.htm;\r\n    \r\n    server_name pinsily.site;\r\n\r\n    location ~ \\.php$ {\r\n            fastcgi_pass unix:/var/run/php5-fpm.sock;\r\n            fastcgi_index index.php;\r\n            include fastcgi_params;\r\n    }\r\n}\r\n```\r\n\r\n```\r\n$ cd /etc/nginx/sites-enabled\r\n$ ln -s ../sites-available/typechodev.com ./\r\n$ nginx -t\r\n$ service nginx restart\r\n```\r\n\r\n\r\n----------\r\n### 伪静态调整\r\n**导致问题**：只能进入主页\r\n**解决**：修改 typechosite  中的 location\r\n**参考**：[http://docs.typecho.org/faq][2]\r\n```\r\nlocation ~ .*\\.php(\\/.*)*$ {\r\n    fastcgi_pass unix:/var/run/php5-fpm.sock;\r\n    fastcgi_index index.php;\r\n    include fastcgi_params;\r\n    \r\n    set $path_info \"\";\r\n    set $real_script_name $fastcgi_script_name;\r\n    if ($fastcgi_script_name ~ \"^(.+?\\.php)(/.+)$\") {\r\n    \r\n        fastcgi_param SCRIPT_FILENAME;\r\n        $document_root$real_script_name;\r\n        fastcgi_param SCRIPT_NAME $real_script_name;\r\n        fastcgi_param PATH_INFO $path_info;\r\n        \r\n    }\r\n\r\n```\r\n\r\n----------\r\n### 进入后台直接下载 admin 文件\r\n**参考**：[https://wildlyinaccurate.com/solving-502-bad-gateway-with-nginx-php-fpm/][3]\r\n```\r\nvim /etc/php5/fpm/pool.d/www.conf\r\n```\r\n将`listen = /var/run/php5-fpm.sock` 改成：\r\n```\r\nlisten = 127.0.0.1:9000\r\n```\r\n\r\n\r\n----------\r\n### 502 bad gateway\r\n如上 进入后台直接下载 admin 文件 参考\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%A7%86%E8%A7%89%20-%2015.jpg\r\n  [2]: http://docs.typecho.org/faq\r\n  [3]: https://wildlyinaccurate.com/solving-502-bad-gateway-with-nginx-php-fpm/', '34.jpg', '2018-01-28 12:59:00', '2019-04-10 06:00:56', 'p', 'LAMP 环境不详细记录了，反正，从 apache 转过来是折腾了', 242, 0, 0, 'pinsily', 11);
INSERT INTO `article` VALUES (102, 'python -- beautifulsoup 使用', '----------\r\n![][1]\r\n\r\n<center><p>一笔而就画出她的笑脸，此间，用了相濡以沫的十年</p></center>\r\n\r\n---------\r\n\r\n### 安装\r\n```\r\npip install beautifulsoup4\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n### 解析库\r\n1. python标准库    --- BeautifulSoup(markup,\'html.parser\')\r\n2. lxml HTML解析库 --- BeautifulSoup(markup,\'html.lxml\')\r\n3. lxml XML 解析库 --- BeautifulSoup(markup,\'html.pxml\')\r\n4. html5lib        --- BeautifulSoup(markup,\'html.html5lib\')\r\n\r\n\r\n----------\r\n\r\n\r\n### 基本使用\r\n```\r\nfrom bs4 import BeautifulSoup\r\n\r\nsoup = BeautifulSoup(html,\'lxml\')\r\n\r\nsoup.prettify()   # 格式化html，输出为排版好的格式\r\nsoup.title.string # title 标签内容\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n### 标签选择器\r\n#### 选择元素\r\n```\r\n# 只是返回第一个结果，不返回全部\r\nsoup.title\r\nsoup.head\r\nsoup.p\r\n```\r\n\r\n### 获取标签名称\r\n```\r\nsoup.title.name\r\n```\r\n\r\n### 获取属性名\r\n```\r\n# <p name=\"hello\"></p>\r\n\r\nsoup.p[\'name\']\r\n\r\n# output: hello\r\n```\r\n\r\n#### 获取标签内的内容\r\n```\r\nsoup.p.string\r\n```\r\n\r\n#### 嵌套选择\r\n```\r\nsoup.head.title.string\r\n```\r\n\r\n#### 子节点\r\n```\r\n# 返回列表\r\nsoup.p.contents\r\n\r\n# 返回迭代器\r\nsoup.p.children\r\n```\r\n\r\n#### 兄弟节点\r\n```\r\nsoup.a.next_siblings\r\nsoup.a.previous_siblings\r\n```\r\n\r\n-----\r\n\r\n### 标准选择器\r\n\r\n`**find_all(name,attrs,recursive,text,**kwargs)**`\r\n\r\n#### name\r\n```\r\n# 返回一个 list\r\nsoup.find_all(\'ull\')\r\n```\r\n \r\n#### attrs\r\n```\r\nsoup.find_all(attrs={\'id\':\'hello\'})\r\n\r\n# or class 需要加下划线 class_\r\n\r\nsoup.find_all(id=\'hello\')\r\n\r\n```\r\n\r\n#### text\r\n```\r\nsoup.find_all(text=\'name\')\r\n```\r\n\r\n`**find(name,attrs,recursive,text,**kargs)**`\r\n\r\n\r\n-----\r\n\r\n### CSS 选择器\r\n```\r\nsoup.select(\'.panel .panel-heading\')\r\n```\r\n\r\n#### 获取属性\r\n```\r\nfor ul in soup.select(\'ul\'):\r\n    print(url[\'id\'])\r\n```\r\n\r\n#### 获取内容\r\n```\r\nfor li in soup.select(\'li\'):\r\n    print(li.get_text())\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%AE%BE%E8%AE%A1%20-%2011.jpg', '35.jpg', '2018-02-05 13:01:00', '2019-04-07 22:53:55', 'p', '一笔而就画出她的笑脸，此间，用了相濡以沫的十年', 142, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (103, '﻿python -- 快速排序', '----------\r\n![][1]\r\n\r\n<center><p>生当复来归，死当长相思</p></center>\r\n\r\n---------\r\n### 说明\r\n快速排序使 用`分治法` 策略来把一个序列分为两个子序列\r\n步骤为：\r\n1. 从数列中挑出一个元素，称为\"基准\"（pivot），\r\n2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\r\n3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。\r\n\r\n\r\n----------\r\n### 伪代码\r\n#### 分区\r\n```\r\nfunction partition(a, left, right, pivotIndex)\r\n     pivotValue := a[pivotIndex]\r\n     swap(a[pivotIndex], a[right]) // 把 pivot 移到結尾\r\n     storeIndex := left\r\n     for i from left to right-1\r\n         if a[i] < pivotValue\r\n             swap(a[storeIndex], a[i])\r\n             storeIndex := storeIndex + 1\r\n     swap(a[right], a[storeIndex]) // 把 pivot 移到它最後的地方\r\n     return storeIndex // 返回 pivot 的最终位置\r\n```\r\n\r\n#### 快排\r\n```\r\nprocedure quicksort(a, left, right)\r\n    if right > left\r\n        select a pivot value a[pivotIndex]\r\n        pivotNewIndex := partition(a, left, right, pivotIndex)\r\n        quicksort(a, left, pivotNewIndex-1)\r\n        quicksort(a, pivotNewIndex+1, right)\r\n```\r\n\r\n----------\r\n### 分区算法详解\r\n拿 wiki 上的一张图解释\r\n<div style=\"width:50%; margin:0 auto;\" >\r\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Partition_example.svg/200px-Partition_example.svg.png\" alt=\"\" />\r\n</div>\r\n\r\n详解可查看这里 [http://bubkoo.com/2014/01/12/sort-algorithm/quick-sort/][3]\r\n\r\n----------\r\n### 动图 -- wiki\r\n\r\n<div style=\"width:50%; margin:0 auto;\" >\r\n <img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif\" alt=\"\"/>\r\n</div>\r\n----------\r\n### 代码实现\r\n```python\r\ndef quick(L,left,right):\r\n	if left<right:\r\n		print(L)\r\n		pivot = partition(L,left,right)\r\n		quick(L,left,pivot-1)\r\n		quick(L,pivot+1,right)\r\n	return\r\n\r\n\'\'\'\r\nleft,right 表示列表的起始坐标\r\n\'\'\'\r\ndef partition(L,left,right):\r\n	pivot = L[right]   # 最后一个元素做基准\r\n	storeIndex = left\r\n	for i in range(left,right):\r\n		if L[i] < pivot:\r\n			L[storeIndex],L[i] = L[i],L[storeIndex]\r\n			storeIndex += 1\r\n\r\n	L[storeIndex],L[right] = L[right],L[storeIndex]\r\n	return storeIndex\r\n\r\nif __name__ == \'__main__\':\r\n	L = [23,42,2,34,34,322,5,43,2,3,13,56,32]\r\n	L = quick(L,0,len(L)-1)\r\n	#print(L)\r\n\r\n```\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%AE%BE%E8%AE%A1%20-%2026.jpg\r\n  [2]: https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Partition_example.svg/200px-Partition_example.svg.png\r\n  [3]: http://bubkoo.com/2014/01/12/sort-algorithm/quick-sort/\r\n  [4]: https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif', '36.jpg', '2018-02-06 13:03:00', '2019-04-05 17:38:26', 'p', '快速排序使 用`分治法` 策略来把一个序列分为两个子序列', 118, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (104, '﻿python -- 选择排序', '----------\r\n![][1]\r\n\r\n<center><p>绝不能和梦中的人说话,那是与黑暗的国度对话</p></center>\r\n\r\n---------\r\n### 简单说明 -- Wiki\r\n选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕\r\n\r\n----------\r\n### 动态图 -- wiki\r\n<div style=\"margin:0 auto; width:50%;\">\r\n    <img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif\" alt=\"\" />\r\n</div>\r\n</br>\r\n<div style=\"margin:0 auto; width:50%;\">\r\n    <img src=\"https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif\" alt=\"\" />\r\n</div>\r\n\r\n\r\n----------\r\n### 算法\r\n```python\r\ndef selection(L):\r\n	print(L)\r\n	for i in range(len(L)-1):\r\n		mins = L[i]\r\n		minIndex = i\r\n		for j in range(i+1,len(L)):\r\n			if L[j]<L[minIndex]:\r\n				mins = L[j]\r\n				minIndex = j\r\n\r\n		L[i],L[minIndex] = L[minIndex],L[i]\r\n		print(L)\r\n\r\n	return L\r\n\r\nif __name__ == \'__main__\':\r\n	L = [23,42,2,34,34,322,5]\r\n	L = selection(L)\r\n	print(L)\r\n\r\n```\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%AE%BE%E8%AE%A1%20-%2033.jpg', '38.jpg', '2018-02-11 13:04:00', '2019-04-01 00:55:33', 'p', '选择排序（Selection sort）是一种简单直观的排序算法', 108, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (105, '﻿uwsgi -- error while loading shared libraries: libpcre.so.1', '----------\r\n![][1]\r\n\r\n<center><p>你的梦想就是我的梦想</p></center>\r\n\r\n---------\r\n### 问题\r\n服务器使用 uwsgi 部署 Django，当执行 uwsgi 相关命令的时候出现了以下的错误\r\n```\r\nuwsgi: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory\r\n```\r\n\r\n\r\n----------\r\n### 解决\r\n原答案：[https://geekflare.com/nginx-error-while-loading-shared-libraries-libpcre-so-1/][2]\r\n\r\n有点意思的是，这个是 nginx 的错误解决，不过好像涉及的原理是一样的\r\n\r\n1. 找到 libpcre.so.1 文件的位置\r\n```\r\n$ find / -name libpcre.so.1\r\n/root/anaconda3/pkgs/pcre-8.41-hc27e229_1/lib/libpcre.so.1\r\n/root/anaconda3/lib/libpcre.so.1\r\n```\r\n\r\n2. 添加到环境变量 `LD_LIBRARY_PATH` 中\r\n```\r\n$ LD_LIBRARY_PATH=/root/anaconda3/lib:$LD_LIBRARY_PATH\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%AE%BE%E8%AE%A1%20-%2033.jpg\r\n  [2]: https://geekflare.com/nginx-error-while-loading-shared-libraries-libpcre-so-1/', '39.jpg', '2018-02-17 13:05:00', '2019-04-08 12:49:55', 'p', '服务器使用 uwsgi 部署 Django，当执行 uwsgi 相关命令的时候出现了以下的错误', 468, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (107, '﻿django -- js 交互', '----------\r\n\r\n![][1]\r\n\r\n<center><p>她走了，一位风一般的佳人</p></center>\r\n\r\n---------\r\n### 前言\r\ndjango 与 js 的交互主要有两种:\r\n- js 不需要处理\r\n- js 需要处理\r\n\r\n----------\r\n### js 不需要处理\r\n直接使用 django 模板传递\r\n\r\n\r\n----------\r\n### js 需要处理\r\n直接传递使用的话会报错\r\n```\r\nUncaught SyntaxError: Unexpected token ILLEGAL\r\n```\r\n\r\n#### 解决方法\r\n- 视图函数中的字典或列表要用 json.dumps() 处理\r\n- 在模板上要加 safe 过滤器\r\n\r\nviews.py\r\n```\r\n# -*- coding: utf-8 -*-\r\n \r\nfrom __future__ import unicode_literals\r\n \r\nimport json\r\nfrom django.shortcuts import render\r\n \r\ndef home(request):\r\n    List = [\'one\', \'two\']\r\n    return render(request, \'home.html\', {\r\n            \'List\': json.dumps(List)\r\n        })\r\n```\r\n\r\nhome.html(部分)\r\n```\r\n<script type=\"text/javascript\">\r\n    var List = {{ List|safe }};\r\n</script>\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E5%8A%A8%E6%BC%AB%20-%208.jpg', '41.jpg', '2018-02-18 13:07:00', '2019-04-03 21:03:46', 'p', 'django 与 js 的交互主要有两种', 120, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (108, '﻿django -- 模型操作', '----------\r\n\r\n![][1]\r\n\r\n<center><p>生者为过客，死者为归人。天地一逆旅，同悲万古尘</p></center>\r\n\r\n---------\r\n### 主要内容\r\n- 增加内容\r\n- 查询内容\r\n- 更新内容\r\n- 删除内容\r\n- 排序\r\n\r\n\r\n**注**：关于模型的操作一般在 app 里面的 view.py 中，当然也可以在命令行中，原理是一样的,这里演示命令行的\r\n\r\nDjango提供了丰富的API，称为 QuerySet，我们所使用的，都是其对象\r\n\r\n----------\r\n### 模型\r\n在 app 下的 models.py 中生成\r\n```\r\nclass UserModel(models.Model):\r\n	username = models.CharField(max_length=50, verbose_name=u\"用户名\")\r\n	password = models.CharField(max_length=20,verbose_name=u\"密码\")\r\n```\r\n\r\n\r\n----------\r\n### 使用 django 命令行\r\n```\r\npython manage.py shell\r\n```\r\n\r\n----------\r\n### 导入\r\n```\r\nfrom helloapp import models\r\n```\r\n\r\n**注**：如果没有使用 django shell 而直接使用 python 解释器导入，可能会报错\r\n```\r\ndjango.core.exceptions.AppRegistryNotReady: Apps aren\'t loaded yet.\r\n```\r\n\r\n\r\n\r\n----------\r\n### 增加内容\r\n```\r\nIn [3]: models.UserModel.objects.create(username=\"pinsily\",password=\"123456\")\r\nOut[3]: <UserModel: UserModel object (1)>\r\n```\r\n\r\n\r\n----------\r\n### 获取对象\r\n#### 单个对象\r\n```\r\nIn [2]: models.UserModel.objects.get(username=\"pinsily\")\r\nOut[2]: <UserModel: UserModel object (1)>\r\n```\r\n如果想丰富查询输出信息的话可以在 models 中增加信息\r\n```\r\nclass UserModel(models.Model):\r\n	username = models.CharField(max_length=50, verbose_name=u\"用户名\")\r\n	password = models.CharField(max_length=20,verbose_name=u\"密码\")\r\n\r\n	def __str__(self):\r\n		return self.username\r\n```\r\n需要重新加载 shell\r\n```\r\nIn [3]: models.UserModel.objects.get(username=\"pinsily\")\r\nOut[3]: <UserModel: pinsily>\r\n```\r\n\r\n#### 获取所有对象\r\n```\r\nIn [4]: models.UserModel.objects.all()\r\nOut[4]: <QuerySet [<UserModel: pinsily>]>\r\n```\r\n返回一个元素为 QuerySet对象的列表，所以是可以使用切片的（数据比较多是省内存）\r\n\r\n#### 筛选对象\r\n##### 符合条件的\r\n```\r\nIn [8]: models.UserModel.objects.filter(password=\"123456\")\r\nOut[8]: <QuerySet [<UserModel: pinsily>]>\r\n```\r\n\r\nfilter 的其他参数\r\n- username__iexact=\"abc\": 名字不区分大小写\r\n- username__contains=\"abc\" ： 名字包含 abc\r\n- username__icontains=\"abc\" : 不区分大小写\r\n- username__regex=\"^abc\" : 正则匹配\r\n- username__iregex=\"^abc\" : 不区分大小写\r\n\r\n##### 排除该条件的\r\n```\r\nIn [15]: models.UserModel.objects.exclude(username=\"peng\")\r\nOut[15]: <QuerySet [<UserModel: pinsily>]>\r\n```\r\n\r\nfilter 的参数一样使用\r\n\r\n\r\n#### get 和 filter 的区别\r\n- get 返回的结果必须存在且具有唯一性，当结果不存在或存在多条重复数据时，会报错\r\n- filter 返回的结果是列表，可以重复，可不存在（空列表）\r\n- filter 有缓存数据的功能\r\n\r\n----------\r\n### 更新数据\r\n#### 批量更新：all,filter 等\r\n```\r\nIn [10]: models.UserModel.objects.filter(username=\"pinsily\").update(username=\"peng\")\r\nOut[10]: 1\r\n```\r\n\r\n#### 单个更新\r\n```\r\nIn [11]: user = models.UserModel.objects.get(username=\"peng\")\r\n\r\nIn [12]: user.username = \"pinsily\"\r\n\r\nIn [13]: user.save()  # 不保存则不会生效\r\n```\r\n\r\n\r\n----------\r\n#### 删除\r\n```\r\nIn [16]: models.UserModel.objects.get(username=\"pinsily\").delete()\r\nOut[16]: (1, {\'helloapp.UserModel\': 1})\r\n```\r\n\r\n\r\n----------\r\n### 排序\r\n- 生成对象\r\n```\r\nIn [18]: models.UserModel.objects.create(username=\"peng\",password=\"123456\")\r\nOut[18]: <UserModel: peng>\r\n\r\nIn [19]: models.UserModel.objects.create(username=\"pinsily\",password=\"123456\")\r\nOut[19]: <UserModel: pinsily>\r\n```\r\n\r\n- 正反排序\r\n```\r\nIn [21]: models.UserModel.objects.all().order_by(\"username\")\r\nOut[21]: <QuerySet [<UserModel: peng>, <UserModel: pinsily>]>\r\n\r\nIn [22]: models.UserModel.objects.all().order_by(\"-username\")\r\nOut[22]: <QuerySet [<UserModel: pinsily>, <UserModel: peng>]>\r\n```\r\n\r\n\r\n----------\r\n### 参考\r\n[https://code.ziqiangxuetang.com/django/django-models.html][2]\r\n\r\n[https://docs.djangoproject.com/en/2.0/topics/db/models/][3]\r\n\r\n[老王python:django model的get和filter方法的区别][4]\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E5%8A%A8%E6%BC%AB%20-%2015.jpg\r\n  [2]: https://code.ziqiangxuetang.com/django/django-models.html\r\n  [3]: https://docs.djangoproject.com/en/2.0/topics/db/models/\r\n  [4]: http://www.cnpythoner.com/post/77.html', '42.jpg', '2018-02-18 13:09:00', '2019-04-05 17:38:29', 'p', '生者为过客，死者为归人。天地一逆旅，同悲万古尘', 220, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (109, 'django -- static 静态文件', '----------\r\n\r\n![][1]\r\n\r\n<center><p>我们确实有如是的优点，但也要隐藏几分，这个叫做涵养</p></center>\r\n\r\n\r\n----------\r\n### 简单说明\r\n关于静态文件的保存使用，应该保存下来的目录习惯，构建项目时将文件放到 app 中，css 文件目录为 `appname/static/appname/style.css`，图片等目录为 `apname/static/appname/image/1.jpg`，之所以加多一层 `appname` 目录，是因为防止多个 app 中存在相同名称的文件，导致出错\r\n\r\n当项目部署时，将所有文件搜集到项目根目录下的 `static/` 中\r\n\r\n---------\r\n### app 下配置\r\n1. 确保 app 在  INSTALLED_APPS 中\r\n2. `settings.py`\r\n```python\r\nSTATIC_URL = \'/static/\'\r\n```\r\n3. 在 app 下新建 static 文件夹并新建相应文件\r\n4. 引用`/static/appname/style.css`\r\n```\r\n{% load static %}\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"{% static \"appname/style.css\" %}\">\r\n```\r\n\r\n\r\n\r\n----------\r\n### 根目录下\r\n1. `settings.py`\r\n```\r\nimport os \r\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\r\nSTATICFILES_DIRS = [\r\n    os.path.join(BASE_DIR, \"static\")\r\n]\r\n```\r\n\r\n2. 在根目录下新建 static 文件夹并新建文件\r\n3. 引用 `/static/css/style.css`\r\n```\r\n{% load static %}\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"{% static \"css/style.css\" %}\">\r\n```\r\n\r\n\r\n----------\r\n### 优先级设置\r\n```python\r\nSTATICFILES_FINDERS = (\r\n    \"django.contrib.staticfiles.finders.FileSystemFinder\",\r\n    \"django.contrib.staticfiles.finders.AppDirectoriesFinder\"\r\n)\r\n```\r\n\r\n\r\n----------\r\n### 部署使用\r\n1. 设置 `static_root`\r\n```python\r\nSTATIC_ROOT = os.path.join(BASE_DIR, \'collected_static\')\r\n```\r\n\r\n2. 收集静态文件\r\n```\r\npython manage.py collectstatic\r\n```\r\n3. nginx 部署\r\n```\r\nlocation /static {\r\n    alias /path/to/project/collected_static;\r\n}\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/%E8%A7%86%E8%A7%89%20-%201.jpg', '43.jpg', '2018-02-19 13:10:00', '2019-04-07 01:09:13', 'p', '关于静态文件的保存使用，应该保存下来的目录习惯，构建项目时将文件放到 app 中', 138, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (110, '﻿nodejs -- 淘宝 npm 镜像', '2018-03-09\r\n\r\n--------\r\n![][1]\r\n\r\n<p><center>等待，不是为了你能回来，而是找个借口不离开 ——九ちのセカィ</center></p>\r\n\r\n----------\r\n### 安装\r\n```\r\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\r\n```\r\n\r\n### 使用\r\n```\r\n$ cnpm install [packagename]\r\n```\r\n----\r\n\r\n [1]: http://cdn.pinsily.site/%E5%B0%8F%E4%B9%A6%E5%8C%A0/WallpaperStudio10-84766.jpg', '50.jpg', '2018-03-09 13:12:00', '2019-04-03 13:47:31', 'p', '等待，不是为了你能回来，而是找个借口不离开', 142, 0, 0, 'pinsily', 16);
INSERT INTO `article` VALUES (111, '﻿django -- favicon.ico 配置', '-----\r\n\r\n![][1]\r\n\r\n<p><center>如同那时的爱情，让人期待,也充满着无奈</center></p>\r\n\r\n\r\n-------\r\n### 前言\r\n在使用 django 做测试的时候，在每次相应请求时，都打印一个无用日志\r\n```\r\nNot Found: /favicon.ico\r\n[12/Mar/2018 17:07:40] \"GET /favicon.ico HTTP/1.1\" 404 2339\r\n```\r\n\r\n看不顺眼就找方法解决它了\r\n\r\n\r\n----------\r\n### 方法\r\n> 原答案：[https://stackoverflow.com/questions/11173631/django-favicon-ico-in-development][2]\r\n\r\n- 文件夹及存放文件的位置可以随意，配置的时候对上就行了\r\n\r\n- 根目录下新建 media，将 ico 图标命名为 favicon.ico 放到此目录下\r\n\r\n- website/website/urls.py\r\n```\r\nfrom django.conf import settings\r\nfrom django.conf.urls.static import static\r\n……\r\nif settings.DEBUG:\r\n    urlpatterns += static(r\'/favicon.ico\', document_root=\'media/favicon.ico\')\r\n```\r\n\r\n**注**：在网上找了很多方法，试了一遍只有这种成功了，可能每个人的情况都会不一样\r\n\r\n\r\n-------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-84766.jpg\r\n  [2]: https://stackoverflow.com/questions/11173631/django-favicon-ico-in-development', '45.jpg', '2018-03-12 13:13:00', '2019-04-06 19:05:06', 'p', '在使用 django 做测试的时候，在每次相应请求时，都打印一个无用日志', 160, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (112, '﻿django -- Abstract User Error', '---------\r\n\r\n\r\n![][1]\r\n\r\n<p><center>回头皆幻景，对面知是谁。 ——牡丹亭</center></p>\r\n\r\n------\r\n### 问题\r\n在使用 AbstractUser 扩展用户的时候，数据库迁移时出现了一下错误\r\n```\r\nReverse accessor for \'User.groups\' clashes with reverse accessor for \'UserModel.groups\'.\r\nHINT: Add or change a related_name argument to the definition for \'User.groups\' or \'UserModel.groups\'.\r\n```\r\n\r\n\r\n----------\r\n### 解决\r\n在 settings.py 中增加相关变量，让 django 知道那个是用户管理 model\r\n```\r\nAUTH_USER_MODEL = \'user_admin.UserModel\'\r\n```\r\n\r\n`user_admin` 为 app 名字， `UserModel` 为所用用户 model\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/10-85058.jpg', '46.jpg', '2018-02-06 13:14:00', '2019-04-07 11:19:01', 'p', '在使用 AbstractUser 扩展用户的时候，数据库迁移时出现了一下错误', 164, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (113, 'hadoop -- 安装配置', '---\r\n\r\n![](http://cdn.pinsily.site/6.jpg)\r\n\r\n<p><center>太想伸手摘取星星的人，常常忘记脚下的鲜花</center></p>\r\n\r\n\r\n----------\r\n### 环境说明\r\n- Ubuntu 16.04\r\n- hadoop 2.9.1\r\n- jdk 1.8\r\n\r\n------\r\n### 安装 java\r\n1. 官网本地下载jdk安装包，解压到opt/中，改名为java\r\n```\r\n$ wget --no-check-certificate --no-cookies --header \"Cookie: oraclelicense=accept-securebackup-cookie\" http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz\r\n\r\n$ cp jdk-8u181-linux-x64.tar.gz /opt\r\n$ tar -zxvf jdk-8u181-linux-x64.tar.gz\r\n$ sudo mv jdk1.8.0_181/ java\r\n\r\n```\r\n\r\n2. 增加环境变量\r\n```\r\n$ vim ~/.bashrc\r\n\r\n# java home\r\nexport JAVA_HOME=/opt/java\r\nexport JRE_HOME=/opt/java/jre\r\nexport CLASSPATH=.:/opt/java/lib:/opt/java/jre/lib\r\nexport PATH=/opt/java/bin:$PATH\r\n```\r\n\r\n> 注：有些奇怪的是，启动hadoop的时候读取不了这个 JAVA_HOME，需要在 hadoop-env.sh 中配置绝对路径才行，这个下面再记录\r\n\r\n3. 测试\r\n```\r\n$ java\r\n$ javac\r\n```\r\n\r\n![](http://cdn.pinsily.site/1532354991714.png)\r\n\r\n\r\n\r\n\r\n----------\r\n### 安装 hadoop\r\n1. 下载 hadoop\r\n```\r\n$ wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.9.1/hadoop-2.9.1.tar.gz\r\n```\r\n\r\n2. 一样解压到/opt中改名为hadoop\r\n```\r\n$ cp hadoop-2.9.1.tar.gz /opt\r\n$ tar -zxvf hadoop-2.9.1.tar.gz\r\n$ sudo mv hadoop-2.9.1/ hadoop\r\n```\r\n\r\n3. 配置环境变量\r\n```\r\n$ vim ~/.bashrc\r\n\r\n# hadoop\r\nexport HADOOP_HOME=/opt/hadoop\r\nexport PATH=$PATH:/opt/hadoop/bin\r\nexport PATH=$PATH:/opt/hadoop/sbin\r\nexport HADOOP_MAPRED_HOME=/opt/hadoop\r\nexport HADOOP_COMMON_HOME=/opt/hadoop\r\nexport HADOOP_HDFS_HOME=/opt/hadoop\r\nexport YARN_HOME=/opt/hadoop\r\nexport HADOOP_COMMON_LIB_NATIVE_DIR=/opt/hadoop/lib/native\r\nexport HADOOP_OPTS=\"-Djava.library.path=/opt/hadoop/lib\"\r\n```\r\n\r\n4. 顺带修复启动时的一个warning\r\n```\r\nUnable to load native-hadoop library for your platform” \r\n```\r\n\r\n```\r\n$ vim /opt/hadoop/etc/hadoop/hadoop-env.sh\r\n\r\nexport HADOOP_OPTS=\"$HADOOP_OPTS -Djava.library.path=/opt/hadoop/lib/native\"\r\n\r\nexport HADOOP_COMMON_LIB_NATIVE_DIR=\"/opt/hadoop/lib/native/\"\r\n\r\n```\r\n\r\n\r\n----------\r\n### ssh 免密登录\r\n\r\nubuntu 只是默认安装了 openssh-client，但是没有安装openssh-server\r\n```\r\n$ sudo apt-get install -y openssh-server\r\n```\r\n\r\n生成公约和密钥,直接回车，不设置密码\r\n```\r\n$ ssh-keygen  -t rsa\r\n```\r\n\r\n![](http://cdn.pinsily.site/1531922832290.png)\r\n\r\n执行完之后默认会在用户的根目录下(/home/username)生成 .ssh 文件夹，公钥和秘钥就在其中\r\n\r\n把公用密匙添加到authorized_keys 文件\r\n```\r\n$ cd /home/pinsily/.ssh\r\n$ cat id_rsa.pub >> authorized_keys\r\n```\r\n\r\n最重要的一步就是设置权限了，没有权限的话登录仍旧需要输入该用户的密码\r\n```\r\n$ chmod 600 id_rsa\r\n$ chmod 755 /home/pinsily/.ssh\r\n```\r\n\r\n设置完这些就可以登录了\r\n```\r\n$ ssh pinsily@localhost\r\n```\r\n\r\n![](http://cdn.pinsily.site/1531923155595.png)\r\n\r\n----------\r\n### 伪分布环境搭建\r\n\r\n1. 配置文件\r\n> hadoop 的配置文件位于 `/opt/hadoop/etc/hadoop` 下\r\n\r\n```xml\r\n$ vim core-site.xml\r\n\r\n<configuration>\r\n\r\n  <property>\r\n    <name>fs.defaultFS</name>\r\n    <value>hdfs://localhost:9000</value>\r\n  </property>\r\n\r\n  <property>\r\n    <name>hadoop.tmp.dir</name>\r\n    <value>file:/opt/hadoop/tmp</value>\r\n  </property>\r\n\r\n</configuration>\r\n\r\n```\r\n\r\n\r\n```xml\r\n$ vim hdfs-site.xml\r\n\r\n<configuration>\r\n\r\n  <!-- 没有这一个的话namenode会启动不了，官网没有这个  -->\r\n  <property>\r\n    <name>dfs.replication</name>\r\n    <value>1</value>\r\n  </property>\r\n\r\n  <property>\r\n    <name>dfs.namenode.name.dir</name>\r\n    <value>file:/opt/hadoop/tmp/dfs/name</value>\r\n  </property>\r\n\r\n  <property>\r\n    <name>dfs.datanode.data.dir</name>\r\n    <value>file:/opt/hadoop/tmp/dfs/data</value>\r\n  </property>\r\n\r\n\r\n\r\n</configuration>\r\n\r\n\r\n```\r\n\r\n```xml\r\n$ cp mapred-site.xml.template mapred-site.xml\r\n$ vim mapred-site.xml\r\n\r\n\r\n<configuration>\r\n\r\n  <property>\r\n    <name>mapreduce.framework.name</name>\r\n    <value>yarn</value>\r\n  </property>\r\n\r\n\r\n\r\n</configuration>\r\n\r\n\r\n```\r\n\r\n\r\n```xml\r\n$ vim yarn-site.xml\r\n\r\n<configuration>\r\n\r\n<!-- Site specific YARN configuration properties -->\r\n  <property>\r\n    <name>yarn.resourcemanager.address</name>\r\n    <value>localhost</value>\r\n  </property>\r\n\r\n  <property>\r\n    <name>yarn.nodemanager.aux-services</name>\r\n    <value>mapreduce_shuffle</value>\r\n  </property>\r\n\r\n\r\n\r\n</configuration>\r\n```\r\n\r\n2. 格式化 namenode\r\n```shell\r\n$ hadoop namenode -format\r\n```\r\n\r\n3. 启动\r\n```\r\n$ start-all.sh\r\n```\r\n\r\n![](http://cdn.pinsily.site/1532357367312.png)\r\n\r\n> 注：如果提示找不到 java 的话, 将 java 的绝对路径修改添加到 hadoop-env.sh 中\r\n\r\n4. 检查启动情况\r\n```\r\n$ jps\r\n```\r\n\r\n![enter description here](http://cdn.pinsily.site/1532357412626.png)\r\n\r\n\r\n5. 不适用的时候可以关掉\r\n```\r\n$ stop-all.sh\r\n```\r\n\r\n----------\r\n### 总结\r\n断断续续摸索了很多次这样的环境配置，没有刚入门时的到处坑，配置文件的完整度，算是好过了官网了吧，汗颜~~', '51.jpg', '2018-07-23 15:21:00', '2019-04-07 05:40:15', 'p', '太想伸手摘取星星的人，常常忘记脚下的鲜花', 262, 0, 0, 'pinsily', 18);
INSERT INTO `article` VALUES (114, 'hadoop -- 生态环境(ecosystem)', '---\r\n\r\n![](http://cdn.pinsily.site/3.jpg)\r\n\r\n<p><center>我们一路奋战，不是为了改变世界，而是为了不让世界改变我们 - 熔炉</center></p>\r\n\r\n\r\n\r\n----------\r\n### 参考翻译\r\n> [https://www.edureka.co/blog/hadoop-ecosystem][1]\r\n\r\n\r\n----------\r\n### 生态环境\r\n\r\n![][2]\r\n\r\n\r\n----------\r\n### HDFS\r\nHDFS 的全称为 Hadoop Distributed File System,即分布式文件系统，HDFS 是 Hadoop 的核心组件，其设计的本质是让大量不同类型的数据集存储在成千上万的机器上，但是 HDFS 会将这些数据集抽象成让你看起来就是同一个文件单元，也就是说，当你访问 HDFS 某目录下的某个文件时，其数据可能来自不同的地方\r\n\r\nHDFS 有两个核心组件，NameNode 和 DataNode：\r\n    1. NameNode 以一种类似表的结构存储一种元数据(metedata)类型,，每条元数据记录描述了一个 dataNode 的相关信息\r\n    2. 另一方面来说，DataNode 就是存储真实数据的场所(分布式环境中普通的存储硬件)，多个 dataNode 由一个 NameNode 存储信息\r\n    \r\n总的来说，我们操作数据总是与 NameNode 进行沟通，NameNode 会自动选择哪些 dataNode 进行数据的写入或者读取\r\n    \r\n![][3]\r\n\r\n\r\n----------\r\n### YARN\r\n类比 CPU 于计算机，YARN 是 hadoop 生态环境中资源分布和任务调度的角色扮演，YARN 只是任务调度的其中一种框架，它使 ecosystem 中的各个工具能够井然有序地在同一个集群环境中合作\r\n\r\n同样，YARN 也有两个核心组件：ResourceManager 和 NodeManager\r\n    1. 相当于 NameNode，ResourceManager 任务调度中处于主控制程序的位置，其接受我们的请求再根据请求的情况分配到不同的NodeManager中，即真正执行任务(task)的地方\r\n    2. NodeManager 安装在每一个 DataNode 上，在这里执行相应的任务(task)\r\n\r\n除此之外，ResourceManager 由两个组件构成：Schedulers 和 ApplicationsManager\r\n    1. Schedulers 会根据请求的情况，执行相应的调度算法和分配资源\r\n    2. ApplicationsManager 会根据所接受到的工作情况和环境情况来执行应用指定的 ApplicationMaster 和监控程序\r\n    \r\n\r\n> While ApplicationsManager accepts the job submission, negotiates to containers (i.e. the Data node environment where process executes) for executing the application specific ApplicationMaster and monitoring the progress.\r\n\r\n\r\n----------\r\n### MAPREDUCE\r\n可以简单地理解为，MapReduce 是 Hadoop 的中心思想，也是我们平时所接触的分而治之的分治法思想，hadoop 为什么能够同时处理不同 DataNode 中数据的原因就在于此\r\n\r\n\r\n![][4]\r\n\r\n----------\r\n### Pig\r\nPig 是一个使用类SQL语言 pig latin 和其运行环境 pig runtime 进行大数据处理分析的平台，其提供了比 Java 等语言更高层次的操作和编程接口\r\n\r\n![][5]\r\n\r\n\r\n![][6]\r\n\r\n----------\r\n### Hive\r\nHive 是类似 SQL 的数据仓库，一样可以对数据进行增删查改，区别在于 Hive 在 hadoop 集群环境下进行，这也为只会 SQL 的非程序员支持 Hadoop 的操作，facebook 很牛逼的说\r\n\r\n同样，Hive 也有自己的 command line 以及供 Java 连接使用的 JDBC/ODBC driver\r\n\r\n另外，Hive 还有高扩展性和伸缩性，对方法进行重写等操作\r\n\r\n![][7]\r\n\r\n----------\r\n### MAHOUT\r\n\r\n![][8]\r\n\r\nMAHOUT 为机器学习提供了连接 Hadoop 的环境，使其更够在 hadoop 下建立可伸缩性的机器学习应用\r\n\r\n对于机器学习来说，MAHOUT上可进行协同过滤(collaborative filtering)，聚类(clustering )和分类(classification)的机器学习算法，或许还有个处于模糊边界的频繁项集(frequent item)\r\n\r\n\r\n----------\r\n### Spark\r\nspark 是基于 scala 语言的框架平台，相对于 hadoop 更注重于存储， spark 天生就是为了实时处理大数据，而且还提供了更多的语言接口，除了原生语言之外，R, SQL, Python, Scala, Java 等都可以通过其进行大数据处理计算\r\n\r\n![][9]\r\n\r\n\r\n----------\r\n### HBASE\r\n- HBASE 是一个开源的非关系分布式数据库(NoSQL)\r\n- 支持各种类型的数据，这也是其能够在Hadoop ecosystem中能够处理一切\r\n- Hbase由java开发但能够通过 REST, Avro and Thrift 等 API 使用\r\n- \r\n\r\n----------\r\n\r\n\r\n  [1]: https://www.edureka.co/blog/hadoop-ecosystem\r\n  [2]: http://cdn.pinsily.site/1531029676618.jpg\r\n  [3]: http://cdn.pinsily.site/1531031620854.jpg\r\n  [4]: http://cdn.pinsily.site/1531034180013.jpg\r\n  [5]: http://cdn.pinsily.site/1531034670991.jpg\r\n  [6]: http://cdn.pinsily.site/1531034387351.jpg\r\n  [7]: http://cdn.pinsily.site/1531040784265.jpg\r\n  [8]: http://cdn.pinsily.site/1531137258449.jpg\r\n  [9]: http://cdn.pinsily.site/1531140168585.jpg', '52.png', '2018-07-15 15:24:00', '2019-04-06 22:24:54', 'p', '我们一路奋战，不是为了改变世界，而是为了不让世界改变我们', 314, 0, 0, 'pinsily', 18);
INSERT INTO `article` VALUES (115, 'hadoop -- HDFS(1)', '---\r\n\r\n![](http://cdn.pinsily.site/5.jpg)\r\n\r\n<p><center>温柔解救不了这个世界 - 罪恶王冠</center></p>\r\n\r\n\r\n------\r\n### 参考翻译\r\n> [https://www.edureka.co/blog/hdfs-tutorial][1]\r\n\r\n\r\n----------\r\n### DFS or Distributed File System\r\n\r\n在说 HDFS 之前，先说说 DFS,即分布式文件系统\r\n\r\n简单来说，分布式文件系统在于能够让你将一份很大的文件或者文件夹存储在多台电脑或者服务器上面，从根本上来讲，这就像是 window 的 NTFS(New Technology File System) 和 mac 的 HFS(Hierarchical File System),不同的只是 DFS 存储数据不再局限于单台机器，但是对于用户来说，操作文件在这三者上是没有很大区别的,虽然你访问某一目录下的文件在DFS中可能来自几台不同的机器上\r\n\r\n----------\r\n### What is HDFS\r\n因此，可以顾名思义地理解为，HDFS 不过是适用于 Hadoop 的 DFS 罢了，只是在 DFS 的基础上，继续完善适配 Hadoop， 比如上面所说的多台电脑或服务器，在 HDFS 上被称为了节点(Node)或集群(cluster)\r\n\r\n所以，总的来说，DFS 的进步意义在于每一台机器都能够贡献他们的微小空间来实现存储大量的任意类型的数据\r\n\r\n\r\n----------\r\n### Advantages Of HDFS\r\n1. 分布式存储\r\n\r\n![][2]\r\n\r\n\r\n就像上面所说的，利用 HDFS 可以将 10T 的数据存储在 10 台存储只有 1T 的机器上，但是用户使用感觉只是在单台电脑上操作，可以说，HDFS 是大数据不在局限于物理边界\r\n\r\n2. 分布式和并行计算(Distributed & Parallel Computation)\r\n\r\n![][3]\r\n\r\n很显然，既然单独的机器可以贡献存储，自然也可以贡献计算资源来共同完成任务工作，虽然上面图片所说的结果是将单独处理的时间平均分为10份，但是对于计算时间的缩减，Hadoop 是真的起到了不可估量的价值\r\n\r\n3. 水平扩展(Horizontal Scalability)\r\n有了水平扩展的名词，自然就有了相对的垂直扩展(Vertical Scalability)了,垂直扩展简单来讲就是我们平时为我们自己的单机配置CPU和加内存的操作，但显而易见的缺点是：\r\n    - 单台机器是不能一直扩展下去的，毕竟容量有限\r\n    - 扩展的时候需要关机，虽然对于我们平时使用没什么影响，但是对于需要长期运行的机器是很费劲的\r\n\r\n水平扩展的出现就是解决以上痛点，也是在分布式的基础上发展的，可以在不关机的集群中通过无限扩展节点来增加系统的存储量和计算力(power)\r\n\r\n![][4]\r\n\r\n\r\n> 学习: Last but not the least 最后但并非不重要的一点\r\n\r\n\r\n----------\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: https://www.edureka.co/blog/hdfs-tutorial\r\n  [2]: http://cdn.pinsily.site/1531147043126.jpg\r\n  [3]: http://cdn.pinsily.site/1531147222955.jpg\r\n  [4]: http://cdn.pinsily.site/1531226735040.jpg', '53.png', '2018-07-17 15:46:00', '2019-04-06 06:54:28', 'p', '温柔解救不了这个世界 - 罪恶王冠', 240, 0, 0, 'pinsily', 18);
INSERT INTO `article` VALUES (116, 'hadoop -- HDFS(2)', '---\r\n\r\n![](http://cdn.pinsily.site/16.jpg)\r\n\r\n<p><center>就算世界终结，也无所谓</center></p>\r\n\r\n\r\n\r\n------\r\n### 翻译解释\r\n> [https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/][1]\r\n\r\n----------\r\n### 前言\r\n通过上篇介绍我们可以了解到DFS是建立在大量商用机器上的分布式文件系统，这次来讲讲其架构(HDFS Architecture)\r\n\r\n> 学习：it’s high time that 是时候了\r\n\r\n\r\n----------\r\n### HDFS Architecture\r\n\r\n![][2]\r\n\r\nHDFS采用主从模式(master/slave)的架构，既是一个 NameNode 为主节点，其余节点 DataNode 作为从节点，当然之后还会说到Secondly NameNode 的概念。另外，数据的存储使用预先定义好大小的块结构(block structured)分开存储在集群中的一台或多台机器中，实现的最终结果是我们能够在单台机器上访问多个 DataNode\r\n\r\n----------\r\n### NameNode\r\n\r\n![][3]\r\n\r\nNameNode 作为 HDFS 的主节点，主要的作用是维护和管理当前运行在 DataNode 中的数据块(block)，这样主从模式的设计，使得用户的数据永远不会存储在 NameNode 中，而只会保留在 DataNode 中\r\n\r\nNameNode 的作用：\r\n1. 作为主进程维护和管理 DataNode\r\n2. 记录存储文件的信息 -- 元数据(Metadata)，元数据会记录块存储的位置、文件的大小，权限等等，主要由两个文件实现关联：\r\n    - FsImage: 其包含了从 NameNode 启动以来完整的刺痛命名空间状态\r\n    - EditLogs: 保留所有最近一段时间内系统中 FsImage 中所做的修改\r\n\r\n3. 记录发生在系统中所有元数据的的变化，比如现在你在 HDFS 上删除了一个文件，其会在 Editlog 上立马记录下来此操作\r\n4. 它会定期地接收来自每个 DataNode 的心跳包(heartbeat)来监控某个 DataNode 是否还活着\r\n5. 当发生某个 DataNode 发生问题时，NameNode 会重新选择一个新节点并将旧数据复制过去，并重新管理磁盘空间的使用和 DataNode 之间的通信\r\n\r\n\r\n----------\r\n### DataNode\r\n\r\nFunctions of DataNode:\r\n1. These are slave daemons or process which runs on each slave machine.\r\n2. The actual data is stored on DataNodes.\r\n3. The DataNodes perform the low-level read and write requests from the file system’s clients.\r\n4. They send heartbeats to the NameNode periodically to report the overall health of HDFS, by default, this frequency is set to 3 seconds.\r\n\r\n----------\r\n### Secondary NameNode\r\n\r\n我们知道，当 DataNode 发生故障时，作为它大佬的 NameNode 会想办法解决，但是如果 NameNode 出问题了呢，这就需要 Secondary NameNode 的参与了\r\n\r\n![][4]\r\n\r\n值得一提的是，Secondary NameNode 并非起到后备支援的作用，它跟主 NameNode 是同时作为 deamon 运行的\r\n\r\nFunctions of Secondary NameNode:\r\n1. The Secondary NameNode is one which constantly reads all the file systems and metadata from the RAM of the NameNode and writes it into the hard disk or the file system.\r\n2. It is responsible for combining the EditLogs with FsImage from the NameNode. \r\n3. It downloads the EditLogs from the NameNode at regular intervals and applies to FsImage. The new FsImage is copied back to the NameNode, which is used whenever the NameNode is started the next time.\r\n\r\n----------\r\n### Blocks\r\n通常来说，文件系统的文件也是以块的形式来存放的，不过在 HDFS 中存放在了不同的位置而已，默认块的大小在 Hadoop 2.0 中时 128M，Hadoop 1.0 中为 64 M\r\n\r\n![][5]\r\n\r\n上图所显示的，当我们有一个 514M 的文件时，它会被分成 4 个 128M 和 1 个 2M 大小的块存储在同一个或者不同的 DataNode 中\r\n\r\n\r\n----------\r\n### Replication Management\r\n既然已经了解到了HDFS的最小存储单位 -- 块(block),那么接下来就需要了解的是块是怎样存储在 HDFS 中的\r\n\r\n在 HDFS 中，每个 block 由系统规定的 replication factor = 3(可以自行配置)来复制3份存储在不同的 dataNode 中，从而达到很高的容错性（fault tolerance）\r\n\r\n![][6]\r\n\r\n由图片可以看出，在默认设置下，每一个 block 都被复制了三份放在了不同的 dataNode 中，这样即使单个节点发生了错误，也不会影响系统的正常运行\r\n\r\n另外，NameNode 会定时查看 block 的情况从而可以改变 replication factor 的稳定，所以说，如果有需要的话，NameNode 可以减少或增多 block 复制的份数\r\n\r\n----------\r\n### Rack Awareness\r\n\r\n![][7]\r\n\r\n关于 HDFS 是怎样放置复制块的，还有一个新的概念，机架感知(Rack Awareness)\r\n\r\n首先，我们应该知道机架的概念，顾名思义，机架可以理解为放置了 n 部机器的架子，我们将其定位为一个新的单元来称呼\r\n\r\n现在，就是算法的问题了，机架感应算法就是解决复制快该怎样放置的问题，我们仍旧使用默认的 3 份复制，机架感应算法指的是第一份备份会被存储在本地的机架中，而其他两份复制存储在另外的机架上，就像上图指示的那样，如果我们的备份多的话，剩下的可以随机地存储在同一机架上的不同 DataNode 上，可以的话\r\n\r\n![][8]\r\n\r\n很容易想到的是，以机架为单位的话，即使单个机架的机器都出问题了，也可以保证其他机架上仍存有备份使用\r\n\r\n除此之外，以机架为单位可以增加网络性能，如上图所示，不同机架间的交流通过 core switch 来实现，相同机架的可以直接交流。显然这样写性能因为避免了很多机架间的交流而得到提高，而读性能因为使用了多个机架的带宽而得到提高\r\n\r\n\r\n----------\r\n### 继续\r\n了解了基本的架构，现在来继续深入了解 HDFS 是怎样读写文件的\r\n\r\n----------\r\n### HDFS Write Architecture\r\n我们假设现在有一个客户端需要将一个 248M 的文件 \'example.txt\' 写入到 HDFS 中，使用 128M 的块的话，很显然可以分为 block(A) - 128M 和 block(B) - 120M\r\n\r\n![][9]\r\n\r\n当需要写入文件时，系统遵循下列协议步骤：\r\n- 首先，客户端(client)会针对这两个 block 向 NameNode 发送写请求，say, Block A & Block B\r\n- 在确认客户端具有写权限之后，NameNode 会将可以存储该文件块的 DataNode 的 IP 地址返回给客户端，而这些 DataNode 的选取是根据机架感应算法随机得到的，而且，根据默认的复制份数，对每一个块会返回 3 个不同的 IP\r\n- 假设返回的 IP 集合如下：\r\n    - For Block A, list A = {IP of DataNode 1, IP of DataNode 4, IP of DataNode 6}\r\n    - For Block B, set B = {IP of DataNode 3, IP of DataNode 7, IP of DataNode 9}\r\n\r\n- 接下来将由以下的三步执行完成数据的存储和备份\r\n    1. Set up of Pipeline\r\n    2. Data streaming and replication\r\n    3. Shutdown of Pipeline (Acknowledgement stage) \r\n\r\n![][10]\r\n\r\n\r\n#### 1. Set up of Pipel\r\n在进行写操作之前，很显然客户端需要知道 NameNode 交付回来的 DataNode 有没有准备好接受数据，为了确认情况，客户端会通过返回来的 IP 序列分别向三个 DataNode 建立管道(Pipeline)连接,我们可以先拿 A 来进行说明：\r\n\r\n**For Block A, list A = {IP of DataNode 1, IP of DataNode 4, IP of DataNode 6}.**\r\n\r\n![][11]       \r\n\r\n接下来，对于A块，客户端会执行以下步骤建立管道：\r\n- 客户端选择第一个IP -- DataNode 1 建立起 TCP/IP 连接\r\n- 客户端会通知 DataNode 1 做好接受数据的准备，并且将要用于存储备份的地址 DataNode 4 和 DataNode 6 交付给它\r\n- 接着 DataNode 1 会连接到 DataNode 4, 通知其做好准备，类似地也将DataNode 6 的地址给它\r\n- 接下来，DataNode 4 只需要建立连接之后通知 DataNode 6 做好准备即可\r\n- 连接建立到最后一个节点，准备充分的确认信息会逆着返回到起始节点 DataNode 1 中，Node1 再统一发回给客户端，确认三个节点都已经准备好接受数据\r\n- 至此，管道才算完成了建立的过程，客户端开始进行数据备份和数据流过程\r\n\r\n> 小疑问，客户端是直接还是间接地与 Node4、Node6 建立管道连接\r\n\r\n#### 2. Data Streaming\r\n\r\n在管道建立之后，客户端将数据推送到管道中，值得一提的是，客户端仅仅只是将数据放到了 DataNode 1 中，接下来的复制由节点序列进行\r\n\r\n![][12]\r\n\r\n所以，复制的步骤很容易就可以得出来：\r\n\r\n- 当客户端将数据写入 DataNode 1 后，DataNode 1 将连接 DataNode 4\r\n- 然后， DataNode 1 通过管道连接将数据推送至 DataNode 4 中完成复制\r\n- 类似地 DataNode 4 将数据复制到 DataNode 6 中\r\n\r\n### 3. Shutdown of Pipeline or Acknowledgement stage\r\n\r\n完成数据的存储和备份之后，确认信息依旧按照逆顺序返回，由 DataNode 1 集中返回给客户端，这里别忘了 NameNode 的存在，客户端收到确认信息之后，会告诉 NameNode，而其会进行相关 Metadata 的更新，之后客户端正式关掉管道\r\n\r\n![][13]\r\n\r\n相同的，对于 block B，跟 A 的步骤是类似的，只是需要注意的是，A 和 B 的写入是并行的，没有先后之分\r\n\r\n![][14]\r\n\r\n就像上图所示，A 和 B 构成了两条并行的管道，他们的执行顺序如下：\r\n- For Block A: 1A -> 2A -> 3A -> 4A\r\n- For Block B: 1B -> 2B -> 3B -> 4B -> 5B -> 6B\r\n\r\n> 小疑问，为什么 datanode1 不用经过 Switch 可以直连 datanode4\r\n\r\n----------\r\n### HDFS Read Architecture\r\n理解了写操作之后，读操作就好理解多了\r\n\r\n我们同样假设客户端需要读取一个 example.txt 文件\r\n\r\n![][15]\r\n\r\n读取的程序如下：\r\n- 客户端向 NameNode 请求有关 \'example.txt\' 文件的 Metadata\r\n- NameNode 将返回存储 Block A and B 的DataNode 的信息\r\n- 客户端开始与相关的 DataNode(A--1, B--3) 建立并行连接并开始读取数据\r\n- 当客户端读取完数据之后，两个数据块将合并成一个完整文件展示\r\n\r\n有一点是，为了节省读延迟和带宽消耗， NameNode 返回的信息会尽可能地离客户端近点，所以返回的 DataNode 并非一定是写文件时的存储顺序的第一个 DataNode\r\n\r\n\r\n----------\r\n### 总结\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/\r\n  [2]: http://cdn.pinsily.site/1531227550363.jpg\r\n  [3]: http://cdn.pinsily.site/1531228143984.jpg\r\n  [4]: http://cdn.pinsily.site/1531233279698.jpg\r\n  [5]: http://cdn.pinsily.site/1531233613485.jpg\r\n  [6]: http://cdn.pinsily.site/1531311773328.jpg\r\n  [7]: http://cdn.pinsily.site/1531312677951.jpg\r\n  [8]: http://cdn.pinsily.site/1531313534244.jpg\r\n  [9]: http://cdn.pinsily.site/1531315482034.jpg\r\n  [10]: http://cdn.pinsily.site/1531316471501.jpg\r\n  [11]: http://cdn.pinsily.site/1531398723448.jpg\r\n  [12]: http://cdn.pinsily.site/1531402691956.jpg\r\n  [13]: http://cdn.pinsily.site/1531403582291.jpg\r\n  [14]: http://cdn.pinsily.site/1531403654579.jpg\r\n  [15]: http://cdn.pinsily.site/1531404117386.jpg', '54.jpg', '2018-07-21 15:47:00', '2019-04-10 09:19:12', 'p', 'HDFS采用主从模式(master/slave)的架构，既是一个 NameNode 为主节点，其余节点 Da', 192, 0, 0, 'pinsily', 18);
INSERT INTO `article` VALUES (117, 'linux -- zip压缩和解压', '---\r\n\r\n![][1]\r\n\r\n<p><center>好梦向来易醒 - 风之谷</center></p>\r\n\r\n\r\n------\r\n### 说明\r\n在 window 和linux 之间传递文件 zip 又学到一个新的知识点\r\n\r\n----------\r\n### 用例\r\n> zip 命令用来压缩文件，unzip 命令用来解压缩文件\r\n\r\n1. 压缩文件：\r\n\r\n``` shell\r\n$ zip -r test.zip abc.py dir\r\n```\r\n\r\n\r\n2. 解压缩\r\n\r\n``` shell\r\n$ unzip test.zip\r\n```\r\n\r\n\r\n3. 同时解压多个zip文件test1.zip, test2.zip\r\n\r\n``` shell\r\n$ unzip test\\?.zip\r\n```\r\n\r\n\r\n4. 预览 zip 文件内容\r\n\r\n``` shell\r\n$ unzip -v test.zip\r\n```\r\n\r\n\r\n5. 验证文件是否下载完全\r\n\r\n``` shell\r\n$ unzip -t test.zip\r\n```\r\n\r\n\r\n6.将 zip 中所有子目录的内容解压到同一个根目录下：\r\n\r\n``` shell\r\n$ unzip -j test.zip\r\n```\r\n\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/MooseLakeGrass.jpg', '55.jpg', '2018-07-22 15:49:00', '2019-04-05 04:36:40', 'p', '在 window 和linux 之间传递文件 zip 又学到一个新的知识点', 190, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (118, 'docker -- 容器操作', '---\r\n\r\n![](http://cdn.pinsily.site/truba-oblako-nebo_2048x1367.jpg)\r\n\r\n<p><center>人，真是奇怪，没有外人来证明你，就往往看不出自己的价值。 ——撒哈拉的故事</center></p>\r\n\r\n\r\n----------\r\n### 参考\r\n> 《docker 开发与实践》\r\n\r\n------\r\n### 容器\r\n容器是一个打包了应用和服务的环境，这里记录容器的常用标准操作\r\n\r\n----------\r\n### 容器的管理操作\r\n#### 容器的查看\r\n\r\n查看正在运行的容器\r\n```shell\r\nroot@pinsily:~# docker ps\r\n```\r\n\r\n![](http://cdn.pinsily.site/1532959514407.png)\r\n\r\n使用参数 a 查看所有容器，即包含未启动的容器\r\n```\r\nroot@pinsily:~# docker ps -a\r\n```\r\n\r\n![](http://cdn.pinsily.site/1532959648357.png)\r\n\r\n各字段的含义：\r\n\r\n| 字段 | 含义 |\r\n| --- | --- |\r\n| CONTAINER ID |64位16进制数唯一容器标识|\r\n|INAGE|创建容器时使用的镜像     |\r\n|COMMAND|容器最后运行的命令|\r\n|CREATED|创建时间|\r\n|STATUS|容器状态分，运行时为运行时间，停止时为类似于 exited(0) 的错误码，0为正常退出|\r\n|PORTS|对外开放的端口|\r\n|NAME|唯一标识的名字|\r\n\r\n\r\n#### 创建容器\r\n> create 和 run 命令均可创建容器，区别在于前者创建一个静止状态的容器，后者创建后则启动容器\r\n\r\n创建静止状态的容器，使用 ubuntu 16.04 版本，返回 id\r\n\r\n``` shell\r\nroot@pinsily:~# docker create ubuntu:16.04\r\n```\r\n\r\n使用 ps -a 命令才能查看到容器\r\n\r\n![](http://cdn.pinsily.site/1532960369957.png)\r\n\r\n\r\nrun 命令可以创建交互性和后台型的运行容器\r\n\r\n创建交互性容器\r\n\r\n``` shell\r\nroot@pinsily:~# docker run -i -t --name=interaction ubuntu:16.04 /bin/bash\r\n```\r\n\r\n![](http://cdn.pinsily.site/1532960809260.png)\r\n\r\n选项含义\r\n\r\n| 选项 |含义  |\r\n| --- | --- |\r\n|  i   |   打开容器的标准输入 stdin  |\r\n|  t   |   使用 /bin/bash 建立 terminal  |\r\n|  name   |  命名,否则系统随机   |\r\n\r\n当本地不存在镜像时，docker 会自动从云端中下载，原理图如下：\r\n\r\n![](http://cdn.pinsily.site/1532961345295.png)\r\n\r\n使用命令 exit 或者 Ctrl+D 可以退出交互式容器\r\n\r\n创建后台型容器，不随 terminal 的关闭而退出\r\n\r\n``` shell\r\nroot@pinsily:~# docker run -d --name=deamon ubuntu:16.04 /bin/bash -c \"while true; do echo hello; sleep 1; done\"\r\n```\r\n\r\n选项含义\r\n\r\n| 选项 |含义  |\r\n| --- | --- |\r\n|  d   |   创建后台进程  |\r\n|  c   |   后台执行命令  |\r\n|  name   |  命名,否则系统随机   |\r\n\r\n使用 ps 命令可以查看到该容器正在执行\r\n\r\n值得注意的是，当容器执行完命令之后会自动停止，上面的死循环能保持我们能用 ps 查看容器\r\n\r\n另外，我们可以通过设置参数 `--restart` 进行重启, `on-failure:5` 表示结束状态码非 0 时最多重启 5 次\r\n\r\n\r\n### 终止和删除容器\r\n> 终止和删除都可以使用唯一标识，即名字和ID进行指定容器\r\n\r\n注: 使用id的时候只要保证键入的位数能够区分即可\r\n\r\n``` shell\r\nroot@pinsily:~# docker stop 79\r\n\r\nroot@pinsily:~# docker rm 79\r\n\r\n```\r\n\r\n![](http://cdn.pinsily.site/1532962233003.png)\r\n\r\n一般情况下，运行中的容器不能直接删除，但是可以使用 `-f` 选项强制删除\r\n\r\n删除所有容器(曲线救国)\r\n\r\n``` shell\r\nroot@pinsily:~# docker rm $(docker ps -a -q)\r\n```\r\n\r\n`$(docker ps -a -q)` 列出所有容器的 id\r\n\r\n\r\n----------\r\n### 容器内信息获取和命令执行\r\n\r\n#### 查看容器日志\r\n> 对于后台型容器而言\r\n\r\n创建一个后台容器\r\n\r\n``` shell\r\nroot@pinsily:~# docker run --name=deamon_log ubuntu:16.04 /bin/bash -c \'for((i=0;1;i++));do echo $i; sleep 1; done;\'\r\n```\r\n\r\n查看日志\r\n\r\n``` shell\r\nroot@pinsily:~# docker logs -f  --tail=5  -t deamon_log\r\n```\r\n\r\n![](http://cdn.pinsily.site/1533048082271.png)\r\n\r\n参数含义\r\n\r\n| 参数  | 含义 |\r\n| --- | --- |\r\n| -f |  实时更新日志 |\r\n| --tail=5  | 开始只打印最后五条日志 |\r\n|  -t   |  显示日志时间   |\r\n\r\n> 注：有趣的是，直接使用 window10 cmd ssh 登录服务器操作的时候，不加任何参数，即`docker logs deamon_log`都会实时刷新，而且还关不掉\r\n\r\n#### 查看容器进程\r\n\r\n``` shell\r\nroot@pinsily:~# docker top deamon_log\r\n```\r\n\r\n![](http://cdn.pinsily.site/1533048276624.png)\r\n\r\n可以看到，上面的容器中有 for 循环和 sleep 进程\r\n\r\n#### 查看容器信息\r\n\r\n``` shell\r\nroot@pinsily:~# docker inspect deamon_log\r\n```\r\n\r\n![](http://cdn.pinsily.site/1533048426887.png)\r\n\r\n容器的信息非常多，可以使用 `-f` 或者 `--format` 制定输出信息\r\n\r\n查看容器名和运行状态\r\n\r\n``` shell\r\nroot@pinsily:~# docker inspect --format \'{{.Name}} {{.State.Running}}\' deamon_log\r\n\r\n/deamon_log true\r\n```\r\n\r\n\r\n----------\r\n### 容器的导入和导出\r\n导出\r\n\r\n``` shell\r\nroot@pinsily:~# docker export deamon_log > my_container.tar\r\n```\r\n\r\n导入\r\n\r\n``` shell\r\nroot@pinsily:~# docker import - imported:container\r\n```\r\n\r\n`-`标识本地导入，也可以使用url形式导入，`imported:container` 表示镜像名和标签\r\n\r\n----------', 'gin_Xvlddvy.jpg', '2018-08-01 14:35:00', '2019-04-01 07:03:37', 'p', '容器是一个打包了应用和服务的环境，这里记录容器的常用标准操作', 190, 0, 0, 'pinsily', 2);
INSERT INTO `article` VALUES (119, 'django -- uwsgi+nginx部署', '---\r\n![](http://cdn.pinsily.site/singapore.jpg)\r\n\r\n<p><center>比起牺牲自己的圣人,我更愿意成为不明事理的勇者</center></p>\r\n\r\n\r\n------\r\n### 说明\r\n直接记录完整的部署操作，详细的可以查看官方文档\r\n\r\n> [使用uWSGI和nginx来设置Django和你的web服务器](https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html)\r\n\r\n\r\n\r\n----------\r\n### 前提\r\n- 项目根目录：/root/youxue\r\n- django 环境搭建好\r\n- 安装 uwsgi\r\n- 安装 supervisor\r\n- 安装 nginx\r\n\r\n----------\r\n### 部署文件\r\n1. uwsgi_params（使用socket时nginx连接uwsgi要用到）\r\n\r\n``` shell\r\nuwsgi_param  QUERY_STRING       $query_string;\r\nuwsgi_param  REQUEST_METHOD     $request_method;\r\nuwsgi_param  CONTENT_TYPE       $content_type;\r\nuwsgi_param  CONTENT_LENGTH     $content_length;\r\n\r\nuwsgi_param  REQUEST_URI        $request_uri;\r\nuwsgi_param  PATH_INFO          $document_uri;\r\nuwsgi_param  DOCUMENT_ROOT      $document_root;\r\nuwsgi_param  SERVER_PROTOCOL    $server_protocol;\r\nuwsgi_param  REQUEST_SCHEME     $scheme;\r\nuwsgi_param  HTTPS              $https if_not_empty;\r\n\r\nuwsgi_param  REMOTE_ADDR        $remote_addr;\r\nuwsgi_param  REMOTE_PORT        $remote_port;\r\nuwsgi_param  SERVER_PORT        $server_port;\r\nuwsgi_param  SERVER_NAME        $server_name;\r\n```\r\n\r\n2. youxue_uwsgi.ini （uwsgi可以直接使用此文件启动服务）\r\n\r\n``` ini\r\n[uwsgi]\r\n\r\n# 根目录\r\nchdir           = /root/youxue\r\n# Django\'s wsgi file\r\nmodule          = youxue.wsgi\r\n\r\n# process-related settings\r\n# master\r\nmaster          = true\r\n# 开启的最多进程数\r\nprocesses       = 10\r\n# 使用 socket连接的时候需要制定路径\r\n# 使用 http 连接的时候制定端口 # socket=:8000\r\nsocket          = /root/youxue/youxue.sock\r\n# 管理员不需要另外设置权限\r\n# chmod-socket    = 664\r\n\r\n# 服务器退出时自动清理环境 删除 sock 文件和 pid 文件\r\nvacuum          = true\r\n\r\npidfile         = /tmp/youxue.pid  # 制定pid文件的位置\r\n\r\ndaemonize = /root/log/tuclown.log  # 后台运行并记录日志\r\n```\r\n\r\n\r\n3. /etc/nginx/sites-enabled/default（nginx 配置）\r\n\r\n> 也可以新建 conf 文件，软链接到配置目录 `ln -s /root/youxue/youxue_nginx.conf /etc/nginx/sites-enabled/youxue_nginx.conf`\r\n``` shell\r\nupstream youxue {\r\n\r\n    server unix:///root/youxue/youxue.sock;\r\n\r\n}\r\n\r\nserver {\r\n\r\n    listen 80;\r\n    server_name youxue.pinsily.site; # 域名 or IP\r\n    root /root/youxue;              # 项目根目录\r\n    index index.html index.htm;\r\n    charset utf-8;  \r\n    location /static {              # \r\n\r\n        alias /root/youxue/static;\r\n\r\n    }\r\n\r\n    # 日志文件\r\n    access_log /root/log/youxue.log;\r\n    error_log /root/log/youxue_error.log;\r\n\r\n    location /media {\r\n\r\n        alias /root/youxue/media;\r\n\r\n    }\r\n\r\n    location / {\r\n\r\n        uwsgi_pass youxue;\r\n        include /root/youxue/uwsgi_params;\r\n    }\r\n\r\n}\r\n```\r\n\r\n4. 启动（也可以使用supercisor）\r\n```shell\r\nuwsgi --ini youxue_uwsgi.ini\r\n```\r\n\r\n\r\n----------\r\n### 使用 supervisor 进行进程管理\r\n0. 安装使用自行搜索\r\n\r\n1. 配置文件\r\n\r\n```shell\r\n# vim /etc/supervisor/supervisord.conf\r\n\r\n[program:youxue]\r\ncommand=uwsgi --ini /root/youxue/youxue_uwsgi.ini\r\nautostart=true\r\nautorestart=true\r\nuser=root\r\nlog_stderr=true\r\nlogfile=/var/log/uwsgi-youxue.log\r\n```\r\n\r\n2. 基本操作\r\n\r\n``` shell\r\nsupervisorctl start youxue\r\nsupervisorctl stop youxue\r\nsupervisorctl restart youxue\r\n```\r\n\r\n\r\n----------\r\n### 总结\r\n稍后需要的话继续完善修改\r\n\r\n\r\n----------', '1_u4UBFMW.jpg', '2018-09-16 01:56:00', '2019-04-10 09:16:55', 'p', '直接记录完整的部署操作，详细的可以查看官方文档', 152, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (120, 'linux -- 磁盘管理基本命令', '---\r\n\r\n![](http://cdn.pinsily.site/60.jpg)\r\n\r\n<p><center>如果有想见的人，那么就一定不再是一个人 -- 夏目友人帐</center></p>\r\n\r\n\r\n------\r\n### df\r\ndf 命令主要查询磁盘占用的空间、剩余空间、以及使用率等，默认以磁盘为单位\r\n\r\n#### 命令参数\r\n\r\n``` shell\r\n-a：显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统\r\n-k：以k字节为单位显示\r\n-i：显示i节点信息，而不是磁盘块\r\n-t：显示各指定类型的文件系统的磁盘空间使用情况\r\n-x：列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）\r\n-T：显示文件系统类型\r\n```\r\n\r\n#### 使用情况\r\n\r\n![](http://cdn.pinsily.site/1537064337522.png)\r\n\r\n![](http://cdn.pinsily.site/1537064380031.png)\r\n\r\n![](http://cdn.pinsily.site/1537064406314.png)\r\n\r\n\r\n----------\r\n### du(disk usage)\r\ndu 命令显示磁盘的使用情况，统计目录或文件所占磁盘空间大小，默认为当前目录\r\n\r\n#### 命令参数\r\n\r\n``` shell\r\n-s：对每个Names参数只给出占用的数据块总数\r\n-a：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定-s，也不指定-a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数\r\n-b：以字节为单位列出磁盘空间使用情况（系统默认以k字节为单位）\r\n-k：以1024字节为单位列出磁盘空间使用情况\r\n-c：最后再加上一个总计（系统默认设置）\r\n-l：计算所有的文件大小，对硬链接文件，则计算多次\r\n-x：跳过在不同文件系统上的目录不予统计\r\n```\r\n\r\n#### 简单使用\r\n\r\n``` shell\r\nroot@pinsily:~# du -s\r\n4116636 .\r\n```\r\n\r\n![](http://cdn.pinsily.site/1537065107327.png)\r\n\r\n\r\n----------\r\n### fdisk 磁盘分区\r\n> 转载：[http://os.51cto.com/art/201012/240726_all.htm](http://os.51cto.com/art/201012/240726_all.htm)\r\n\r\nfdisk可以划分磁盘分区。下面给出使用Fdisk命令进行磁盘分区的操作步骤：\r\n\r\n``` shell\r\n#fdisk /dev/had    //使用/dev/had作为默认的分区设备\r\nCommand (m for help): m  //选择命令选项\r\nCommand action\r\n   a   toggle a bootable flag\r\n   b   edit bsd disklabel\r\n   c   toggle the dos compatibility flag\r\n   d   delete a partition\r\n   l   list known partition types\r\n   m   print this menu\r\n   n   add a new partition\r\n   o   create a new empty DOS partition table\r\n   p   print the partition table\r\n   q   quit without saving changes\r\n   s   create a new empty Sun disklabel\r\n   t   change a partition\'s system id\r\n   u   change display/entry units\r\n   v   verify the partition table\r\n   w   write table to disk and exit\r\n   x   extra functionality (experts only)\r\n```\r\n\r\nFdisk有很多参数，可是经常使用的只有几个\r\n\r\n- 在Linux分区过程，一般是先通过p参数来显示硬盘分区表信息，然后根据信息确定将来的分区。如下所示\r\n\r\n![](http://cdn.pinsily.site/1537065289710.png)\r\n\r\n- 如果想完全改变硬盘的分区格式，就可以通过d参数一个一个地删除存在的硬盘分区。删除完毕，就可以通过n参数来增加新的分区。当按下“n”后，可以看到如下所示\r\n\r\n![](http://cdn.pinsily.site/1537065323483.png)\r\n\r\n这里要选择新建的分区类型，是主分区还是扩展分区；并选择p或是e。然后就是设置分区的大小\r\n\r\n要提醒注意的是，如果硬盘上有扩展分区，就只能增加逻辑分区，不能增加扩展分区\r\n\r\n- 在增加分区的时候，其类型都是默认的Linux Native，如果要把其中的某些分区改变为其他类型，例如Linux Swap或FAT32等，可以通过命令t来改变，当按下“t”改变分区类型的时候，系统会提示要改变哪个分区、以及改变为什么类型（如果想知道系统所支持的分区类型，键入l），如下所示\r\n\r\n![](http://cdn.pinsily.site/1537065398161.png)\r\n\r\n改变完了分区类型，就可以按下“w”，保存并退出。如果不想保存，那么可以选择“q”直接退出\r\n\r\n\r\n----------', '63.jpg', '2018-09-07 02:39:00', '2019-03-31 23:56:42', 'p', '如果有想见的人，那么就一定不再是一个人 -- 夏目友人帐', 116, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (121, 'bootstrap 4 -- 隐藏部分栅格', '---\r\n\r\n![][1]\r\n\r\n<p><center>你还是这么冷漠啊。不过，仅此而已的话，我是不会泄气的 -- 银魂</center></p>\r\n\r\n\r\n\r\n------\r\n### 说明\r\n使用小屏幕的时候想着隐藏掉侧边栏，发现v3和v4版本的隐藏使用发生了挺大的改变\r\n\r\n----------\r\n### 来源\r\n> [https://stackoverflow.com/questions/35351353/missing-visible-and-hidden-in-bootstrap-v4][2]\r\n> [https://getbootstrap.com/docs/4.0/utilities/display/][3]\r\n\r\n----------\r\n### 变换\r\n#### Show/hide for breakpoint and down:\r\n\r\n - hidden-xs-down (hidden-xs) = d-none d-sm-block hidden-sm-down\r\n - (hidden-sm hidden-xs) = d-none d-md-block hidden-md-down (hidden-md\r\n - hidden-sm hidden-xs) = d-none d-lg-block hidden-lg-down = d-none\r\n - d-xl-block hidden-xl-down (n/a 3.x) = d-none (same as hidden)\r\n\r\n#### Show/hide for breakpoint and up:\r\n\r\n- hidden-xs-up = d-none (same as hidden)\r\n- hidden-sm-up = d-sm-none\r\n- hidden-md-up = d-md-none\r\n- hidden-lg-up = d-lg-none\r\n- hidden-xl-up (n/a 3.x) = d-xl-none\r\n\r\n#### Show/hide only for a single breakpoint:\r\n- hidden-xs (only) = d-none d-sm-block (same as hidden-xs-down)\r\n- hidden-sm (only) = d-block d-sm-none d-md-block\r\n- hidden-md (only) = d-block d-md-none d-lg-block\r\n- hidden-lg (only) = d-block d-lg-none d-xl-block\r\n- hidden-xl (n/a 3.x) = d-block d-xl-none\r\n- visible-xs (only) = d-block d-sm-none\r\n- visible-sm (only) = d-none d-sm-block d-md-none\r\n- visible-md (only) = d-none d-md-block d-lg-none\r\n- visible-lg (only) = d-none d-lg-block d-xl-none\r\n- visible-xl (n/a 3.x) = d-none d-xl-block\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/risunok.jpg\r\n  [2]: https://stackoverflow.com/questions/35351353/missing-visible-and-hidden-in-bootstrap-v4\r\n  [3]: https://getbootstrap.com/docs/4.0/utilities/display/', '1_8E6PqgC.jpg', '2018-08-09 10:44:00', '2019-04-02 09:34:54', 'p', '使用小屏幕的时候想着隐藏掉侧边栏，发现v3和v4版本的隐藏使用发生了挺大的改变', 118, 0, 0, 'pinsily', 10);
INSERT INTO `article` VALUES (122, 'mysql -- 创建数据库制定编码', '---\r\n\r\n![][1]\r\n\r\n<p><center>杂耍和唱歌的才需要掌声 - 冰与火之歌</center></p>\r\n\r\n\r\n\r\n------\r\n### 说明\r\n导入数据库之间需要创建好相应的数据库，如果存在中文的话需要制定编码格式才行\r\n\r\n----------\r\n### 解决\r\n```\r\nGBK: create database test DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;\r\n \r\nUTF8: CREATE DATABASE test DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\r\n```\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/maldivy-okean.jpg', '1_YuzX171.jpg', '2018-07-25 10:57:00', '2019-04-09 00:04:15', 'p', '杂耍和唱歌的才需要掌声 - 冰与火之歌', 96, 0, 0, 'pinsily', 7);
INSERT INTO `article` VALUES (123, 'css -- 图片悬停原区域放大', '---\r\n\r\n![](http://cdn.pinsily.site/singapore.jpg)\r\n\r\n\r\n<p><center>起风了,唯有努力生存。 ——起风了</center></p>\r\n\r\n\r\n\r\n------\r\n### 说明\r\n实现在div区域上图片能在此放大，但不覆盖掉外面的区域\r\n\r\n放大前：\r\n\r\n![][1]\r\n\r\n悬停中：\r\n\r\n![][2]\r\n\r\n----------\r\n### 解决\r\n```css\r\ndiv{  \r\n    /* ... */\r\n    overflow: hidden;  \r\n    /* ... */\r\n}  \r\ndiv img{  \r\n    /* ... */ \r\n    transition: all 1s;  \r\n    /* ... */\r\n}  \r\ndiv img:hover{ \r\n    /* ... */\r\n    transform: scale(1.2);  \r\n    /* ... */\r\n} \r\n```\r\n\r\noverflow: hidden; 表示溢出的部分直接隐藏，这样很重要\r\n\r\ntransition: all 0.6s; 表示所有的属性变化在1s的时间段内完成。\r\n\r\ntransform: scale(1.4); 表示在鼠标放到图片上的时候图片按比例放大1.2倍\r\n\r\n----------\r\n\r\n\r\n  [1]: http://cdn.pinsily.site/1527905163251.jpg\r\n  [2]: http://cdn.pinsily.site/1527905179386.jpg', '1537103132080.jpg', '2018-09-16 11:00:00', '2019-04-04 03:07:11', 'p', '起风了,唯有努力生存。 ——起风了', 298, 0, 0, 'pinsily', 5);
INSERT INTO `article` VALUES (124, 'python -- 时间戳批量重命名图片', '-----\r\n\r\n![](http://cdn.pinsily.site/1537103132039.jpg)\r\n\r\n<p><center>歌声像一条柔软丝带，伸进黑洞里一点一点诱出深藏的记忆 -- 目送</center></p>\r\n\r\n\r\n------\r\n### 说明\r\n因为上传到七牛云的图片重名时会发生覆盖，所以就想到了利用时间戳来命名文件\r\n\r\n只支持 jpg 和 png 的图片\r\n\r\n----------\r\n### 脚本\r\n\r\n``` python\r\ndef rename():\r\n	try:\r\n		print(\"[info]------开始更新------\")\r\n		# basePath = os.getcwd()\r\n		file_list = os.listdir(\".\")\r\n\r\n		for file in file_list:\r\n			file_name, file_suffix = file.split(\".\")\r\n			if file_suffix in (\"jpg\", \"png\") and len(file_name)!=13:\r\n				new_name = \"{0}.{1}\".format(int(round(time.time() * 1000)), file_suffix)\r\n				os.rename(file, new_name)\r\n\r\n		print(\"[info]------更新成功------\")\r\n	except:\r\n		print(\"[error]------更新失败------\")\r\n\r\nrename()\r\n```\r\n\r\n----------', '1537103132039.jpg', '2018-08-23 13:26:00', '2019-04-01 23:46:09', 'p', '因为上传到七牛云的图片重名时会发生覆盖，所以就想到了利用时间戳来命名文件', 120, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (125, 'win10 -- 安装 mysql', '---\r\n\r\n![](http://cdn.pinsily.site/1537103132053.jpg)\r\n\r\n<p><center>一个故事的阅读方法，绝对不只有一种</center></p>\r\n\r\n\r\n\r\n------\r\n### 下载\r\n> [https://dev.mysql.com/downloads/installer/](https://dev.mysql.com/downloads/installer/)\r\n\r\n![](http://cdn.pinsily.site/1531546052602.png)\r\n\r\n\r\n----------\r\n### 安装\r\n\r\n![](http://cdn.pinsily.site/1531546154984.png)\r\n\r\n![](http://cdn.pinsily.site/1531546206999.png)\r\n\r\n![](http://cdn.pinsily.site/1531546229540.png)\r\n\r\n![](http://cdn.pinsily.site/1531546345344.png)\r\n\r\n![](http://cdn.pinsily.site/1531546368106.png)\r\n\r\n![](http://cdn.pinsily.site/1531546399219.png)\r\n\r\n![](http://cdn.pinsily.site/1531546423653.png)\r\n\r\n![](http://cdn.pinsily.site/1531546474231.png)\r\n\r\n![](http://cdn.pinsily.site/1531546495269.png)\r\n\r\n![](http://cdn.pinsily.site/1531546510687.png)\r\n\r\n![](http://cdn.pinsily.site/1531546529147.png)\r\n\r\n![](http://cdn.pinsily.site/1531546574643.png)\r\n\r\n\r\n----------', '1537103132053.jpg', '2018-08-29 13:33:00', '2019-04-06 19:57:04', 'p', '一个故事的阅读方法，绝对不只有一种', 96, 0, 0, 'pinsily', 12);
INSERT INTO `article` VALUES (126, 'docker -- 国内镜像修改', '---\r\n\r\n![](http://cdn.pinsily.site/1537103132087.jpg)\r\n\r\n<p><center>话虽是这般说，可是烦恼之来，岂是轻易摆脱得了的？倘若情丝一斩便断，那也算不得是情丝了</center></p>\r\n\r\n\r\n\r\n------\r\n### 说明\r\n简单上网搜了一下，发现还真有个大陆镜像,速度真的是快了很多，只有一个问题，只能下载公共流行的镜像，私人镜像还得美区下载\r\n\r\n> [https://www.docker-cn.com/registry-mirror](https://www.docker-cn.com/registry-mirror)\r\n\r\n----------\r\n### 使用\r\n1. 方法一: 直接使用\r\n```shell\r\n$ docker pull registry.docker-cn.com/library/ubuntu:18.04\r\n```\r\n\r\n\r\n2. 方法二: 设置守护进程\r\n在 Docker 守护进程启动时传入 --registry-mirror 参数：\r\n\r\n``` shell\r\n$ docker --registry-mirror=https://registry.docker-cn.com daemon\r\n```\r\n\r\n3. 方法三: 永久设置\r\n> 版本是 18.06 的，这个方法没能实现\r\n``` shell\r\n# vim /etc/docker/daemon.json\r\n\r\n{\r\n  \"registry-mirrors\": [\"https://registry.docker-cn.com\"]\r\n}\r\n```\r\n\r\n----------', '1537103132087.jpg', '2018-09-22 14:06:00', '2019-04-06 14:11:15', 'p', '简单上网搜了一下，发现还真有个大陆镜像,速度真的是快了很多，只有一个问题，只能下载公共流行的镜像，私人镜像还', 134, 0, 0, 'pinsily', 2);
INSERT INTO `article` VALUES (127, 'python -- 脚本指定解释器', '---\r\n\r\n![](http://cdn.pinsily.site/1537103132093.jpg)\r\n\r\n<p><center>说文了叫“关心则乱”，说白了就是喝醋</center></p>\r\n\r\n------\r\n### 说明\r\n在 linux 编写脚本的时候，看到别人的文件头基本都加上了解释器\r\n\r\n``` shell\r\n#!/usr/bin/python\r\n\r\n或者\r\n\r\n#!/usr/bin/env python\r\n```\r\n\r\n所以也就顺便查了一下\r\n\r\n> [https://segmentfault.com/q/1010000000680188](https://segmentfault.com/q/1010000000680188)\r\n\r\n如果你用 `python xxoo.py` 来运行，那么写不写都没关系，如果要用 `./xxoo.py` 那么就必须加这行，这行被称为 shebang, 用来为脚本语言指定解释器.\r\n\r\n通常认为用 `#!/usr/bin/env python` 要比 `#!/usr/bin/python` 更好，因为 python 解释器有时并不安装在默认路径，例如在 virtualenv 中\r\n\r\nshebang 的概念是对于Unix系统的，就像我们平时写的 shell 脚本文件头也会加上相应的 `#!/bin/sh` 一样\r\n\r\n> [https://en.wikipedia.org/wiki/Shebang_(Unix)](https://en.wikipedia.org/wiki/Shebang_(Unix))\r\n\r\n----------', '1537103132093.jpg', '2018-09-04 14:53:00', '2019-04-04 02:34:55', 'p', '在 linux 编写脚本的时候，看到别人的文件头基本都加上了解释器', 96, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (128, 'python -- 打印自身源代码', '---\r\n\r\n![](http://cdn.pinsily.site/1537103132098.jpg)\r\n\r\n<p><center>秒速5厘米，那是樱花飘落的速度，那么怎样的速度，才能走完我与你之间的距离？</center></p>\r\n\r\n\r\n\r\n------\r\n### 说明\r\n在看《枕边算法书》时，有一个题目是打印自身的源代码\r\n\r\n第一想法是直接读文件不就行了，往下看发现不能这样\r\n\r\n``` python\r\nprint(open(__file__).read())\r\n```\r\n\r\n网上查找了相关的概念,这种玩法被称为了Quine, 发现还是挺有意思的，就用python实现了出来\r\n\r\n> [http://www.madore.org/~david/computers/quine.html](http://www.madore.org/~david/computers/quine.html)\r\n\r\n\r\n----------\r\n### 实现\r\n\r\n``` python\r\nme=\'me=%r\\nprint(me %% me)\'\r\nprint(me % me)\r\n```\r\n\r\n`%r` 格式化字符串 `me`，`%%` 表示输出一个 `%`\r\n\r\n----------', '1537103132098.jpg', '2018-08-15 12:17:00', '2019-03-29 16:02:50', 'p', '秒速5厘米，那是樱花飘落的速度，那么怎样的速度，才能走完我与你之间的距离？', 84, 0, 0, 'pinsily', 6);
INSERT INTO `article` VALUES (129, '聚类算法 -- kmeans 算法', '---\r\n\r\n![](http://cdn.pinsily.site/1537103132107.jpg)\r\n\r\n<p><center>无法舍弃两个方中的任何一方，那不是温柔，那不过是软弱罢了 - 东京食尸鬼</center></p>\r\n\r\n\r\n------\r\n### 算法流程\r\n1. 随机的取 k 个点作为 k 个初始质心\r\n2. 计算其他点到这个 k 个质心的距离\r\n3. 如果某个点 p 离第 n 个质心的距离更近，则该点属于 cluster n\r\n4. 计算同一 cluster 中，也就是相同 label 的点向量的平均值，作为新的质心\r\n5. 迭代至所有质心都不变化为止，即算法结束\r\n\r\n\r\n![K-means](http://cdn.pinsily.site/K-means_convergence.gif)\r\n\r\n\r\n----------\r\n### 算法过程演示\r\n> 转载：[http://www.cnblogs.com/leoo2sk/archive/2010/09/20/k-means.html](http://www.cnblogs.com/leoo2sk/archive/2010/09/20/k-means.html)\r\n\r\n下图是亚洲15只球队在2005年-2010年间大型杯赛的战绩\r\n\r\n![](http://cdn.pinsily.site/1538903472992.png)\r\n\r\n其中包括两次世界杯和一次亚洲杯。对数据做了如下预处理：对于世界杯，进入决赛圈则取其最终排名，没有进入决赛圈的，打入预选赛十强赛赋予40，预选赛小组未出线的赋予50。对于亚洲杯，前四名取其排名，八强赋予5，十六强赋予9，预选赛没出现的赋予17。这样做是为了使得所有数据变为标量，便于后续聚类\r\n\r\n对数据进行[0,1]归约化处理\r\n\r\n![](http://cdn.pinsily.site/1538903545594.png)\r\n\r\n接着用k-means算法进行聚类。设k=3，即将这15支球队分成三个集团\r\n\r\n 现抽取日本、巴林和泰国的值作为三个簇的种子，即初始化三个簇的中心为A：{0.3, 0, 0.19}，B：{0.7, 0.76, 0.5}和C：{1, 1, 0.5}。下面，计算所有球队分别对三个中心点的相异度，这里以欧氏距离度量。下面是用程序求取的结果：\r\n \r\n ![](http://cdn.pinsily.site/1538903601972.png)\r\n \r\n 从做到右依次表示各支球队到当前中心点的欧氏距离，将每支球队分到最近的簇，可对各支球队做如下聚类：\r\n \r\nA：`日本`，韩国，伊朗，沙特\r\nB：乌兹别克斯坦，`巴林`，朝鲜\r\nC：中国，伊拉克，卡塔尔，阿联酋，`泰国`，越南，阿曼，印尼\r\n\r\n下面根据第一次聚类结果，调整各个簇的中心点\r\n\r\nA簇的新中心点为：{(0.3+0+0.24+0.3)/4=0.21, (0+0.15+0.76+0.76)/4=0.4175, (0.19+0.13+0.25+0.06)/4=0.1575} = {0.21, 0.4175, 0.1575}\r\n\r\n用同样的方法计算得到B和C簇的新中心点分别为{0.7, 0.7333, 0.4167}，{1, 0.94, 0.40625}\r\n\r\n用调整后的中心点再次进行聚类，得到：\r\n \r\n![](http://cdn.pinsily.site/1538903737310.png)\r\n\r\n第二次迭代后的结果为：\r\n\r\n中国C，日本A，韩国A，伊朗A，沙特A，伊拉克C，卡塔尔C，阿联酋C，乌兹别克斯坦B，泰国C，越南C，阿曼C，巴林B，朝鲜B，印尼C\r\n\r\n结果无变化，说明结果已收敛，于是给出最终聚类结果：\r\n\r\nA：日本，韩国，伊朗，沙特\r\nB：乌兹别克斯坦，巴林，朝鲜\r\nC：中国，伊拉克，卡塔尔，阿联酋，泰国，越南，阿曼，印尼\r\n\r\n----------\r\n### 评价\r\n> k 均值适用于绝大多数的数据类型，并且简单有效。但其缺点就是需要知道准确的 k 值，并且不能处理异形簇，比如球形簇，不同尺寸及密度的簇，环形簇等等\r\n\r\n----------', '1537103132107.jpg', '2018-10-07 09:21:00', '2019-03-30 16:08:12', 'p', '无法舍弃两个方中的任何一方，那不是温柔，那不过是软弱罢了 - 东京食尸鬼', 120, 0, 0, 'pinsily', 19);
INSERT INTO `article` VALUES (130, 'linux -- 进程管理工具', '---\r\n\r\n![](http://cdn.pinsily.site/2.jpg)\r\n\r\n<p><center>我也很喜欢,不只是烟火</center></p>\r\n\r\n------\r\n### 转载\r\n> [http://linuxtools-rst.readthedocs.io/zh_CN/latest/base/05_process_manage.html][1]\r\n\r\n----------\r\n### 查询进程\r\n- 查询正在运行的进程\r\n```\r\n$ ps -ef\r\n```\r\n\r\n- 查询归属于用户root的进程\r\n```\r\n$ ps -ef | grep root\r\n```\r\n\r\n- 完整格式显示所有进程\r\n```\r\n$ ps -ajx\r\n```\r\n\r\n- 实时更新进程信息\r\n```\r\n$ top\r\n```\r\n\r\n- 查看端口占用的进程\r\n```\r\n$ lsof -i:3306\r\n```\r\n\r\n- 查看用户进程当前打开的文件\r\n```\r\n$ lsof -u root\r\n```\r\n\r\n- 查询init进程当前打开的文件\r\n```\r\n$ lsof -c init\r\n```\r\n\r\n- 查询进程ID打开的文件\r\n```\r\n$ lsof -p 1049\r\n```\r\n\r\n- 查询目录下打开的文件\r\n```\r\n$ lsof +d dir1/\r\n\r\n# 递归\r\n$ lsof +D dir1/\r\n```\r\n\r\n\r\n----------\r\n### 终止进程\r\n- 杀死指定PID进程\r\n```\r\n$ kill PID\r\n```\r\n\r\n- 杀死一系列相关进程\r\n```\r\n$ kill -9 3434\r\n```\r\n\r\n- 杀死job\r\n```\r\n$ kill %job\r\n```\r\n\r\n\r\n----------\r\n### 进程监控\r\n```\r\n$ top\r\n```\r\n可进行交互操作\r\n```\r\nP：根据CPU使用百分比大小进行排序。\r\nM：根据驻留内存大小进行排序。\r\ni：使top不显示任何闲置或者僵死进程。\r\n```\r\n\r\n\r\n----------\r\n### 分析线程栈\r\n```\r\n$ pamp PID\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://linuxtools-rst.readthedocs.io/zh_CN/latest/base/05_process_manage.html', '1537103132110.jpg', '2018-10-07 09:26:00', '2019-03-31 20:09:32', 'p', '我也很喜欢,不只是烟火', 118, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (131, '聚类算法 -- 层次聚类', '------\r\n\r\n![](http://cdn.pinsily.site/1537103132124.jpg)\r\n\r\n<p><center>我们坐在时间的列车上，却不知到目的地是何方</center></p>\r\n\r\n\r\n------\r\n### 转载\r\n> [https://www.ibm.com/developerworks/cn/analytics/library/ba-1607-clustering-algorithm/index.html#N100CF](https://www.ibm.com/developerworks/cn/analytics/library/ba-1607-clustering-algorithm/index.html#N100CF)\r\n\r\n----------\r\n### 简介\r\n层次聚类分为凝聚式层次聚类和分裂式层次聚类\r\n\r\n凝聚式层次聚类，就是在初始阶段将每一个点都视为一个簇，之后每一次合并两个最接近的簇，当然对于接近程度的定义则需要指定簇的邻近准则\r\n\r\n分裂式层次聚类，就是在初始阶段将所有的点视为一个簇，之后每次分裂出一个簇，直到最后剩下单个点的簇为止\r\n\r\n本文中我们将详细介绍凝聚式层次聚类算法\r\n\r\n对于凝聚式层次聚类，指定簇的邻近准则是非常重要的一个环节，在此我们介绍三种最常用的准则，分别是 MAX, MIN, 组平均。如下图所示：\r\n\r\n![](http://cdn.pinsily.site/1538904628636.png)\r\n\r\n\r\n----------\r\n### 算法流程\r\n凝聚式层次聚类算法也是一个迭代的过程，算法流程如下：\r\n\r\n1. 每次选最近的两个簇合并，我们将这两个合并后的簇称之为合并簇\r\n2. 若采用 MAX 准则，选择其他簇与合并簇中离得最远的两个点之间的距离作为簇之间的邻近度。若采用 MIN 准则，取其他簇与合并簇中离得最近的两个点之间的距离作为簇之间的邻近度。若组平均准则，取其他簇与合并簇所有点之间距离的平均值作为簇之间的邻近度\r\n3. 重复步骤 1 和步骤 2，合并至只剩下一个簇\r\n\r\n----------\r\n### 算法举例\r\n\r\n下面以五个点进行举例\r\n\r\n![](http://cdn.pinsily.site/1538904753939.png)\r\n\r\n先求出五个点的欧氏距离矩阵：\r\n\r\n|     |   P1  |   P2  |   P3  |  P4   |  P5  |\r\n| --- | --- | --- | --- | --- | --- |\r\n|  P1   |  0	   | 0.81    | 1.32    | 1.94    | 1.82    |\r\n|  P2   |  0.81   |  0	   |   1.56  |   2.16  |   1.77  |\r\n|  P3   |  1.32   |  1.56   |  0	   | 0.63    | 0.71    |\r\n|  P4   |  1.94   |  2.16   |  0.63   |  0	   |   0.71  |\r\n|  P5   |  1.82   |  1.77   |  0.71   |  0.71   |  0   |\r\n\r\n根据算法流程，我们先找出距离最近的两个簇，P3, P4\r\n\r\n合并 P3, P4 为 {P3, P4}，根据 MIN 原则更新矩阵如下：\r\n\r\nMIN.distance({P3, P4}, P1) = 1.32;\r\n\r\nMIN.distance({P3, P4}, P2) = 1.56;\r\n\r\nMIN.distance({P3, P4}, P5) = 0.70;\r\n\r\n继续更新举例矩阵\r\n\r\n|     |   P1  |P2|  {P3, P4}   |   P5  |\r\n| --- | --- | --- | --- | --- |\r\n|  P1	       |  0	   |   0.81  |    1.32 |    1.82 |\r\n|  P2	       |  0.81   | 0	    | 1.56    | 1.77    |\r\n|  {P3, P4}   |   1.32  |  1.56   |   0	  |     0.71    |\r\n|  P5	       |  1.82   | 1.77    |  0.71   |  0   |\r\n\r\n接着继续找出距离最近的两个簇，{P3, P4}, P5\r\n\r\n合并 {P3, P4}, P5 为 {P3, P4, P5}，根据 MIN 原则继续更新矩阵：\r\n\r\nMIN.distance(P1, {P3, P4, P5}) = 1.32;\r\n\r\nMIN.distance(P2, {P3, P4, P5}) = 1.56;\r\n\r\n继续更新举例矩阵\r\n\r\n|     |  P1   |  P2   |{P3, P4, P5}|\r\n| --- | --- | --- |---|\r\n|  P1	           |  0	   |   0.81 |   1.32|\r\n|  P2	           |  0.81   | 0	   |1.56|\r\n|  {P3, P4, P5}   |   1.32  |  1.56  |  0|\r\n\r\n接着继续找出距离最近的两个簇，P1, P2。\r\n\r\n合并 P1, P2 为 {P1, P2}，根据 MIN 原则继续更新矩阵：\r\n\r\nMIN.distance({P1,P2}, {P3, P4, P5}) = 1.32\r\n\r\n继续更新举例矩阵\r\n\r\n|     |  {P1, P2}   |   {P3, P4, P5}  |\r\n| --- | --- | --- |\r\n|   {P1, P2}  |   0  | 1.32    |\r\n|   {P3, P4, P5}  |   1.32  |  0   |\r\n\r\n最终合并剩下的这两个簇即可获得最终结果，如下图：\r\n\r\n![](http://cdn.pinsily.site/1538913027029.png)\r\n\r\nMAX，组平均算法流程同理，只是在更新矩阵时将上述计算簇间距离变为簇间两点最大欧式距离，和簇间所有点平均欧式距离即可\r\n\r\n----------\r\n### 优缺点\r\n优点：1，距离和规则的相似度容易定义，限制少；2，不需要预先制定聚类数；3，可以发现类的层次关系；4，可以聚类成其它形状\r\n\r\n缺点：1，计算复杂度太高；2，奇异值也能产生很大影响；3，算法很可能聚类成链状\r\n\r\n----------', '1537103132124.jpg', '2018-10-07 11:53:00', '2019-03-30 14:21:27', 'p', '我们坐在时间的列车上，却不知到目的地是何方', 102, 0, 0, 'pinsily', 14);
INSERT INTO `article` VALUES (132, '聚类算法 -- DBSCAN 算法', '---\r\n\r\n![](http://cdn.pinsily.site/1537103132118.png)\r\n\r\n<p><center>当佛已无能为力，魔渡众生</center></p>\r\n\r\n\r\n------\r\n### 转载\r\n> [https://www.ibm.com/developerworks/cn/analytics/library/ba-1607-clustering-algorithm/index.html#N100CF](https://www.ibm.com/developerworks/cn/analytics/library/ba-1607-clustering-algorithm/index.html#N100CF)\r\n\r\n----------\r\n### 简要说明\r\nDBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种基于密度的空间聚类算法。该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合\r\n\r\n该算法利用基于密度的聚类的概念，即要求聚类空间中的一定区域内所包含对象（点或其他空间对象）的数目不小于某一给定阈值。DBSCAN算法的显著优点是聚类速度快且能够有效处理噪声点和发现任意形状的空间聚类。但是由于它直接对整个数据库进行操作且进行聚类时使用了一个全局性的表征密度的参数，因此也具有两个比较明显的弱点：\r\n\r\n（1）当数据量增大时，要求较大的内存支持I/O消耗也很大\r\n\r\n（2）当空间聚类的密度不均匀、聚类间距差相差很大时，聚类质量较差\r\n\r\n\r\n----------\r\n### 算法流程\r\n1. 设定扫描半径 Eps, 并规定扫描半径内的密度值。若当前点的半径范围内密度大于等于设定密度值，则设置当前点为核心点；若某点刚好在某核心点的半径边缘上，则设定此点为边界点；若某点既不是核心点又不是边界点，则此点为噪声点\r\n2. 删除噪声点\r\n3. 将距离在扫描半径内的所有核心点赋予边进行连通\r\n4. 每组连通的核心点标记为一个簇\r\n5. 将所有边界点指定到与之对应的核心点的簇总\r\n\r\n\r\n----------\r\n### 算法举例\r\n\r\n![](http://cdn.pinsily.site/1538915054680.png)\r\n\r\n如上图坐标系所示，我们设定扫描半径 Eps 为 1.5，密度阈值 threshold 为 3，则通过上述算法过程，我们可以得到下图：\r\n\r\n![](http://cdn.pinsily.site/1538915079075.png)\r\n\r\n通过计算各个点之间的欧式距离及其所在扫描半径内的密度值来判断这些点属于核心点，边界点或是噪声点。因为我们设定了扫描半径为 1.5，密度阈值为 3，所以：\r\n\r\n- P0 点为边界点，因为在以其为中心的扫描半径内只有两个点 P0 和 P1\r\n- P1 点为核心点，因为在以其为中心的扫描半径内有四个点 P0,P1,P2,P4\r\n- P8 为噪声点，因为其既非核心点，也非边界点\r\n- 其他点依次类推\r\n\r\n----------', '1537103132131.jpg', '2018-10-07 12:53:00', '2019-04-05 16:28:41', 'p', '当佛已无能为力，魔渡众生', 178, 0, 0, 'pinsily', 14);
INSERT INTO `article` VALUES (133, '分类算法 -- 朴素贝叶斯', '---\r\n\r\n![](http://cdn.pinsily.site/1537103132135.jpg)\r\n\r\n<p><center>生之本质在于死。因此只有乐于生的人才能真正不感到死之苦恼 - 蒙田随笔</center></p>\r\n\r\n\r\n------\r\n### 简单说明\r\n贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类，这里讲解最简单的朴素贝叶斯分类算法\r\n\r\n----------\r\n### 贝叶斯定理\r\n贝叶斯定理基于条件概率，P(A|B)表示在事件B已经发生的情况下，事件A发生的概率\r\n\r\n条件概率下有一条很有用的求解公式：\r\n\r\n<img src=\"https://latex.codecogs.com/gif.latex?P(A|B)=\\frac{P(AB)}{P(B)}\" title=\"P(A|B)=\\frac{P(AB)}{P(B)}\" />\r\n\r\n这条公式经过简单的两步推导就可以推出贝叶斯定理了\r\n\r\n<img src=\"https://latex.codecogs.com/gif.latex?P(A|B)=\\frac{P(B|A)*P(A)}{P(B)}\" title=\"P(A|B)=\\frac{P(B|A)*P(A)}{P(B)}\" />\r\n\r\n----------\r\n### 朴素贝叶斯分类流程\r\n\r\n1. 设 <img title=\"x=\\{a_1,a_2,...,a_m\\}\" src=\"http://latex.codecogs.com/gif.latex?x=\\{a_1,a_2,...,a_m\\}\" alt=\"\">为一个待分类项，而每个a为x的一个特征属性\r\n2. 有类别集合<img title=\"C=\\{y_1,y_2,...,y_n\\}\" src=\"http://latex.codecogs.com/gif.latex?C=\\{y_1,y_2,...,y_n\\}\" alt=\"\">\r\n3. 计算<img title=\"P(y_1|x),P(y_2|x),...,P(y_n|x)\" src=\"http://latex.codecogs.com/gif.latex?P(y_1|x),P(y_2|x),...,P(y_n|x)\" alt=\"\">\r\n4. 如果<img title=\"P(y_k|x)=max\\{P(y_1|x),P(y_2|x),...,P(y_n|x)\\}\" src=\"http://latex.codecogs.com/gif.latex?P(y_k|x)=max\\{P(y_1|x),P(y_2|x),...,P(y_n|x)\\}\" alt=\"\">，则<img title=\"x \\in y_k\" src=\"http://latex.codecogs.com/gif.latex?x \\in y_k\" alt=\"\">\r\n\r\n所以现在的目的是求出第三步中的x属于各类别的概率\r\n\r\n1. 找到一个已知分类的待分类项集合，这个集合叫做训练样本集\r\n2. 统计得到在各类别下各个特征属性的条件概率估计。即<img title=\"P(a_1|y_1),P(a_2|y_1),...,P(a_m|y_1);P(a_1|y_2),P(a_2|y_2),...,P(a_m|y_2);...;P(a_1|y_n),P(a_2|y_n),...,P(a_m|y_n)\" src=\"http://latex.codecogs.com/gif.latex?P(a_1|y_1),P(a_2|y_1),...,P(a_m|y_1);P(a_1|y_2),P(a_2|y_2),...,P(a_m|y_2);...;P(a_1|y_n),P(a_2|y_n),...,P(a_m|y_n)\" alt=\"\">\r\n3. 如果各个特征属性是条件独立的，则根据贝叶斯定理有如下推导：\r\n<img title=\"P(y_i|x)=\\frac{P(x|y_i)P(y_i)}{P(x)}\" src=\"http://latex.codecogs.com/gif.latex?P(y_i|x)=\\frac{P(x|y_i)P(y_i)}{P(x)}\" alt=\"\">\r\n4. 因为分母对于所有类别为常数，因为我们只要将分子最大化皆可。又因为各特征属性是条件独立的，所以有：\r\n<img title=\"P(x|y_i)P(y_i)=P(a_1|y_i)P(a_2|y_i)...P(a_m|y_i)P(y_i)=P(y_i)\\prod^m_{j=1}P(a_j|y_i)\" src=\"http://latex.codecogs.com/gif.latex?P(x|y_i)P(y_i)=P(a_1|y_i)P(a_2|y_i)...P(a_m|y_i)P(y_i)=P(y_i)\\prod^m_{j=1}P(a_j|y_i)\" alt=\"\">\r\n\r\n\r\n----------\r\n### 算法示例\r\n> 转载：[https://blog.csdn.net/xo3ylAF9kGs/article/details/78630937](https://blog.csdn.net/xo3ylAF9kGs/article/details/78630937)\r\n\r\n挑苹果时，一般红润而圆滑的果子都是好苹果，泛青无规则的一般都比较一般，现在根据之前几次买过的苹果，已经验证过了10个苹果，主要根据大小，颜色和形状这三个特征，来区分是好是坏，如下：\r\n\r\n|编号|大小|颜色| 形状|好果|\r\n|----|----|----|----|----|\r\n|1|小|青色|非规则|否|\r\n|2|大|红色|非规则|是|\r\n|3| 大|红色|圆形|是|\r\n|4|大| 青色| 圆形|否|\r\n|5|大| 青色|非规则|否|\r\n|6|小|红色|圆形|是|\r\n|7|大|青色|非规则|否|\r\n|8|小|红色|非规则|否|\r\n|9|小|青色|圆形|否|\r\n|10|大|红色|圆形|是|\r\n\r\n现在有一个苹果各属性为 大，红色，圆形，求这个苹果更大概率属于那种果\r\n\r\n这里设结果为c，则P(c)为\r\n\r\nP(c=好果）=  4/10\r\n\r\nP(c=一般) =  6/10\r\n\r\n接下来求解每个属性的类条件概率：\r\nP(大小=大 | c=好果)  =   3/4\r\n\r\nP(颜色=红色 | c=好果) = 4/4\r\n\r\nP(形状=圆形 | c=好果) = 3/4\r\n\r\nP(大小=大 | c=一般) =  3/6\r\n\r\nP(颜色=红色 | c=一般) = 1/6\r\n\r\nP(形状=圆形 | c=一般) =  2/6\r\n\r\n现在需要求解的是\r\n\r\nP1(c=好果|大小=大,颜色=红，形状=红色)\r\n\r\nP2(c=一般果|大小=大,颜色=红，形状=红色)\r\n\r\n两个概率，由贝叶斯定理可得：\r\n\r\nP1 = P(c=好果） * P(大小=大 | c=好果) * P(颜色=红色 | c=好果) * P(形状=圆形 | c=好果)  = 0.225\r\n\r\nP2 = P(c=一般） * P(大小=大 | c=一般) * P(颜色=红色 | c=一般) * P(形状=圆形 | c=一般)  = 0.0167\r\n\r\n比较可得，此苹果更可能为好果\r\n\r\n---------------------\r\n### 评价\r\n优点：对小规模的数据表现很好，适合多分类任务，适合增量式训练\r\n缺点：对输入数据的表达形式很敏感（离散、连续，值极大极小之类的）\r\n\r\n----------', '1537103132135.jpg', '2018-10-07 15:07:00', '2019-04-07 05:10:03', 'p', '生之本质在于死。因此只有乐于生的人才能真正不感到死之苦恼 - 蒙田随笔', 356, 0, 0, 'pinsily', 14);
INSERT INTO `article` VALUES (134, 'django -- 邮件发送', '---\r\n\r\n![](http://csn.pinsily.site/1537103132155.jpg)\r\n\r\n<p><center>一旦有个留恋，就不算是旅行者了</center></p>\r\n\r\n------\r\n### 说明\r\n\r\n趁着有空，就想着把很久以前就像弄的邮件功能给加到博客评论上面，发现资料说Django已经有自带的邮件功能了，就在获取客户端服务器的问题上跳了点坑\r\n\r\n\r\n----------\r\n### 配置\r\n\r\n- settings 中配置好相关变量信息\r\n\r\n``` python\r\nEMAIL_BACKEND = \'django.core.mail.backends.smtp.EmailBackend\'\r\nEMAIL_USE_SSL = True # 这两个必须互斥，只能一个为真\r\nEMAIL_USE_TLS = False\r\nEMAIL_HOST = \'smtp.163.com\'\r\nEMAIL_PORT = 465\r\nEMAIL_HOST_USER = \'13160724868@163.com\'\r\nSERVER_EMAIL = \'13160724868@163.com\'\r\nEMAIL_HOST_PASSWORD = \'*********\'\r\nDEFAULT_FROM_EMAIL = EMAIL_HOST_USER\r\n```\r\n\r\n[163免费邮箱客户端](http://help.163.com/09/1223/14/5R7P3QI100753VB8.html)\r\n\r\n有一个比较坑的地方在于 EMAIL_HOST_PASSWORD 的值不是登录 163 邮箱的密码，而是授权码，不然会报错 `SMTPAuthenticationError` \r\n\r\n[获取授权码](https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2cda80145a1742516)\r\n\r\n然后就可以直接在需要发送邮件的地方直接调用函数实现功能了\r\n\r\n``` python\r\n# 评论后发送邮件\r\nsend_mail(\r\n    \'博客有新评论\',\r\n    \'评论者：\\n\' + comment.user_name + \'\\n\\r评论内容：\\n\' + comment.text + \'\\n\\r评论者邮箱：\\n\' + comment.user_email,\r\n    \'13160724868@163.com\',\r\n    [\'2608927151@qq.com\']\r\n)\r\n```\r\n\r\n参数分别为 主题，内容，发件人，收件人集合(可多个)\r\n\r\n\r\n----------\r\n### 参考\r\n> [https://blog.csdn.net/Creabine/article/details/53857826](https://blog.csdn.net/Creabine/article/details/53857826)\r\n> [https://my.oschina.net/chenmoxuan/blog/1835322](https://my.oschina.net/chenmoxuan/blog/1835322)\r\n>[https://my.oschina.net/chenmoxuan/blog/1835322](https://my.oschina.net/chenmoxuan/blog/1835322)', '1537103132155.jpg', '2018-11-15 03:26:00', '2019-04-07 16:25:15', 'p', '趁着有空，就想着把很久以前就像弄的邮件功能给加到博客评论上面，发现资料说Django已经有自带的邮件功能了，', 222, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (135, 'django -- 部署 ‘ascii’ codec can’t encode characters in position', '---\r\n\r\n![](http://csn.pinsily.site/1537103132159.jpg)\r\n\r\n<p><center>奚者为奴，怜我奚儿，囚于闺阁囹圄，终不得见世间川峦，人生百态 -- 昭奚旧草</center></p>\r\n\r\n------\r\n### 问题排查\r\n真的是第一次在 py3 中遇到编码错误的问题\r\n\r\n- 本地一切正常\r\n- 服务器端博客一出现中文就报错\r\n- 服务器使用` python -c \"import sys; print(sys.getfilesystemencoding())\"` 获取到的编码为 `utf-8`,也是 Python3 默认的编码，没什么问题\r\n- 网上的大部分解决方法压根不起作用，py3 中直接报错\r\n\r\n``` python\r\nimport sys\r\nreload(sys)\r\nsys.setdefaultencoding(\'utf-8\')\r\n```\r\n\r\n- 然后觉得是部署环境的问题了，突然想到使用到的进程管理工具 supervisor 也是 Python 写的，就往这个方向找到了解决方法，在配置中添加环境变量 `environment`，具体的原因可参考链接 \r\n\r\n``` shell\r\n[program:django]\r\ncommand=/root/anaconda3/bin/uwsgi --emperor /etc/uwsgi/vassals\r\nautostart=true\r\nautorestart=true\r\nuser=root\r\nlog_stderr=true\r\nlogfile=/var/log/uwsgi_django.log\r\nenvironment=LANG=\"en_US.utf8\", LC_ALL=\"en_US.UTF-8\", LC_LANG=\"en_US.UTF-8\"\r\n```\r\n\r\n----------\r\n### 参考\r\n[supervisor遇到的坑](https://www.zoulei.net/2016/12/25/supervisor_may_be_sucks/)\r\n\r\n----------', '1537103132159.jpg', '2018-11-16 00:51:00', '2019-04-09 21:48:27', 'p', '奚者为奴，怜我奚儿，囚于闺阁囹圄，终不得见世间川峦，人生百态 -- 昭奚旧草', 258, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (136, 'django -- rss 订阅', '---\r\n\r\n![](http://csn.pinsily.site/1537103132165.jpg)\r\n\r\n<p><center>最熟悉你我的街，已是人去夕阳的斜</center></p>\r\n\r\n------\r\n### rss 订阅\r\nRSS是一个缩写的英文术语，在英文中被认为有几个不同的源头，并被不同的技术团体做不同的解释。它即可以是\"Rich Site Summary\"（丰富站点摘要），或\"RDF Site Summary\"（RDF站点摘要），也可以是\"Really Simple Syndication\"（真正简易聚合）。现在已有的有Netscape, 1.0 (RSS-DEV版本),和 0.9x and 2.0 (UserLand Software版本) 0.9x和2.0。不过几乎所有能支持RSS的程序都可以浏览不同版本的RSS\r\n\r\nRSS是基于文本的格式。它是XML（可扩展标识语言）的一种形式。通常RSS文件都是标为XML，RSS files(通常也被称为RSS feeds或者channels)通常只包含简单的项目列表。一般而言，每一个项目都含有一个标题，一段简单的介绍，还有一个URL链接（比如是一个网页的地址）。其他的信息，例如日期，创建者的名字等等，都是可以选择的\r\n\r\nRSS是站点用来和其他站点之间共享内容的一种简易方式（也叫聚合内容），通常被用于新闻和其他按顺序排列的网站，例如Blog。一段项目的介绍可能包含新闻的全部介绍，Blog post等等。或者仅仅是额外的内容或者简短的介绍。这些项目的链接通常都能链接到全部的内容。网络用户可以在客户端借助于支持RSS的新闻聚合工具软件（例如NewzCrawler、FeedDemon），在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。网站提供RSS输出，有利于让用户发现网站内容的更新。\r\n\r\n----------\r\n### 使用 Django Feed 类\r\n现在已经知道，要实现rss订阅的目的主要是生成 xml 制定格式的文档即可，django 中已经有了相应的类实现\r\n\r\n```python\r\n# blog/feed.py\r\n\r\nimport markdown\r\nfrom django.contrib.syndication.views import Feed\r\n\r\nfrom . import models\r\n\r\n\r\nclass AllArticalRssFeed(Feed):\r\n    title = \"TuClown\"\r\n    link = \"/\"\r\n    description = \"TuClown Detail\"\r\n\r\n    # 所有的文章集合\r\n    def items(self):\r\n        return models.Article.objects.all()\r\n\r\n    # 显示的文章标题\r\n    def item_title(self, item):\r\n        return \"{0}\".format(item.title)\r\n\r\n    # 文章的描述，这里将文章内容作为描述，并将markdown解析为html\r\n    def item_description(self, item):\r\n        # markdown to html\r\n        extensions = [\'markdown.extensions.extra\',\r\n                      \'markdown.extensions.codehilite\',\r\n                      \'markdown.extensions.tables\',\r\n                      \'markdown.extensions.toc\']\r\n\r\n        return markdown.markdown(item.body, extensions=extensions)\r\n\r\n```\r\n\r\n\r\n----------\r\n### 配置 url\r\n\r\n```python\r\n\r\nfrom blog.feeds import AllArticalRssFeed\r\n\r\nurlpatterns = [\r\n    ...\r\n    path(\"rss/\", AllArticalRssFeed(), name=\"rss\"),\r\n    ...\r\n]\r\n```\r\n\r\n----------\r\n### 生成\r\n\r\n![](http://csn.pinsily.site/1542331999863.png)\r\n\r\n----------', '1537103132170.jpg', '2018-11-16 01:35:00', '2019-04-01 16:24:43', 'p', 'RSS是一个缩写的英文术语，在英文中被认为有几个不同的源头，并被不同的技术团体做不同的解释。它即可以是\"Ri', 154, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (137, 'django -- 日志 logging', '---\r\n\r\n![](http://csn.pinsily.site/1537103132177.jpg)\r\n\r\n<p><center>你是我的半截的诗，不许别人更改一个字</center></p>\r\n\r\n------\r\n### 说明\r\n今天在看《python linux系统管理与自动化运维》这本书的时候，里面讲到了 python 上的 logging 日志模块，就找找资料添加到 Django 上了\r\n\r\n最好的资料还是在于官网：https://docs.djangoproject.com/en/2.1/topics/logging/\r\n\r\n---\r\n### 简单介绍\r\nDjango 有自己自带的日志管理，不过基本上还是基于 logging 模块建立起来的，只是对用户来说方便了很多\r\n\r\n在日志上，有四个功能块\r\n- loggers\r\n- handlers\r\n- filters\r\n- formatters\r\n\r\n这四个功能块的流向顺序如下：\r\n```shell\r\n                       formatter\r\nlogger ----> handler ---------------->  files, emails, console\r\n                         filter\r\n```\r\n\r\n每个功能块的作用及功能具体可以看官网文档的介绍\r\n\r\n此外，日志中还有五个日志等级\r\n\r\n- logger.debug()\r\n- logger.info()\r\n- logger.warning()\r\n- logger.error()\r\n- logger.critical()\r\n\r\n\r\n然后，我们只要在 settings.py 文件上添加这四个功能块的配置项就可以了\r\n\r\n很重要的一点是，只要配置好了，Django就会自动解析这些配置，并执行。所以就省掉了我们很多功夫去填写\r\n\r\n原理就不多说，直接配置好代码\r\n\r\n```python\r\nLOGGING = {\r\n    \'version\': 1,\r\n    \'disable_existing_loggers\': False,\r\n    \'formatters\': {\r\n        \'verbose\': {\r\n            \'format\': \'{levelname} {message}\',\r\n            \'style\': \'{\',\r\n        },\r\n        \'simple\': {\r\n            \'format\': \'{levelname} {message}\',\r\n            \'style\': \'{\',\r\n        },\r\n    },\r\n    \'filters\': {\r\n    },\r\n    \'handlers\': {\r\n        \'file\': {\r\n            \'level\': \'DEBUG\',\r\n            \'class\': \'logging.FileHandler\',\r\n            \'filename\': os.path.join(BASE_DIR, \'debug.log\'),\r\n            \'formatter\': \'verbose\',\r\n        },\r\n        \'console\': {\r\n            \'level\': \'INFO\',\r\n            \'class\': \'logging.StreamHandler\',\r\n            \'formatter\': \'verbose\',\r\n        },\r\n        \'mail_admins\': {\r\n            \'level\': \'ERROR\',\r\n            \'class\': \'django.utils.log.AdminEmailHandler\',\r\n        }\r\n    },\r\n    \'loggers\': {\r\n        \'django\': {\r\n            \'handlers\': [\'file\'],\r\n            \'level\': \'DEBUG\',\r\n            \'propagate\': True,\r\n        },\r\n        \'django_file\': {\r\n            \'handlers\': [\'file\'],\r\n            \'level\': \'DEBUG\',\r\n            \'propagate\': True,\r\n        },\r\n        \'django.request\': {\r\n            \'handlers\': [\'mail_admins\'],\r\n            \'level\': \'ERROR\',\r\n            \'propagate\': False,\r\n        },\r\n        \'myproject.custom\': {\r\n            \'handlers\': [\'console\', \'mail_admins\'],\r\n            \'level\': \'INFO\',\r\n        }\r\n    },\r\n}\r\n```\r\n\r\n因为平时不需要特别多的日志分析，所以直接定义 等级+信息 就足够了\r\n\r\n更多的格式化参数可以参考使用：https://docs.python.org/3/library/logging.html#logrecord-attributes\r\n\r\n然后 DEBUG 级别及以上的都会输出到文件 debug.log 中\r\n\r\n其他的是官网上抄的，像 ERROR 级别的可以发邮件给管理员，这个还没有验证，也就不敢妄下结论了\r\n\r\n----', '1537103132177.jpg', '2018-11-16 01:58:00', '2019-04-04 02:40:55', 'p', '今天在看《python linux系统管理与自动化运维》这本书的时候，里面讲到了 python 上的 log', 180, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (138, 'win10 -- Mongodb 4.0 安装配置', '![](http://csn.pinsily.site/1537103132293.jpg)\r\n\r\n<p><center>我认为最深沉的爱；莫过于你离开以后；我活成了你的样子</center></p>\r\n\r\n\r\n------\r\n### 下载\r\n> [https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community)\r\n\r\n![](http://csn.pinsily.site/1548592756225.png)\r\n\r\n----------\r\n### 安装\r\n\r\n![enter description here](http://csn.pinsily.site/1548592816456.png)\r\n\r\n\r\n> Service failed to start. Verify that you have sufficient privileges to start system services\r\n\r\n选择好安装路径\r\n\r\n![](http://csn.pinsily.site/1548592853184.png)\r\n\r\n选择好数据和日志的存放位置及切换到本地服务\r\n\r\n![](http://csn.pinsily.site/1548595486585.png)\r\n\r\n----------\r\n### 配置\r\n\r\n#### 配置文件\r\n\r\n在安装目录下新建 mongodb.cfg，选择此目录是因为方便管理 \r\n\r\n日志和数据存储的文件夹和安装时的一致，mongod.log 文件不用自己生成，但文件夹需要提前建好\r\n\r\n``` shell\r\nsystemLog:\r\n    destination: file    \r\n    path: F:\\MongoDB\\log\\mongod.log\r\nstorage:\r\n    dbPath: F:\\MongoDB\\data\\db\r\n```\r\n\r\n\r\n#### 配置生效\r\n\r\n``` shell\r\nmongod --config \"C:\\Program Files\\MongoDB\\Server\\4.0\\mongodb.cfg\" --install\r\n```\r\n\r\n没有输出则表示设置成功，配置文件需要使用绝对路径且需加双引号\r\n\r\n----------\r\n### 错误问题\r\n> 参考：[https://blog.csdn.net/qq_20084101/article/details/82261195](https://blog.csdn.net/qq_20084101/article/details/82261195)\r\n在安装之后，弹出了服务无法启动的问题\r\n\r\n![](http://csn.pinsily.site/1553425487044.png)\r\n\r\n#### 解决方法\r\n在 bin 目录下找到 mongod.cfg，把隐藏在最后一行的 `mp:`给注释掉，这里发生了错误的配置，不知道是不是4.0特有的bug\r\n\r\n------\r\n### Linux 下的安装配置\r\n\r\n``` shell\r\n```shell \r\n# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-4.0.6.tgz\r\n# tar -zxvf mongodb-linux-x86_64-ubuntu1604-4.0.6.tgz\r\n# mkdir mongodb\r\n# mv mongodb-4.0.6/ mongodb\r\n# cd mongodb\r\n# mkdir data\r\n# mkdir logs\r\n# mkdir etc\r\n# cd logs\r\n# touch mongo.log\r\n# cd ../etc\r\n# vim mongo.conf\r\n\r\ndbpath=/opt/mongodb/data\r\nlogpath=/opt/mongodb/logs/mongo.log\r\nlogappend=true\r\njournal=true\r\nquiet=true\r\nport=27017\r\n\r\n# vim ~/.bashrc\r\nexport PATH=$PATH:/opt/mongodb/mongodb-4.0.6/bin\r\n\r\n# source ~/.bashrc\r\n# mongod -f /opt/mongodb/etc/mongo.conf\r\n```', '1537103132293.jpg', '2019-03-24 11:47:00', '2019-04-08 11:32:18', 'p', '我认为最深沉的爱；莫过于你离开以后；我活成了你的样子', 12, 0, 0, 'pinsily', 12);
INSERT INTO `article` VALUES (139, 'git -- 回滚撤销', '---\r\n\r\n\r\n![](http://csn.pinsily.site/1537103132307.jpg)\r\n\r\n<p><center>选择最难的路，在暗夜里看成群的星星涌来</center></p>\r\n\r\n\r\n------\r\n### 回滚\r\n\r\n> 总结关于 git 代码回滚撤销的方法\r\n\r\n``` shell\r\ngit fetch --all  \r\ngit reset --hard origin/master \r\ngit pull\r\n```\r\n\r\n----------\r\n### 已经 add，但未 commit\r\n\r\n``` shell\r\ngit rm --cache snake.py\r\n```\r\n\r\n直接 `git rm snake.py` 本地文件也会被删除 \r\n\r\n----------\r\n### 文件在add后被修改，想撤回add的那个版本\r\n\r\n``` shell\r\ngit add snake.py\r\nvim snake.py\r\ngit checkout snake.py\r\n```\r\n\r\n中间 vim 修改的就会无效\r\n\r\n\r\n----------\r\n### 回退到指定版本\r\n\r\n\r\n``` shell\r\ngit reset --hard HEAD^      # 回退到上一个版本\r\ngit reset --hard commit_id  # 会退到指定版本\r\n```\r\n\r\n----------', '1537103132307.jpg', '2019-03-24 12:22:00', '2019-04-08 11:32:27', 'p', '总结关于 git 代码回滚撤销的方法', 12, 0, 0, 'pinsily', 20);
INSERT INTO `article` VALUES (140, 'hadoop -- hive 伪分布式搭建', '---\r\n\r\n![](http://csn.pinsily.site/1537103132298.jpg)\r\n\r\n<p><center>我是一个经常笑的人，可我不是经常开心的人 -- 未闻花名</center></p>\r\n\r\n------\r\n### 环境说明\r\n- ubuntu 16.06\r\n- hadoop 2.9\r\n- hive 2.3.3\r\n\r\n----------\r\n### 下载 hive\r\n> [http://mirrors.hust.edu.cn/apache/hive/hive-2.3.3/apache-hive-2.3.3-bin.tar.gz](http://mirrors.hust.edu.cn/apache/hive/hive-2.3.3/apache-hive-2.3.3-bin.tar.gz)\r\n\r\n解压到 /opt 中并命名为 hive 方便操作\r\n\r\n``` shell\r\npinsily@zhu:/opt$ sudo tar -zxvf apache-hive-2.3.3-bin.tar.gz\r\npinsily@zhu:/opt$ sudo mv apache-hive-2.3.3-bin hive\r\n```\r\n\r\n添加到环境变量\r\n\r\n``` shell\r\npinsily@zhu:/opt$ vim ~/.bashrc\r\n```\r\n\r\n```shell\r\n# hive\r\nHIVW_HOME=/opt/hive\r\nexport PATH=$PATH:/opt/hive/bin\r\n```\r\n\r\n```\r\npinsily@zhu:/opt$ source ~/.bashrc\r\n```\r\n----------\r\n### 安装 mysql\r\n安装服务器端即可\r\n```\r\npinsily@zhu:~$ sudo apt-get install mysql-server\r\n```\r\n\r\n下载 jdbc 依赖包并解压\r\n[https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/)\r\n\r\n将解压后的 `mysql-connector-java-5.1.46.jar` 复制到 `$HIVE_HOME/lib` 中\r\n\r\n``` shell\r\npinsily@zhu:/opt$ sudo cp mysql-connector-java-5.1.46.jar /opt/hive/lib/\r\n```\r\n\r\n为 hive 新建一个 hive 用户\r\n\r\n``` shell\r\n# 创建 hive 数据库\r\nmysql> create database hive;\r\n\r\n# 新建 hive 用户并赋权限\r\nmysql> create user \"hive\"@\"localhost\" identified by \"hive\";\r\n\r\nmysql> grant all privileges on \".\" to \"hive\"@\"localhost\" with grant option;\r\n\r\nmysql> show grants for \"hive\"@\"localhost\";\r\n\r\nmysql> flush privileges;\r\n```\r\n\r\n\r\n----------\r\n修改配置文件\r\n在 conf 目录下获得以下四个文件\r\n```\r\npinsily@zhu:/opt/hive/conf$ sudo cp hive-env.sh.template hive-env.sh\r\npinsily@zhu:/opt/hive/conf$ sudo cp hive-log4j2.properties.template hive-log4j2.properties\r\npinsily@zhu:/opt/hive/conf$ sudo cp hive-exec-log4j2.properties.template hive-exec-log4j2.properties\r\npinsily@zhu:/opt/hive/conf$ sudo cp hive-default.xml.template hive-default.xml\r\n```\r\n\r\n增加环境变量\r\n```shell\r\npinsily@zhu:/opt/hive/conf$ sudo vim hive-env.sh\r\n\r\n# set env variable pinsily 2018.08.05\r\nexport HADOOP_HOME=/opt/hadoop\r\nexport JAVA_HOME=/opt/java\r\nexport HIVE_HOME=/opt/hive\r\nexport HIVE_CONF_DIR=/opt/hive/conf\r\nexport HIVE_AUX_JARS_PATH=/opt/hive/lib\r\n```\r\n\r\n\r\n```\r\npinsily@zhu:/opt/hive/conf$ sudo vim hive-site.xml\r\n\r\n将以下字段\r\n${system:java.io.tmpdir}/${system:user.name}\r\n${system:java.io.tmpdir}/${hive.session.id}_resources\r\n${system:java.io.tmpdir}/${system:user.name}/operation_logs\r\n\r\n分别替换为\r\n/tmp/hive\r\n/tmp/hive/resources\r\n/tmp/hive/operation_logs\r\n```\r\n\r\n并新建相应的目录\r\n\r\n``` shell\r\npinsily@zhu:/tmp$ sudo mkdir hive\r\npinsily@zhu:/tmp$ sudo mkdir hive/resources\r\npinsily@zhu:/tmp$ sudo mkdir hive/operation_logs\r\n```\r\n\r\n\r\n----------\r\n### Hive 使用 MySQL\r\n> 参考：[https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin](https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin)\r\n\r\n需要在 hive-site.xml 中配置以下参数的 value：\r\n\r\n``` shell\r\njavax.jdo.option.ConnectionURL\r\n\r\n<property>\r\n    <name>javax.jdo.option.ConnectionURL</name>\r\n    <value>jdbc:mysql://localhost:3306/hive?createDatabaseIfNoExist=true&amp;useSSL=false</value>\r\n    <description></description>\r\n</property>\r\n\r\n<property>\r\n    <name>javax.jdo.option.ConnectionDriverName</name>\r\n    <value>com.mysql.jdbc.Driver</value>\r\n    <description>Driver class name for a JDBC metastore</description>\r\n</property>\r\n\r\n<property>\r\n    <name>javax.jdo.option.ConnectionUserName</name>\r\n    <value>hive</value>\r\n    <description>Username to use against metastore database</description>\r\n</property>\r\n\r\n<property>\r\n    <name>javax.jdo.option.ConnectionPassword</name>\r\n    <value>hive</value>\r\n    <description>password to use against metastore database</description>\r\n</property>\r\n\r\n```\r\n\r\n> 需要注意的是，在 xml 中，必须使用 `&amp;` 表示 `&`，不然启动时会报错\r\n\r\n\r\n----------\r\n### 启动\r\n\r\n``` shell\r\npinsily@zhu:/opt/hive/conf$ hive\r\n```\r\n\r\n![](http://owgxfd8jv.bkt.clouddn.com/1533476021497.png)\r\n\r\n\r\n\r\n----------\r\n### 问题\r\n1. Class path contains multiple SLF4J bindings\r\n\r\n![](http://owgxfd8jv.bkt.clouddn.com/1533471222986.png)\r\n\r\n解决方法：两个log4j冲突了，使用hadoop的，将hive的删除\r\n\r\n``` shell\r\npinsily@zhu:/opt/hive$ sudo rm -f lib/log4j-slf4j-impl-2.6.2.jar\r\n```\r\n\r\n2. Exception in thread \"main\" java.lang.RuntimeException: java.io.IOException: Permission denied\r\n\r\n解决方法： 设置好临时目录的权限\r\n\r\n``` shell\r\npinsily@zhu:/opt/hive$ sudo chown pinsily -R /tmp/hive\r\n```\r\n\r\n![](http://owgxfd8jv.bkt.clouddn.com/1533473769397.png)\r\n\r\n3. java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient\r\n![](http://owgxfd8jv.bkt.clouddn.com/1533475370141.png)\r\n\r\n解决方法：查看mysql是否创建好相应的数据库，即 hive-site.xml 中 `javax.jdo.option.ConnectionURL` 的value中的hive，然后进行初始化：\r\n\r\n``` shell\r\npinsily@zhu:/opt/hive/conf$ schematool -dbType mysql -initSchema\r\n```', '1537103132298.jpg', '2019-03-24 12:27:00', '2019-04-08 11:32:23', 'p', '之前整理的部署，碰到了好多坑后的笔记', 8, 0, 0, 'pinsily', 18);
INSERT INTO `article` VALUES (141, 'linux -- 网络工具', '---\r\n![][1]\r\n\r\n\r\n\r\n<p><center>君看双眼色，不语似无忧</center></p>\r\n\r\n\r\n------\r\n### 查询网络服务和端口\r\n- 列出所有端口\r\n```\r\n$ netstat -a\r\n```\r\n\r\n- 列出所有 tcp 端口:\r\n```\r\n$ netstat -at\r\n```\r\n\r\n- 列出所有有监听的服务状态:\r\n```\r\n$ netstat -l\r\n```\r\n\r\n\r\n----------\r\n### 网络路由\r\n- 查看路由状态\r\n```\r\n$ route -n\r\n```\r\n\r\n- 发送ping包\r\n```\r\n$ ping IP\r\n$ ping domain\r\n```\r\n\r\n- 探测前往地址IP的路由路径\r\n```\r\n$ traceroute IP\r\n```\r\n\r\n- DNS查询\r\n```\r\n$ host domine\r\n```\r\n\r\n- 反向DNS查询\r\n```\r\n$ host IP\r\n```\r\n\r\n\r\n----------\r\n### 镜像下载\r\n```\r\n$ wget url\r\n```\r\n\r\n常用选项\r\n- limit-rate :下载限速\r\n- o：指定日志文件；输出都写入日志；\r\n- c：断点续传\r\n\r\n\r\n----------\r\n\r\n\r\n### ftp sftp lftp ssh\r\n- ssh登录\r\n```\r\n$ ssh username@host\r\n```\r\n\r\n- ftp/sftp 文件传输\r\n```\r\n$ sftp username@host\r\n```\r\n\r\n操作\r\n- get filename 	# 下载文件\r\n- put filename 	# 上传文件\r\n- ls 		# 列出host上当前路径的所有文件\r\n- cd 		# 在host上更改当前路径\r\n- lls 		# 列出本地主机上当前路径的所有文件\r\n- lcd 		# 在本地主机更改当前路径\r\n\r\n\r\n----------\r\n\r\n\r\n### 网络复制\r\n- 将本地localpath指向的文件上传到远程主机的path路径:\r\n```\r\n$ scp localpath ID@host:path\r\n```\r\n\r\n- 以ssh协议，遍历下载path路径下的整个文件系统，到本地的localpath:\r\n```\r\n$ scp -r ID@site:path localpath\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n  [1]: http://owgxfd8jv.bkt.clouddn.com/muzhchina.jpg', '1537103132278.jpg', '2019-03-24 12:30:00', '2019-04-08 11:32:37', 'p', '整理常用的 linux 网络工具，方便使用', 8, 0, 0, 'pinsily', 3);
INSERT INTO `article` VALUES (142, 'django2.0 -- xadmin', '---\r\n\r\n![](http://csn.pinsily.site/5252aff10a3742ffba088f1d79d2fcae_th.png)\r\n\r\n<p><center>你将不再是道具，而是人如其名的人</center></p>\r\n\r\n\r\n------\r\n### 下载安装\r\n现在安装有两种方法，一种是直接 pip 安装，一种是 django 的 app 扩展\r\n\r\n#### pip\r\n\r\n``` shell\r\npip install git+git://github.com/sshwsfc/xadmin.git@django2\r\n```\r\n\r\n\r\n#### app 扩展\r\n使用 git 克隆对应版本的xadmin：[https://github.com/sshwsfc/xadmin/tree/django2](https://github.com/sshwsfc/xadmin/tree/django2)放到项目中，并安装对应的依赖库\r\n\r\n``` shell\r\ngit clone -b django2 https://github.com/sshwsfc/xadmin.git\r\n\r\npip install django-crispy-forms\r\npip install django-formtools\r\npip install httplib2\r\npip install future\r\npip install six\r\npip install django-import-export\r\n```\r\n\r\n----------\r\n### setting.py 中注册 app\r\n\r\n``` shell\r\n\'xadmin\',\r\n\'crispy_forms\',\r\n\'reversion\',\r\n```\r\n\r\n\r\n----------\r\n### 主 urls.py 配置\r\n\r\n``` python\r\nimport xadmin\r\nfrom xadmin.plugins import xversion\r\n \r\nxadmin.autodiscover()\r\nxversion.register_models() \r\n \r\nurlpatterns = [\r\n    path(\'xadmin/\', xadmin.site.urls),\r\n]\r\n```\r\n\r\n路由 xadmin.site.urls 不要加引号也不要放在 include() 中， 不然会报错\r\n\r\n----------\r\n### 数据库迁移\r\n\r\n``` shell\r\npython manage.py makemigrations\r\npython manage.py migrate\r\n```\r\n\r\n----------\r\n### app 使用 xadmin\r\n在 app 目录下新建 adminx.py, 进行注册， xadmin 会自动检测\r\n\r\n``` python\r\nimport xadmin\r\nfrom . import models\r\n\r\n\r\nclass UserProfileAdmin(object):\r\n    # 要列出的字段\r\n    list_display = (\'id\', \'username\', \'gender\', \'email\', \'location\', \'session\', \'avatar\', \'is_active\',)\r\n    # 可以搜索的字段\r\n    search_fields = (\'name\',)\r\n    # 列出可以编辑的字段\r\n    list_editable = (\'gender\', \'location\',)\r\n    # 右侧过滤条件\r\n    list_filter = (\'add_time\',)\r\n    # icon\r\n    model_icon = \"fa fa-group\"\r\n    # 下拉框搜索，当有外键指向他时会以ajax方式加载，数据量过大时很有用\r\n    relfield_style = \'fk-ajax\'\r\n    ordering = [\'id\']\r\n    # 后台可选刷新频率\r\n    refresh_times = [3, 5]\r\n\r\n# 如果报错 已注册，可以 unregister 先注销\r\n# xadmin.site.unregister(models.UserProfile)\r\nxadmin.site.register(models.UserProfile, UserProfileAdmin)\r\n```\r\n\r\n\r\n----------\r\n### 自定义\r\n#### 基础配置\r\n\r\n``` python\r\nfrom xadmin import views\r\n\r\nclass BaseSetting(object):\r\n    # 开启主题功能\r\n    enable_themes = True\r\n    # 支持切换主题\r\n    use_bootswatch = True\r\n\r\n\r\nxadmin.site.register(views.BaseAdminView, BaseSetting)\r\n```\r\n\r\n\r\n### 全局配置\r\n\r\n```python\r\nfrom news import models as news_models\r\nfrom webUser import models as user_models\r\n\r\nclass GlobalSettings(object):\r\n    site_title = \"新闻聚合系统\"\r\n    site_footer = \"Copyright @2019-2020 新闻聚合系统 All Rights Reserved\"\r\n    # 菜单可折叠\r\n    menu_style = \"accordion\"\r\n\r\n    # 自定义新增菜单栏\r\n    def get_site_menu(self):\r\n        return (\r\n            {\'title\': \'News\', \'menus\': (\r\n                {\'title\': \'新闻\', \'url\': self.get_model_url(\r\n                    news_models.NewPost, \'changelist\')},\r\n            )},\r\n            {\'title\': \'User\', \'menus\': (\r\n                {\'title\': \'User\', \'url\': self.get_model_url(\r\n                    user_models.UserProfile, \'changelist\')},\r\n                {\'title\': \'VerifyCode\', \'url\': self.get_model_url(\r\n                    user_models.VerifyCode, \'changelist\')},\r\n            )},\r\n        )\r\n\r\n    # 可以重写此方法，使右侧菜单栏只有上面添加的项\r\n    # def get_nav_menu(self):\r\n    #    # 直接返回新增的菜单栏，源码中还有很大一部分的合并功能\r\n    #    site_menu = list(self.get_site_menu() or [])\r\n    #    return site_menu\r\n\r\n\r\nxadmin.site.register(views.CommAdminView, GlobalSettings)\r\n```\r\n\r\n----------', '5252aff10a3742ffba088f1d79d2fcae_th.png', '2019-03-24 15:00:00', '2019-04-08 11:32:18', 'p', '关于 xadmin 的各种资料整合和各种坑的避免吧', 16, 0, 0, 'pinsily', 1);
INSERT INTO `article` VALUES (143, 'window -- sublime text 3 配置', '---\r\n\r\n![](http://csn.pinsily.site/1537103132248.jpg)\r\n\r\n<p><center>我的每一个动作都有你的印记</center></p>\r\n\r\n------\r\n### 下载\r\n> [https://www.sublimetext.com/3](https://www.sublimetext.com/3)\r\n\r\n![](http://csn.pinsily.site/1553833739995.png)\r\n\r\n----------\r\n### 安装 package control\r\n代码地址：https://packagecontrol.io/installation\r\n\r\n``` python\r\nimport urllib.request,os,hashlib; h = \'6f4c264a24d933ce70df5dedcf1dcaee\' + \'ebe013ee18cced0ef93d5f746d80ef60\'; pf = \'Package Control.sublime-package\'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( \'http://packagecontrol.io/\' + pf.replace(\' \', \'%20\')).read(); dh = hashlib.sha256(by).hexdigest(); print(\'Error validating download (got %s instead of %s), please try manual install\' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), \'wb\' ).write(by)\r\n```\r\n\r\n将代码在 sublime 终端执行：via the ctrl+` shortcut or the View > Show Console menu\r\n\r\n\r\n----------\r\n### 插件安装\r\n\r\n#### 安装\r\npreferences --> package control -- install package\r\n\r\n\r\n#### 列表\r\n- a file icon\r\n- Emmet\r\n- GitGutter\r\n- Material Theme\r\n- Side Bar\r\n- Anaconda\r\n- CovertToUTF8\r\n- Terminal\r\n- DocBlockr Python\r\n\r\n----------\r\n### 个人配置\r\n\r\n``` json\r\n{\r\n	\"color_scheme\": \"Packages/Material Theme/schemes/Material-Theme-Darker.tmTheme\",\r\n	\"default_browser\": \"chrome\",\r\n	\"ensure_newline_at_eof_on_save\": true,\r\n	\"font_face\": \"Monaco\",\r\n	\"font_size\": 12,\r\n	\"highlight_line\": false,\r\n	\"ignored_packages\":\r\n	[\r\n		\"Vintage\",\r\n		\"Markdown\"\r\n	],\r\n	\"install_prereleases\":\r\n	[\r\n		\"SublimeCodeIntel\"\r\n	],\r\n\r\n    // material theme\r\n	\"material_theme_arrow_folders\": true,\r\n	\"material_theme_compact_sidebar\": true,\r\n	\"material_theme_panel_separator\": true,\r\n	\"material_theme_small_statusbar\": true,\r\n	\"material_theme_small_tab\": true,\r\n	\"statusbar_file_size\": true,\r\n	\"theme\": \"Material-Theme-Darker.sublime-theme\",\r\n\r\n    // sidebar\r\n	\"translate_tabs_to_spaces\": true,\r\n	\"use_powershell\": false,\r\n\r\n    // anaconda\r\n    \"auto_formatting\": true\r\n}\r\n\r\n```\r\n\r\n----------', '1537103132248.jpg', '2019-03-29 05:15:00', '2019-04-02 07:57:06', 'p', '我的每一个动作都有你的印记', 10, 0, 0, 'pinsily', 12);
INSERT INTO `article` VALUES (144, 'python3 -- 时间与时间戳转换', '---\r\n\r\n![](http://csn.pinsily.site/1537103132235.jpg)\r\n\r\n<p><center>你以为这个世界上只有你一个人与众不同么 -- 火影</center></p>\r\n\r\n\r\n\r\n------\r\n### 时间戳转时间\r\n需要注意的是，时间戳有两种级别，毫秒级别和秒级别，我们直接使用 time.time() 返回的带小数点的是秒级别的，而转换也是基于秒级别的，所以转换之前如果是毫秒级别的需要先除于1000进行转换\r\n\r\n\r\n``` python\r\nimport time\r\n\r\nltime = time.localtime(1553917554060/1000)\r\n\r\ntime.strftime(\"%Y-%m-%d %H:%M:%S\", ltime)\r\n```\r\n\r\n----------\r\n### 时间转时间戳\r\n> 时间转成时间戳是秒级的\r\n\r\n#### 时间元组\r\n``` python\r\n>>> import datetime\r\n>>> cdate = datetime.datetime(2019,3,30,20,0,0) \r\n>>> timestamp = time.mktime(cdate.timetuple())\r\n>>> timestamp\r\n1553947200.0\r\n```\r\n#### 字符串时间\r\n\r\n``` python\r\n>>> ctime = \"2019-3-30 20:10:00\"\r\n>>> cdate = time.strptime(ctime, \'%Y-%m-%d %H:%M:%S\')\r\n>>> timestamp = time.mktime(cdate)\r\n>>> timestamp\r\n1553947800.0\r\n```\r\n\r\n----------', '1537103132253.jpg', '2019-03-30 12:15:00', '2019-04-06 00:37:24', 'p', '需要注意的是，时间戳有两种级别，毫秒级别和秒级别，我们直接使用 time.time() 返回的带小数点的是秒', 14, 0, 0, 'pinsily', 6);

SET FOREIGN_KEY_CHECKS = 1;
